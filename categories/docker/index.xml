<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>docker on CaiJingLong</title>
    <link>https://kikt.top/categories/docker/</link>
    <description>Recent content in docker on CaiJingLong</description>
    <generator>Hugo -- gohugo.io</generator>
    <copyright>Copyright © 2008–2018, Steve Francia and the Hugo Authors; all rights reserved.</copyright>
    <lastBuildDate>Sat, 05 Jan 2019 11:13:08 +0800</lastBuildDate><atom:link href="https://kikt.top/categories/docker/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Caddy 初探</title>
      <link>https://kikt.top/posts/server/caddy/caddy-first/</link>
      <pubDate>Sat, 05 Jan 2019 11:13:08 +0800</pubDate>
      
      <guid>https://kikt.top/posts/server/caddy/caddy-first/</guid>
      <description>
        
          
            caddy 是使用 go 语言开发的一个 server 服务器
相对于 nginx 来说,这个部署更简单,配置起来也很简单,很适合搭私人站点使用,而且相比于 nginx 来说,这个只有单文件,很适合小白使用
而且,这东西最大的优点是,可以通过简单的配置来支持 https,而无需操心证书,另外还支持 http2 协议
这里有一份,请注意查收
入手 以 mac os 为例 我只需要 brew install caddy 然后, 运行 caddy,这样就完成了最简单的部署过程...
当然这是因为有默认配置的关系,整个项目是单文件的,就只有一个 caddy 文件
其他系统的参考
运行结果如下 默认是 2015 端口,可能是代表这个项目是 2015 年创建/发布的?
然后打开 就可以看到你的网页了,当然这里因为有默认的原因,你看到的也许是 404,或是其他的什么
自定义配置 caddy 支持命令行的一些简单配置和配置文件的复杂配置
命令行 使用caddy -h 可以看到最新最全的命令行参数列表 这里说命令行运行简单命令的意思并不是支持不全,而是有一些复杂的情况,如果用命令行来做调错比较麻烦
比如 -agree 同意 CA 的协议
-ca XXX 获取指定 host 的 ca 证书
一般情况下比较有用的就是
-conf string 使用配置文件
-email string ca 的 email
          
          
        
      </description>
    </item>
    
    <item>
      <title>Docker 部署二进制</title>
      <link>https://kikt.top/posts/docker/docker-delop-bin-file/</link>
      <pubDate>Fri, 16 Nov 2018 13:39:04 +0800</pubDate>
      
      <guid>https://kikt.top/posts/docker/docker-delop-bin-file/</guid>
      <description>
        
          
            在搜索引擎中,搜索了一下如何部署一个 go 的程序, 发现都是基于 golang 的镜像部署 go 源码的方案
而基于 golang 源码部署 docker image 的大小有 700MB, 有时候并不需要这么大,我们生成二进制文件后 只需要基于 centos 来制作 image 就可以了, 当然如果对于 go 源码有持续部署的需求,那还是只能使用 golang 镜像
 目录结构  完整的目录结构就这么简单, main 是二进制运行文件
main.go 1package main 23import &amp;#34;github.com/gin-gonic/gin&amp;#34; 45func main() { 6g := gin.Default() 78g.LoadHTMLGlob(&amp;#34;static/*&amp;#34;) 910g.GET(&amp;#34;/index&amp;#34;, func(c *gin.Context) { 11c.HTML(200, &amp;#34;index.html&amp;#34;, gin.H{ 12&amp;#34;title&amp;#34;: &amp;#34;标题&amp;#34;, 13}) 14}) 1516g.Run(&amp;#34;:80&amp;#34;) 17} 打包 go 二进制运行文件 这里因为我是 mac 系统,所以我需要交叉编译,具体的交叉编译可以查看我的
1cd main 23CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build main.
          
          
        
      </description>
    </item>
    
    <item>
      <title>Docker-Compose 结合nginx实现跨容器转发</title>
      <link>https://kikt.top/posts/docker/docker-compose-and-nginx-forward/</link>
      <pubDate>Thu, 15 Nov 2018 15:28:11 +0800</pubDate>
      
      <guid>https://kikt.top/posts/docker/docker-compose-and-nginx-forward/</guid>
      <description>
        
          
            开发环境 mac zsh docker-compose
1$ docker-compose --version 2docker-compose version 1.22.0, build f46880f 目录结构  docker-compose.yml 1version:&amp;#34;3&amp;#34;2services:3web:# 服务的名称4image:nginx5volumes:# 文件夹映射6- /Users/cai/Documents/www:/usr/share/nginx/html:ro# 宿主:docker:只读 ,www目录7- ./config/web.conf:/etc/nginx/nginx.conf:ro# nginx配置文件8ports:# 端口转发 宿主:docker9- &amp;#34;8080:80&amp;#34;10- &amp;#34;8081:81&amp;#34;11# environment:12# - NGINX_HOST=foobar.com13# - NGINX_PORT=8014# command: /bin/bash -c &amp;#34;envsubst &amp;lt; /etc/nginx/conf.d/mysite.template &amp;gt; /etc/nginx/conf.d/default.conf &amp;amp;&amp;amp; exec nginx -g &amp;#39;daemon off;&amp;#39;&amp;#34;15networks:## 定义网络16nn:## 加入的网络的名称17ipv4_address:192.168.5.101## ipv4的ip地址1819web8082:20image:nginx21volumes:22- /Users/cai/Documents/www/8082:/usr/share/nginx/html:ro23ports:24- &amp;#34;8082:80&amp;#34;2526networks:27nn:28ipv4_address:192.168.5.1022930web8083:31image:nginx32volumes:33- /Users/cai/Documents/www/8083:/usr/share/nginx/html:ro34ports:35- &amp;#34;8083:80&amp;#34;3637networks:38nn:39ipv4_address:192.168.5.1034041networks:##定义网络组42nn:## 网络组名称43driver:bridge## 网络的模式44ipam:## 配置网络45driver:default46config:47- subnet:192.168.5.0/24## ip地址网络 这里宿主机一般会是该网段的 192.168.5.1,所以不要设置自网段为1配置服务 配置网络
将服务加入同一个网络组,这样 docker 就可以在同一个网络组里了,由于 docker 的特性,每个容器会认为自己和另一个容器是局域网的关系
我这里做的是 nginx 转发
nginx.conf 1user nginx; 2worker_processes 1; 34error_log /var/log/nginx/error.
          
          
        
      </description>
    </item>
    
  </channel>
</rss>
