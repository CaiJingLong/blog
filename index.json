[{"body":"","link":"https://kikt.top/","section":"","tags":null,"title":""},{"body":"","link":"https://kikt.top/categories/","section":"categories","tags":null,"title":"Categories"},{"body":"","link":"https://kikt.top/tags/gradle/","section":"tags","tags":null,"title":"gradle"},{"body":"","link":"https://kikt.top/categories/gradle/","section":"categories","tags":null,"title":"Gradle"},{"body":"Gradle wrapper 这东西不知道什么时候，下载被迁移到了 Github 的 release 里，下载速度骤降，曾几何时 Gradle 团队还高调宣布国内 CDN，现在看来 Gradle 团队也降本增效了。\n解决方案有如下几种，具体使用什么方式，要看你自己的情况。\n直接替换 url 这种情况适用于项目是内部项目或者都是国内人员参与的项目。\n替换方式为直接替换 gradle/wrapper/gradle-wrapper.properties 下的 url 到国内镜像即可， 比如 https://mirrors.cloud.tencent.com/gradle/gradle-8.5-all.zip。\n使用代理 自备\n不能替换的情况 比如某个项目是开源项目，你需要上传到 github，那你就不应该这么做了，你不能假定使用者都是国内的人。 那你就需要研究下正常情况下是放在哪里的了。\n有几种方式，自行下载并复制到对应文件夹下。\n默认情况下，每个版本的 Gradle wrapper 会在 $GRADLE_HOME/wrapper/dists/{version}/{hash} 下 这个 version 是包含类型的，例如 gradle-7.4-all ，是包含 -all 后缀的。 然后 hash 则是 md5 后，生成方法在\n1 2 /** 3 * This method computes a hash of the provided {@code string}. 4 * \u0026lt;p\u0026gt; 5 * The algorithm in use by this method is as follows: 6 * \u0026lt;ol\u0026gt; 7 * \u0026lt;li\u0026gt;Compute the MD5 value of {@code string}.\u0026lt;/li\u0026gt; 8 * \u0026lt;li\u0026gt;Truncate leading zeros (i.e., treat the MD5 value as a number).\u0026lt;/li\u0026gt; 9 * \u0026lt;li\u0026gt;Convert to base 36 (the characters {@code 0-9a-z}).\u0026lt;/li\u0026gt; 10 * \u0026lt;/ol\u0026gt; 11 */ 12 private String getHash(String string) { 13 try { 14 MessageDigest messageDigest = MessageDigest.getInstance(\u0026#34;MD5\u0026#34;); 15 byte[] bytes = string.getBytes(); 16 messageDigest.update(bytes); 17 return new BigInteger(1, messageDigest.digest()).toString(36); 18 } catch (Exception e) { 19 throw new RuntimeException(\u0026#34;Could not hash input string.\u0026#34;, e); 20 } 21 } 这样，我们只需要根据 url 替换，并帮它完成下载步骤即可。\n我也写了一个工具来简化这个步骤，自取。\n","link":"https://kikt.top/posts/gradle/gradle-wapper-mirrors/","section":"posts","tags":["gradle"],"title":"Gradle wrapper 使用国内镜像的那点事"},{"body":"","link":"https://kikt.top/posts/","section":"posts","tags":null,"title":"Posts"},{"body":"","link":"https://kikt.top/tags/","section":"tags","tags":null,"title":"Tags"},{"body":"","link":"https://kikt.top/categories/c/","section":"categories","tags":null,"title":"c"},{"body":"c/c++ 可以说是现代软件的基石，类库繁多，构建工具也很多。\n在介绍构建工具前，我打算梳理一下 c/c++ 体系的一些基本概念。\n1. 编译器 编译器的目的是编译源代码，生成可执行文件或类库文件。\n典型的编译器组成部分如下：\n前端 优化器 后端 嗯？什么，前端不是写 js 的吗？怎么编译器也有前端了？ 请听我娓娓道来\n1.1 前端 编译器的前端不同于软件开发中的前端，它的主要任务是词法分析、语法分析和语义分析。\n词法分析的任务是将源代码分割成一个个的词法单元，比如 int、main、(、)、{、}、;、return、0、;。\n语法分析的任务是将词法单元组合成语法单元，比如 int main() { return 0; }。\n语义分析的任务是检查语法单元是否符合语法规则，比如 int main() { return 0; } 是合法的，而 int main() { return 0 } 是不合法的。\n一般来说，编译器的前端会生成一棵语法树（AST），AST 这个词就很眼熟了，经常在各种演讲炫耀中听到，全称是抽象语法树（Abstract Syntax Tree）。 咱们听到 react/flutter 中的摇树优化（tree shaking）就是摇这个玩意。\n1.2 优化器 优化器在分类时其实属于后端，但是现在通常会单独提出来作为一部分。\n优化器的任务是对语法树进行优化。因为编译的本质是将源码转为二进制，所以优化器的优化目标是二进制代码，而不是源码。\n它可以做一些显而易见的事，比如将 int a = 1 + 2; 优化成 int a = 3;。这样可以减少运行时的执行步骤。 当然，现代的 ide 会提示你合并，但是那和本文无关。\n1.3 后端 后端的任务是将语法树转为目标代码。\n1.4 常见的编译器 在介绍构建工具之前，我们先来看看常见的编译器。\ngcc: GNU Compiler Collection，GNU 的编译器集合，包含了 c/c++ 编译器、汇编器、链接器等。 llvm: Low Level Virtual Machine，低级虚拟机，是一个编译器工具链，包含了编译器前端、优化器、后端、汇编器、链接器等。clang 是 llvm 的一个前端。 msvc: Microsoft Visual C++，微软的 c/c++ 编译器，包含了编译器前端、优化器、后端、汇编器、链接器等。 除此以外，其他的都是偏小众的，就不说了。\n个人建议，如果你是 linux 用户，那么 clang/llvm 是你的首选，如果你是 windows 用户，那么 msvc 是你的首选。 macOS 用户，直接使用 xcode 带的 clang，如果是交叉编译到 Android，可以使用 NDK 中的 clang。\n2. 构建工具 然后，就到了构建工具的时间了。\n为什么需要构建工具？\n因为编译器本质上执行的是一个一个文件的编译，而现代软件的项目通常是由多个文件组成的，所以需要一个工具来协调编译器的工作。 而构建工具就是用来做这个事情的。 它们的主要任务是：\n读取环境变量或构建工具的参数或配置文件 生成编译器的命令行参数 执行编译、链接、打包等操作 有一些常见的构建工具\nAutotools CMake Meson Microsoft Visual Studio Xcode Android Studio 它们涵盖了 99%的场景。\n前三个是跨平台的，后三个是平台相关的。\n2.1 Autotools Autotools 是 GNU 的构建工具，它的主要特点是跨平台，配置编译器、编译参数，然后打包。\n常用步骤是 ./configure、make、make install。\n2.2 CMake CMake 是跨平台的构建工具，它也是目前最流行的构建工具之一。\n常用步骤是 cmake、make、make install。\n2.3 Meson Meson 是跨平台的构建工具，它的主要特点使用了 python 语法，配置文件比 autotools 和 cmake 更加易读。\n常用步骤是 meson、ninja、ninja install。\n2.4 Microsoft Visual Studio Microsoft Visual Studio 是微软的 IDE，它的主要特点是集成了编译器、调试器、构建工具等。 号称宇宙最强 IDE，主要用于 Windows 开发。\n内置的构建工具是 msbuild。\n2.5 Xcode Xcode 是苹果的 IDE，它的主要特点是集成了编译器、调试器、构建工具等。 主要用于 macOS/iOS 开发。\n内置的构建工具是 xcodebuild。\n2.6 Android Studio Android Studio 是谷歌的 IDE，它主要用于 Android 开发。\n内置的构建工具是 gradle。集成的用于构建 c/c++ 的构建工具是 cmake。\n底层的构建工具是 NDK。\nninja or make ninja 和 make 都是构建工具，但与cmake、meson等构建工具不同，它们只负责执行构建。\n因为语法简单、直观，所以很多构建工具都会生成ninja或make的构建文件。 然后通过 ninja 或 make 来执行构建。\nninja 在构建速度评测上完全超越了 make，所以如果你的构建工具支持 ninja，那么就推荐ninja。\n目前，cmake、meson 可以生成 ninja 构建文件。\n3. 调试器 调试器的主要任务是调试程序，它可以让你在程序运行时查看变量的值、执行步骤、堆栈信息等。\n调试器的分类：\n交互式调试器 gdb: GNU Debugger，GNU 的调试器 lldb: Low Level Virtual Machine Debugger，低级虚拟机调试器 非交互式调试器 strace: Linux 的系统调用跟踪工具 dtruss: macOS 的系统调用跟踪工具 3.1 gdb gdb 是 GNU 的调试器，它的主要特点是交互式调试，支持多种语言。\n3.2 lldb lldb 是 LLVM 的调试器，它的主要特点是交互式调试，支持多种语言。\n3.3 strace strace 是 Linux 的系统调用跟踪工具，它的主要特点是非交互式调试，只能跟踪系统调用。\n3.4 dtruss dtruss 是 macOS 的系统调用跟踪工具，它的主要特点是非交互式调试，只能跟踪系统调用。\n4. 其他工具 除了编译器、构建工具、调试器以外，还有一些其他的工具。\n静态分析工具 clang-tidy 动态分析工具 valgrind perf 代码格式化工具 clang-format clang-format-diff clang-tidy-diff 代码检查工具 clang-tidy clang-check 其他工具 git svn hg 4.1 静态分析工具 静态分析工具是用来分析源代码的，它用来检查代码是否符合规范，是否有潜在的 bug 等。\n常用的静态分析工具是 clang-tidy。\n4.2 动态分析工具 动态分析工具是用来分析程序运行时的，它用来检查程序是否有潜在的 bug 等。\n常用的动态分析工具是 valgrind 和 perf。\n4.3 代码格式化工具 代码格式化工具是用来格式化源代码的，它的主要特点是可以统一代码风格。\n常用的代码格式化工具是 clang-format。\n4.4 代码检查工具 代码检查工具是用来检查代码的，它的主要特点是可以检查代码中的 bug。\n常用的代码检查工具是 clang-tidy。\n5. 总结 这篇文章主要介绍了常见的 c/c++ 开发工具，以上。\n","link":"https://kikt.top/posts/c/base/","section":"posts","tags":null,"title":"c/c++ 项目基础"},{"body":"首先，是官方文档 Gradle的插件支持任意的JVM语言来编写，当前最常见的是Java或Kotlin\n插件的类型 通常来说，插件的编写有3个位置\n直接在项目里写脚本，比如kts或者groovy的，好处是简单清晰，但这样的插件问题是无法运行在别的项目，并且不太适合复杂逻辑 在目录里写，好处是可以使用多个文件，并且相对工程化一些，缺点同上 单独的工程，对，插件本身也可以是一个gradle项目，通常一个Gradle plugin会包含多个Task。当然，实际引用时只需要一个jar包即可，无论你项目的类型，并且，可以公开发布到mavenCentral或自己的私服，方便引用，一般来说强烈推荐这种方式 项目脚本的方式 创建一个项目 gradle init --type=basic，然后一路回车默认下来即可 首先，编写一个Plugin，并且引入插件\n1import org.gradle.api.* 2 3class ScriptPlugin implements Plugin\u0026lt;Project\u0026gt;{ 4 @Override 5 public void apply(Project project) { 6 println(\u0026#34;Apply the script plugin\u0026#34;) 7 } 8} 9 10apply plugin: ScriptPlugin // 引入插件 这个插件只会做一个事，输出一行文本 然后，因为这个文件目前还在其他的文件里，我们将这个文件引入项目\n1apply from: \u0026#39;./s.groovy\u0026#39; 在引入前后分别执行 gradle tasks可以得到不同的日志 这里，可以看到这行日志，是执行在 configure project阶段 通常来说，引入插件不是目的，目的是在于添加task，并在后续中使用，我们修改一下插件的源码\n1import org.gradle.api.* 2 3class ScriptPlugin implements Plugin\u0026lt;Project\u0026gt;{ 4 @Override 5 public void apply(Project project) { 6 println(\u0026#34;Apply the script plugin\u0026#34;) 7 // 形参project是当前项目的引用，可以通过task方法添加任务 8 project.task(\u0026#39;say\u0026#39;) { 9 doLast { 10 println(\u0026#39;Say hello\u0026#39;) 11 } 12 description = \u0026#39;Say hello task\u0026#39; // 这个任务的描述，可以通过 gradle tasks --all 查看 13 } 14 } 15} 16 17apply plugin: ScriptPlugin // 引入插件 在修改后，我们使用groovy tasks --all查看一下任务列表 可以看到这里，有了新的task，用gradle -q say执行一下 让插件可以配置 我们通常在使用插件时，会有很多可配置的选项，比如android会让你配置安卓的编译版本、包名、是不是使用ndk等信息，自定义插件也不例外。\n1import org.gradle.api.* 2 3// 定义一个插件的扩展 4abstract class ScriptPluginExtension { 5 abstract Property\u0026lt;String\u0026gt; getMessage() 6 7 ScriptPluginExtension() { 8 message.convention(\u0026#39;hello\u0026#39;) 9 } 10} 11 12class ScriptPlugin implements Plugin\u0026lt;Project\u0026gt;{ 13 @Override 14 public void apply(Project project) { 15 // 形参project是当前项目的引用，可以通过task方法添加任务和通过extension方法添加扩展 16 17 // 这里，就是获取扩展的值 18 def scriptExt = project.extensions.create(\u0026#39;scriptPlugin\u0026#39;, ScriptPluginExtension) 19 // def message = scriptExt.message.get() // 这里要注意，不能在apply方法中获取扩展的值，因为扩展的值是在配置阶段才会被设置的 20 21 project.task(\u0026#39;say\u0026#39;) { 22 doLast { 23 def message = scriptExt.message.get() // 要在运行时才能读取到配置的值 24 println(\u0026#34;Say $message\u0026#34;) 25 } 26 description = \u0026#34;Say task\u0026#34; // 这个任务的描述，可以通过 gradle tasks --all 查看 27 } 28 } 29} 30 31apply plugin: ScriptPlugin // 引入插件 1apply from: \u0026#39;s.groovy\u0026#39; 2 3scriptPlugin { 4 message = \u0026#39;world\u0026#39; 5} ","link":"https://kikt.top/posts/gradle/03/%E7%BC%96%E5%86%99-plugin/","section":"posts","tags":["gradle"],"title":"Gradle 编写Plugin"},{"body":"使用方法 这个东西的使用方法很简单，在项目下创建一个buildSrc文件夹，然后刷新gradle项目即可 Gradle会自动将这个文件夹识别为一个Gradle项目，并支持在项目的build.gradle中引用\n我在项目中创建如下的一个文件夹 buildSrc 1plugins { 2 id \u0026#39;java\u0026#39; 3} 1package top.kikt; 2 3import org.gradle.api.Plugin; 4import org.gradle.api.Project; 5 6public class MyPlugin implements Plugin\u0026lt;Project\u0026gt; { 7 8 @Override 9 public void apply(Project project) { 10 System.out.println(\u0026#34;Apply MyPlugin from project: \u0026#34; + project.getName()); 11 } 12} 1import top.kikt.MyPlugin 2 3plugins { 4 id \u0026#39;java\u0026#39; 5} 6 7group \u0026#39;org.example\u0026#39; 8version \u0026#39;1.0-SNAPSHOT\u0026#39; 9 10repositories { 11 mavenCentral() 12} 13 14dependencies { 15 testImplementation \u0026#39;org.junit.jupiter:junit-jupiter-api:5.8.1\u0026#39; 16 testRuntimeOnly \u0026#39;org.junit.jupiter:junit-jupiter-engine:5.8.1\u0026#39; 17} 18 19test { 20 useJUnitPlatform() 21} 22 23apply plugin: MyPlugin ","link":"https://kikt.top/posts/gradle/01/basic/03-buildsrc/","section":"posts","tags":["gradle"],"title":"Gradle buildSrc"},{"body":"Gradle 推荐使用 Wrapper 的方式来构建工程 Wrapper 根据我的理解，是帮助不同的所有开发同一个项目的人使用相同的 Gradle 版本，从而避免Gradle版本差异带来的问题，而“副作用”就是不同的项目使用相同的 Gradle Wrapper 版本不需要重新下载。\n给项目添加 wrapper 一般来说，如果使用的是 IDE（例如Jetbrains IDEA)或 创建的项目都会包含Wrapper，不需要自行添加。 但如果你的项目是命令创建的，或因为其他原因不包含 wrapper 目录，则需要自行添加 通过如下的代码给项目添加 wrapper，一般来说这取决于你的 gradle 版本，使用 gradle -v 或 gradle --version来查看版本\n1gradle wrapper 使用后，会根据你当前的Gradle版本创建wrapper\n关于版本控制 在版本控制工具上提交项目代码的时候，一定要把wrapper文件夹包含在内。 通常来说，一个带有wrapper的项目根目录会包含 gradlew 和 gradle.bat 文件，前者是给 linux/macOS 使用的，后者是 windows，使用方式是\n1./gradlew xxxx # mac/linux 2gradle.bat xxxx # windows 如果你 clone 的 gradle 项目代码不包含 wrapper 目录，那这个项目的管理者可能不太懂 gradle，很多时候你能跑起他的项目是需要靠运气的，因为不同版本的gradle差异还是存在的。\n版本号 一个典型的包含wrapper的项目结构如下 其中gradle-wrapper.properties文件内会指定了gradle的版本号等信息，一般建议使用对应的all版本，并且，如无特殊情况，新项目建议永远使用当前的最新版\n1distributionBase=GRADLE_USER_HOME 2distributionPath=wrapper/dists 3distributionUrl=https\\://services.gradle.org/distributions/gradle-7.4-bin.zip 4zipStoreBase=GRADLE_USER_HOME 5zipStorePath=wrapper/dists 1distributionUrl=https\\://services.gradle.org/distributions/gradle-7.4-bin.zip 2distributionUrl=https\\://services.gradle.org/distributions/gradle-7.5.1-all.zip ","link":"https://kikt.top/posts/gradle/01/03-gradle_wrapper/","section":"posts","tags":["gradle"],"title":"Gradle Wrapper"},{"body":"Gradle 中存在很多约定式的东西，也就是理论上不支持配置，或者哪怕可以配置，也不建议修改的东西\nbuild.gradle Gradle 构建系统的入口，一般一个gradle项目应该首先看这里，这里会指定项目的几乎所有配置 对于Java项目来说，包含但不仅限于指定项目是java app还是java library，依赖的三方库，源文件包含什么，打包时应该包含的文件，签名方式，上传maven的配置等等\nsettings.gradle 如果是子项目，可能不包含这个文件，但主项目一般都应该包含这个文件，一般情况下，这个文件指定了项目名称和整个工程包含的项目\nbuildSrc 这个文件夹很神奇，这里可以定义你在构建系统中需要用到的源码，计划中，我会单独开一篇文章来聊聊怎么使用和有什么用。 Gradle buildSrc ","link":"https://kikt.top/posts/gradle/01/02-gradle%E7%9A%84%E7%BA%A6%E5%AE%9A%E5%BC%8F%E6%A6%82%E5%BF%B5/","section":"posts","tags":["gradle"],"title":"Gradle 的约定式概念"},{"body":"在 Gradle 中使用 Plugin 大概有如下两种方式\n使用 Gradle 第一方提供的内置插件，或第三方的插件 自己编写的，放在 buildSrc 的 在本篇中插件和 Plugin 为同义 本篇只写如何使用Plugin，关于编写Plugin单独开一篇来写 内置插件 有2种常见的引入模式\n1plugins { 2 id \u0026#39;java\u0026#39; 3} 4 5apply plugin: \u0026#39;java\u0026#39; 6apply plugin: JavaPlugin // 注意这里没有引号，这个 JavaPlugin 是一个 Groovy 对象 这几种是相同的作用 需要注意的一点是，如果是使用 plugins 闭包来引入插件，则要注意顺序，否则会报如下的错，而apply plugin则没有这样的要求\n1only buildscript {}, pluginManagement {} and other plugins {} script blocks are allowed before plugins {} blocks, 2no other statements are allowed 按 Gradle 定义，只有buildscript``pluginManagement两种闭包可以放在这个前面，另外就是其他的 plugins 闭包可以在前面\n三方插件 1plugins { 2 id \u0026#39;com.jfrog.bintray\u0026#39; version \u0026#39;1.8.5\u0026#39; 3 id \u0026#39;com.jfrog.bintray\u0026#39; version \u0026#39;1.8.5\u0026#39; apply false 4} 使用 version 来指定版本号，如果 apply 为false，则表示在子项目中使用，不立即加载\npluginManagement 闭包的使用 按，可以在settings中定义插件版本，然后在build.gradle中使用而不指定版本号，这样的好处是所有子项目的插件版本号保持一致，官方示例如下\n1pluginManagement { 2 plugins { 3 id \u0026#39;com.example.hello\u0026#39; version \u0026#34;${helloPluginVersion}\u0026#34; 4 } 5} 1plugins { 2 id \u0026#39;com.example.hello\u0026#39; 3} 1helloPluginVersion=1.0.0 引入 Script plugin 在中，其他的gradle文件也是plugin，比如\n1apply from: \u0026#39;other.gradle\u0026#39; 找到其他插件 去官方提供的地方找找吧\n","link":"https://kikt.top/posts/gradle/03-plugin/","section":"posts","tags":["gradle"],"title":"Gradle Plugin"},{"body":"创建栈 1tasks.register(\u0026#34;Hello\u0026#34;) { 2 doLast { 3 println(\u0026#34;Run the method do last\u0026#34;) 4 } 5} 使用 gradle -q Hello会得到输出 任务的生命周期 1 2tasks.register(\u0026#34;World\u0026#34;) { 3 println(\u0026#34;Config the world task\u0026#34;) 4 dependsOn(\u0026#34;Hello\u0026#34;) 5 doFirst { 6 println(\u0026#34;World first\u0026#34;) 7 } 8 doLast { 9 println(\u0026#34;World do last\u0026#34;) 10 } 11} 12 13tasks.register(\u0026#34;Hello\u0026#34;) { 14 println(\u0026#34;Config the hello task\u0026#34;) 15 doLast { 16 println(\u0026#34;Hello do last\u0026#34;) 17 } 18 doFirst { 19 println(\u0026#34;Hello do first\u0026#34;) 20 } 21} 22 23tasks.register(\u0026#34;Other\u0026#34;) { 24 println(\u0026#34;Config the other task\u0026#34;) 25} 通过register来注册task，然后通过doLast和doFirst来确定顺序，通过dependsOn来指定是否要依赖其他的Task。有一个叫Other的任务因为没有被依赖，所以干脆就没有被调用，而本身的闭包内的内容是直接调用的，并没有遵循 Task 的依赖顺序，所以闭包内不能做其他任务做过的事。如果需要依赖其他的内容，还是需要在 doLast/doFirst里来做。\n除了任务本身的Task外，项目也可以做全局的task创建的监听，具体的参考。\n","link":"https://kikt.top/posts/gradle/02-task%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E4%BD%BF%E7%94%A8/","section":"posts","tags":["gradle"],"title":"Gradle Task的创建和使用"},{"body":"在我看来，Gradle 中有几项很基础的概念必须提前说明\n概念 Gradle 的约定式概念 ","link":"https://kikt.top/posts/gradle/01-gradle%E7%9A%84%E5%9F%BA%E7%A1%80/","section":"posts","tags":["gradle"],"title":"Gradle 基础"},{"body":"Gradle 本身包含一个命令行工具，正常情况下，Gradle的使用离不开命令行工具 一个正常的Gradle项目应该包含 gradle/wrapper 文件夹，这里会指明你项目使用的Gradle版本，以保证所有项目参与者在不同的系统都使用相同的Gradle版本\n最典型的使用 Gradle中最基本的概念之一，任务（Task），你需要执行哪个任务，就使用gradle [taskName]即可，典型的比如java项目包含的jar，安卓项目包含的assembleRelease，可以使用gradle tasks来查看当前项目包含的所有任务和对应的功能 参数的设置方式，可以在task前也可以在后，有两种参数，一种是有值的，一种是无值的(可以理解为true/false) 有值: --console=plain 无值: --build-cache --no-build-cache，就是在前面加--no-表示false 长参数，短参数的问题，简单来说，短参数有且只有一个字母，长参数就是完整单词，比如：--help``-h，是一个意思\n调用 Task gradle :jar 和 gradle jar 是一个意思 但是当你有子项目的时候，比如你的子项目叫sub1，而根项目和子项目有jartask，那如果想要单独调用子项目的jar task，需要使用 gradle :sub1:jar或gradle sub1:jar\n运行多个 task 当想要调用多个项目时，可以直接把task连续输入，使用空格分割即可，例如 gradle build jar就是同时调用两个task 同时运行多个项目时，gradle 的官方文档说明有如下2点\n尽量快，比如提供并行编译等等 安全，比如 gradle clean build就是先清除再构建，而不会边清除边构建 不执行某特定的 task 按照官网介绍，dist 任务依赖test和compile，同时compile也依赖test，可以使用gradle dist --exclude-task test来跳过test任务，同时也会忽略掉compileTest这种任务\n强制执行所有任务 gradle的任务有缓存机制（)，有的任务在某些时间内只会执行一次，可以强制指定这种任务每次都运行 gradle test --rerun-tasks\n失败，但继续 gradle test --continue Gradle在任何任务发生错误时，会停止所有的任务，通过上面的命令可以在发生错误时完成所有不相干的命令（只要没有依赖关系）。\nTask 名称的简写 这个很有意思，支持驼峰式的简写，比如你有一个任务叫myCompileSource，当然，也支持my-compile-src这种类型的简写 你只需要gradle mCS就可以调用myCompileSource任务\n约定式的任务 build check run clean 所有插件都应该包含的任务\n关于项目的一些报告 1gradle projects # 查看项目 2gradle tasks # 查看任务 3gradle tasks --all # 所有任务 4gradle tasks --group=\u0026#34;build setup\u0026#34; #指定分组的任务 内置任务栈 Gradle 内建有一些任务栈 例如：gradle init 用于初始化一个gradle项目，可以使用 --type 来指定类型\n其他的配置选项 相对于上面的来说，其他的一些选项就不那么重要，到需要的时候再去查文档即可 一些我认为常用的选项 -q可以不输出gradle本身的日志，只输出task相关的 -s运行任务报错的时候用，可以显示错误栈信息 gradle --stop当有些不知道在哪里后台运行的Gradle Task时可以使用这个命令，会停止所有的gradle task，按官方说明，是同一个Gradle版本的 --foreground 后台运行 --status查询任务后台运行的状态\n","link":"https://kikt.top/posts/gradle/01/01-gradle-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/","section":"posts","tags":["gradle"],"title":"Gradle 命令行工具的使用"},{"body":"官方的文档链接，针对的是 7.5.1 版本 本文章对应的所有代码托管在 中\n关于文档 项目可能会混杂 groovy、kotlin、java 的代码 groovy 是因为这是 gradle 默认使用的语言，.gradle 文件都是使用的 groovy 的语法 kotlin则是因为gradle将kt也作为一级语言来使用，扩展名大部分是kts java则是因为偶尔会有buildSrc文件夹内会使用，包括groovy中也会有java语法，因为几乎是完全兼容\n为什么需要 Gradle Gradle 在我的理解就是把复杂的过程简单化的过程，可以使用 Gradle 来构建自己的项目，如果有一个很复杂的项目或者项目是java、kotlin、android这样被gradle支持的类型，也应该使用gradle来完成它。\n","link":"https://kikt.top/posts/gradle/00-gradle-%E5%BC%80%E5%A4%B4/","section":"posts","tags":["gradle"],"title":"Gradle 开始"},{"body":"本文不是从零教 groovy，而是一些基础的 groovy 语法，够用就行 另外，目前Gradle原生支持kts，简单来说就是用kt的语法来配置Gradle，新入门的话足够用 后续的文章会加大kts的使用比例，来替代 groovy\n基础类型 更多的是使用别人提供的插件，我们在使用的时候主要就是配置而已 gradle 脚本中包含了三种使用方式\n闭包 方法 .的调用 其中我们最常见的其实是闭包，其次是方法，最后才是.的调用\n方法 常见的apply其实就是调用 PluginAware.apply方法，from:则属于groovy的语法糖, from是方法的参数，冒号后跟的是参数\n1apply from: \u0026#39;xxx.groovy\u0026#39; // 这里的 apply 是一个自带的方法，使用的参数 2 3// 如果是 Java语法，则是如下写法： 4HashMap\u0026lt;String, ?\u0026gt; applies = new HashMap\u0026lt;String, ?\u0026gt;(); 5applies.put(\u0026#34;plugin\u0026#34;, MyPlugin) 6apply(applies) 然后 java中的方法调用方法是 println(\u0026quot;xxx\u0026quot;);groovy 中可以使用 println \u0026quot;\u0026quot;; 所以，常见的设置maven仓库的方式 maven { url '' }其实是先调用了 方法，然后在闭包中调用 setUrl 方法，参考\n闭包 groovy 的闭包很有意思 大量的闭包的签名是这样的\n1MavenArtifactRepository maven(Action\u0026lt;? super MavenArtifactRepository\u0026gt; action) 然后结合语法糖，形成了如下这种闭包\n1maven { 2 url \u0026#39;xxxx\u0026#39; 3} 其实，这里的maven调用的是方法maven，同时，如果有需要，还可以使用变量来接收返回结果，并修改结果\n. 的方式 1def m = maven { 2 url \u0026#39;xxxx\u0026#39; 3} 4m.url = \u0026#39;yyyy\u0026#39; 这样，会修改 url 的值\n","link":"https://kikt.top/posts/gradle/01/api/groovy-%E8%AF%AD%E6%B3%95/","section":"posts","tags":["gradle"],"title":"Groovy 语法"},{"body":"Project ","link":"https://kikt.top/posts/gradle/01/api/gradle-api/","section":"posts","tags":["gradle"],"title":"Gradle API"},{"body":" Gradle 开始 Gradle 命令行工具的使用 Gradle 基础 Gradle 的约定式概念 Gradle Task的创建和使用 Gradle Wrapper Gradle Plugin Gradle buildSrc Gradle API Groovy 语法 Gradle 编写Plugin ","link":"https://kikt.top/posts/gradle/menu/","section":"posts","tags":["gradle"],"title":"目录 for content/post/gradle"},{"body":"\nClick listeners 示例就是点击会变色，根据是单击双击还是长按，分别修改RGB值。\n1package top.kikt.examples.event.mouse 2 3import androidx.compose.foundation.ExperimentalFoundationApi 4import androidx.compose.foundation.background 5import androidx.compose.foundation.combinedClickable 6import androidx.compose.foundation.layout.Box 7import androidx.compose.foundation.layout.Column 8import androidx.compose.foundation.layout.padding 9import androidx.compose.foundation.layout.size 10import androidx.compose.material.Text 11import androidx.compose.runtime.* 12import androidx.compose.ui.Modifier 13import androidx.compose.ui.graphics.Color 14import androidx.compose.ui.unit.dp 15 16@OptIn(ExperimentalFoundationApi::class) 17@Composable 18fun MouseEventExample() { 19 var redColor by remember { mutableStateOf(0) } 20 var greenColor by remember { mutableStateOf(0) } 21 var blueColor by remember { mutableStateOf(0) } 22 23 var lastEvent by remember { mutableStateOf(\u0026#34;\u0026#34;) } 24 25 val color = Color(redColor, greenColor, blueColor) 26 val textColor = if (redColor + greenColor + blueColor \u0026gt; 128 * 3) Color.Black else Color.White 27 Box( 28 modifier = Modifier 29 .background(color = color) 30 .size(300.dp, 300.dp) 31 .combinedClickable( 32 onClick = { 33 redColor = (redColor + 32) % 256 34 lastEvent = \u0026#34;onClick\u0026#34; 35 }, 36 onDoubleClick = { 37 greenColor = (greenColor + 32) % 256 38 lastEvent = \u0026#34;onDoubleClick\u0026#34; 39 }, 40 onLongClick = { 41 blueColor = (blueColor + 32) % 256 42 lastEvent = \u0026#34;onLongClick\u0026#34; 43 } 44 ) 45 .padding(16.dp) 46 ) { 47 Column { 48 Text(\u0026#34;The color rgb is ($redColor, $greenColor, $blueColor)\u0026#34;, color = textColor) 49 Text(\u0026#34;Last event is $lastEvent\u0026#34;, color = textColor) 50 } 51 } 52} combinedClickable 有一个问题，只支持鼠标左键，如果是右键，就不会触发事件。\nMouse move listeners 核心代码如下，其实就是添加了一个事件，在鼠标移动的时候，就会触发，效果是改变背景颜色\n1.onPointerEvent(PointerEventType.Move) { event -\u0026gt; 2 val position = event.changes.first().position 3 val changed = position.x != lastMoveOffset.x || position.y != lastMoveOffset.y 4 5 if (changed) { 6 lastMoveOffset = position 7 lastEvent = \u0026#34;onPointerEvent Move\u0026#34; 8 redColor = (redColor + 1) % 256 9 greenColor = (greenColor + 1) % 256 10 blueColor = (blueColor + 1) % 256 11 } 12} Mouse enter and exit listeners 核心代码如下，其实就是添加了一个事件，在鼠标进入和离开的时候，就会触发，效果是改变背景颜色\n1@OptIn(ExperimentalComposeUiApi::class) 2@Composable 3private fun MouseEnterExample() { 4 Column { 5 repeat(10) { index -\u0026gt; 6 var isEnter by remember { mutableStateOf(false) } 7 Box( 8 Modifier 9 .size(100.dp, 40.dp) 10 .background(if (isEnter) Color.Red else Color.Green) 11 .onPointerEvent(PointerEventType.Enter) { 12 isEnter = it.type == PointerEventType.Enter 13 } 14 .onPointerEvent(PointerEventType.Exit) { 15 isEnter = it.type == PointerEventType.Enter 16 } 17 ) { 18 Text(\u0026#34;index: $index\u0026#34;) 19 } 20 } 21 } 22} Mouse scroll listeners 核心代码如下，其实就是添加了一个事件，在鼠标滚动的时候，就会触发，效果是改变背景颜色\n1@OptIn(ExperimentalComposeUiApi::class) 2@Composable 3private fun MouseScrollExample() { 4 var scroll by remember { mutableStateOf(0f) } 5 Box( 6 Modifier 7 .fillMaxWidth() 8 .height(200.dp) 9 .background(Color.LightGray) 10 .onPointerEvent(PointerEventType.Scroll) { 11 scroll += it.changes.first().scrollDelta.y 12 } 13 ) { 14 Text(\u0026#34;Scroll y: $scroll\u0026#34;) 15 } 16} Mouse pointer listeners 1@ExperimentalComposeUiApi 2private fun Modifier.onAllPointerEvent( 3 eventTypeList: List\u0026lt;PointerEventType\u0026gt; = listOf( 4 PointerEventType.Enter, 5 PointerEventType.Exit, 6 PointerEventType.Move, 7 PointerEventType.Unknown, 8 PointerEventType.Press, 9 PointerEventType.Release, 10 PointerEventType.Scroll, 11 ), 12 pass: List\u0026lt;PointerEventPass\u0026gt; = listOf(PointerEventPass.Initial, PointerEventPass.Main, PointerEventPass.Final), 13 onEvent: (PointerEventType, PointerEventPass, PointerEvent) -\u0026gt; Unit 14): Modifier { 15 var modifier = this 16 for (pointerEventType in eventTypeList) { 17 for (pointerEventPass in pass) { 18 modifier = modifier.onPointerEvent(pointerEventType, pointerEventPass) { 19 onEvent(pointerEventType, pointerEventPass, it) 20 } 21 } 22 } 23 return modifier 24} 25 26@OptIn(ExperimentalComposeUiApi::class) 27@Composable 28private fun AwtEventExample() { 29 var text by remember { mutableStateOf(\u0026#34;\u0026#34;) } 30 Box( 31 modifier = Modifier 32 .fillMaxSize() 33 .padding(10.dp) 34 .background(Color.White) 35 .onAllPointerEvent { type, pass, event -\u0026gt; 36 val textList = ArrayList\u0026lt;String\u0026gt;() 37 textList.add(\u0026#34;type: $type\u0026#34;) 38 textList.add(\u0026#34;pass: $pass\u0026#34;) 39 textList.add(\u0026#34;event: $event\u0026#34;) 40 val awtEvent = event.awtEventOrNull 41 if (awtEvent != null) { 42 textList.add(\u0026#34;awtEvent: $awtEvent\u0026#34;) 43 } 44 text = textList.joinToString(\u0026#34;\\n\u0026#34;) 45 } 46 ) { 47 Text(text = text) 48 } 49} pointerInput 这个方法是订阅式的接收指针事件，一个实验性方法\n1@Composable 2private fun InputEventExample() { 3 val list = remember { mutableStateListOf\u0026lt;String\u0026gt;() } 4 5 Column( 6 Modifier 7 .fillMaxSize() 8 .pointerInput(Unit) { 9 awaitPointerEventScope { 10 while (true) { 11 val event = awaitPointerEvent() 12 val position = event.changes.first().position 13 if (event.type != PointerEventType.Move) { 14 list.add(0, \u0026#34;${event.type} $position\u0026#34;) 15 } 16 } 17 } 18 }, 19 ) { 20 for (item in list.take(20)) { 21 Text(item) 22 } 23 } 24} ","link":"https://kikt.top/posts/kotlin-compose/kotlin-compose-05-mouse-event/","section":"posts","tags":["Kotlin-Compose"],"title":"Kotlin Compose 05 鼠标事件"},{"body":"","link":"https://kikt.top/tags/kotlin-compose/","section":"tags","tags":null,"title":"Kotlin-Compose"},{"body":"","link":"https://kikt.top/categories/kotlin-compose/","section":"categories","tags":null,"title":"Kotlin-Compose"},{"body":"文档地址\n简单说明 首先，代码部分，我会以 LazyColumn 作为 App 的根容器，这个容器可以简单理解为 ScrollView 和 ListView 的混合体，后面会详细说\n然后每一个子元素会被包裹在一个 item {}闭包内，但每一个都包的话，很不oop，所以，我会略微封装一下，变成下面这样，这样我就可以直接在 MyColumn闭包内写每一个item了\n1@Composable 2fun App() { 3 var text by remember { mutableStateOf(\u0026#34;Hello, World!\u0026#34;) } 4 val platformName = getPlatformName() 5 6 MyColumn { 7 Button(onClick = { 8 text = \u0026#34;Hello, $platformName\u0026#34; 9 }) { 10 Text(text) 11 } 12 } 13 14} 15 16@Composable 17fun MyColumn(content: @Composable LazyItemScope.() -\u0026gt; Unit) { 18 LazyColumn { 19 item { 20 content() 21 } 22 } 23} 加载资源图片 compose 的图片是依托于 androidx.compose.foundation.Image控件来显示的 一个入门级的示例\n1package top.kikt.common.image 2 3import androidx.compose.foundation.Image 4import androidx.compose.foundation.layout.width 5import androidx.compose.runtime.Composable 6import androidx.compose.ui.Modifier 7import androidx.compose.ui.graphics.ImageBitmap 8import androidx.compose.ui.graphics.painter.Painter 9import androidx.compose.ui.graphics.vector.ImageVector 10import androidx.compose.ui.res.loadImageBitmap 11import androidx.compose.ui.res.loadSvgPainter 12import androidx.compose.ui.res.loadXmlImageVector 13import androidx.compose.ui.res.painterResource 14import androidx.compose.ui.unit.Density 15import androidx.compose.ui.unit.dp 16import org.xml.sax.InputSource 17import java.io.File 18import java.net.URL 19 20@Composable 21actual fun ImageExample() { 22 Image( 23 painter = painterResource(\u0026#34;header.svg\u0026#34;), // 支持格式：(BMP, GIF, HEIF, ICO, JPEG, PNG, WBMP, WebP) and vector formats (SVG, XML vector drawable). 24 contentDescription = \u0026#34;Sample\u0026#34;, // 用于无障碍 25 modifier = Modifier.size(200.dp, 200.dp), // 设置约束 26 contentScale = ContentScale.FillBounds, // 设置缩放模式 27 ) 28} painterResource 支持的格式很多\nsupports raster (BMP, GIF, HEIF, ICO, JPEG, PNG, WBMP, WebP) and vector formats (SVG, ).\n异步加载图片 官方给的一个示例，用于使用 io 加载网络图片或 java 的本地文件\n1import androidx.compose.foundation.Image 2import androidx.compose.foundation.layout.Column 3import androidx.compose.foundation.layout.width 4import androidx.compose.runtime.Composable 5import androidx.compose.runtime.getValue 6import androidx.compose.runtime.produceState 7import androidx.compose.runtime.remember 8import androidx.compose.ui.Modifier 9import androidx.compose.ui.graphics.ImageBitmap 10import androidx.compose.ui.graphics.painter.BitmapPainter 11import androidx.compose.ui.graphics.painter.Painter 12import androidx.compose.ui.graphics.vector.ImageVector 13import androidx.compose.ui.graphics.vector.rememberVectorPainter 14import androidx.compose.ui.layout.ContentScale 15import androidx.compose.ui.platform.LocalDensity 16import androidx.compose.ui.res.loadImageBitmap 17import androidx.compose.ui.res.loadSvgPainter 18import androidx.compose.ui.res.loadXmlImageVector 19import androidx.compose.ui.unit.Density 20import androidx.compose.ui.unit.dp 21import androidx.compose.ui.window.singleWindowApplication 22import kotlinx.coroutines.Dispatchers 23import kotlinx.coroutines.withContext 24import org.xml.sax.InputSource 25import java.io.File 26import java.io.IOException 27import java.net.URL 28 29fun main() = singleWindowApplication { 30 val density = LocalDensity.current 31 Column { 32 AsyncImage( 33 load = { loadImageBitmap(File(\u0026#34;sample.png\u0026#34;)) }, 34 painterFor = { remember { BitmapPainter(it) } }, 35 contentDescription = \u0026#34;Sample\u0026#34;, 36 modifier = Modifier.width(200.dp) 37 ) 38 AsyncImage( 39 load = { loadSvgPainter(\u0026#34;https://github.com/JetBrains/compose-jb/raw/master/artwork/idea-logo.svg\u0026#34;, density) }, 40 painterFor = { it }, 41 contentDescription = \u0026#34;Idea logo\u0026#34;, 42 contentScale = ContentScale.FillWidth, 43 modifier = Modifier.width(200.dp) 44 ) 45 AsyncImage( 46 load = { loadXmlImageVector(File(\u0026#34;compose-logo.xml\u0026#34;), density) }, 47 painterFor = { rememberVectorPainter(it) }, 48 contentDescription = \u0026#34;Compose logo\u0026#34;, 49 contentScale = ContentScale.FillWidth, 50 modifier = Modifier.width(200.dp) 51 ) 52 } 53} 54 55@Composable 56fun \u0026lt;T\u0026gt; AsyncImage( 57 load: suspend () -\u0026gt; T, 58 painterFor: @Composable (T) -\u0026gt; Painter, 59 contentDescription: String, 60 modifier: Modifier = Modifier, 61 contentScale: ContentScale = ContentScale.Fit, 62) { 63 val image: T? by produceState\u0026lt;T?\u0026gt;(null) { 64 value = withContext(Dispatchers.IO) { 65 try { 66 load() 67 } catch (e: IOException) { 68 // instead of printing to console, you can also write this to log, 69 // or show some error placeholder 70 e.printStackTrace() 71 null 72 } 73 } 74 } 75 76 if (image != null) { 77 Image( 78 painter = painterFor(image!!), 79 contentDescription = contentDescription, 80 contentScale = contentScale, 81 modifier = modifier 82 ) 83 } 84} 85 86/* Loading from file with java.io API */ 87 88fun loadImageBitmap(file: File): ImageBitmap = 89 file.inputStream().buffered().use(::loadImageBitmap) 90 91fun loadSvgPainter(file: File, density: Density): Painter = 92 file.inputStream().buffered().use { loadSvgPainter(it, density) } 93 94fun loadXmlImageVector(file: File, density: Density): ImageVector = 95 file.inputStream().buffered().use { loadXmlImageVector(InputSource(it), density) } 96 97/* Loading from network with java.net API */ 98 99fun loadImageBitmap(url: String): ImageBitmap = 100 URL(url).openStream().buffered().use(::loadImageBitmap) 101 102fun loadSvgPainter(url: String, density: Density): Painter = 103 URL(url).openStream().buffered().use { loadSvgPainter(it, density) } 104 105fun loadXmlImageVector(url: String, density: Density): ImageVector = 106 URL(url).openStream().buffered().use { loadXmlImageVector(InputSource(it), density) } 107 108/* Loading from network with Ktor client API (https://ktor.io/docs/client.html). */ 109 110/* 111 112suspend fun loadImageBitmap(url: String): ImageBitmap = 113 urlStream(url).use(::loadImageBitmap) 114 115suspend fun loadSvgPainter(url: String, density: Density): Painter = 116 urlStream(url).use { loadSvgPainter(it, density) } 117 118suspend fun loadXmlImageVector(url: String, density: Density): ImageVector = 119 urlStream(url).use { loadXmlImageVector(InputSource(it), density) } 120 121@OptIn(KtorExperimentalAPI::class) 122private suspend fun urlStream(url: String) = HttpClient(CIO).use { 123 ByteArrayInputStream(it.get(url)) 124} 125 126 */ 这里使用了 withContext ，也就是协程来加载图片，然后将 inputStream 传给官网提供的对应方法来加载图片为Painter\nCanvas 类“图片” 其实称呼这种为图片不太准确，只是 Canvas 支持将图片写到画布上而已\n1package top.kikt.common.image 2 3import androidx.compose.runtime.Composable 4import androidx.compose.foundation.Canvas 5import androidx.compose.foundation.layout.size 6import androidx.compose.runtime.remember 7import androidx.compose.ui.Modifier 8import androidx.compose.ui.geometry.Offset 9import androidx.compose.ui.graphics.* 10import androidx.compose.ui.graphics.drawscope.drawIntoCanvas 11import androidx.compose.ui.unit.IntOffset 12import androidx.compose.ui.unit.IntSize 13import androidx.compose.ui.unit.dp 14 15@Composable 16fun ImageExample() { 17 ResImageExample() 18 CanvasImageExample() 19} 20 21@Composable 22fun CanvasImageExample() { 23 val image = Logo() 24 25 Canvas(modifier = Modifier.size(100.dp, 100.dp)) { 26 val redPaint = Paint().apply { 27 color = Color.Red 28 } 29 val bluePaint = Paint().apply { 30 color = Color.Blue 31 } 32 val greenPaint = Paint().apply { 33 color = Color.Green 34 } 35 drawIntoCanvas { canvas: Canvas -\u0026gt; 36 canvas.withSave { 37 canvas.drawCircle(Offset(100f, 100f), 100f, redPaint) 38 canvas.drawCircle(Offset(100f, 100f), 66f, bluePaint) 39 canvas.drawCircle(Offset(100f, 100f), 33f, greenPaint) 40 } 41 } 42 } 43 44 Canvas(modifier = Modifier.size(400.dp, 400.dp)) { 45 drawIntoCanvas { 46 it.withSave { 47 it.drawImageRect( 48 image, 49 IntOffset(0, 0), 50 IntSize(image.width, image.height), 51 IntOffset(0, 0), 52 IntSize(400, 400), 53 Paint(), 54 ) 55 } 56 } 57 } 58} 设置窗口图标 所谓Icon，指的是这个 macOS 上如果是debug运行可以通过最小化窗口来查看 设置 窗口图标是通过设置 Window 的 icon 属性来配置的 Painter 的实现类有这些，理论上可以通过任意一个来实现，支持位图 最简单的，可以设置纯色\n1package top.kikt.image 2 3import androidx.compose.runtime.Composable 4import androidx.compose.ui.graphics.Color 5import androidx.compose.ui.graphics.painter.ColorPainter 6import androidx.compose.ui.graphics.painter.Painter 7 8@Composable 9fun ImageIconPainter(): Painter { 10 return ColorPainter(Color.Blue) 11} 菜单栏图标设置 菜单栏就是这个东西，WIndows 应该是右下角任务栏的那个图标 代码如下\n1package top.kikt.image 2 3import androidx.compose.runtime.Composable 4import androidx.compose.ui.graphics.painter.BitmapPainter 5import androidx.compose.ui.window.ApplicationScope 6import androidx.compose.ui.window.Tray 7 8@Composable 9fun ApplicationScope.TrayWindowPaint() { 10 val icon = Logo() 11 Tray( 12 icon = BitmapPainter(icon), 13 menu = { 14 Item(\u0026#34;Quit App\u0026#34;, onClick = ::exitApplication) 15 }, 16 ) 17} 这里是使用了扩展方法来定义的，因为Tray方法本身是 ApplicatioinScope 的扩展方法，为了在单独文件内定义控件，所以这里使用这种定义方法 menu 就是定义弹出的选项， 使用 Item 方法来定义每个选项即可\n","link":"https://kikt.top/posts/kotlin-compose/kotlin-compose-04-image/","section":"posts","tags":["Kotlin-Compose"],"title":"Kotlin Compose 04 控件 Image"},{"body":"在 Compose 中，有几个基本的概念\n概念 Application Application 是一个 Compose 的应用，它通常是一个顶层的 Composable 函数，它的参数是一个 @Composable 的函数，这个函数就是我们的应用的主体。\nTray Tray 是一个托盘（状态栏的图标），它通常是一个顶层的 Composable 函数，它的参数是一个 @Composable 的函数，这个函数就是我们的托盘的主体。\nWindow Window 是一个窗口，对应了 windows/macOS/Linux 的窗口，它通常是一个顶层的 Composable 函数， 它的参数是一个 @Composable 的函数，这个函数就是我们的窗口的主体。\nWidget Widget 是一个组件，也可以包含多个 Widget，包括 Text，Button，Image 等，都是 Widget，通常是一个 @Composable 函数。\n架构 学会管理 Window 在 Kotlin Compose 中是非常重要的。\nCompose 的结构如下，单Appliction，多 Window，多 Widget\n每个窗口都有独立的Menu\nTray则由Application管理\ngraph TD APP[Appliction]--\u003eW1[Window] W1--\u003eV1[Widget] W1--\u003eV2[Widget] W1--\u003eV3[Widget] APP--\u003eTray[Tray] APP--\u003eW2[Window] W2--\u003eV11[Widget] W2--\u003eV12[Widget] W2--\u003eV13[Widget] 代码的组织 WindowManager 首先，需要配置一个顶层状态来使窗口和窗口状态可以对应上\n1package top.kikt.examples.window 2 3import androidx.compose.runtime.Composable 4import androidx.compose.runtime.mutableStateListOf 5import androidx.compose.ui.window.ApplicationScope 6import androidx.compose.ui.window.MenuBar 7import androidx.compose.ui.window.MenuBarScope 8import androidx.compose.ui.window.Window 9import top.kikt.examples.app.Content 10import top.kikt.examples.example.image.ImageIconPainter 11import top.kikt.examples.menubar.DefaultMenu 12 13/** 14 * 定义一个了一个窗口管理器，用于管理窗口 15 */ 16class WindowManager(private val applicationScope: ApplicationScope) { 17 18 /** 19 * 所有窗口对应的状态 20 */ 21 val windows = mutableStateListOf\u0026lt;WindowState\u0026gt;() 22 23 init { 24 // 打开一个默认的窗口 25 openDefaultWindow() 26 } 27 28 fun openDefaultWindow() { 29 windows += DefaultWindowState(this) 30 } 31 32 fun openNewWindow(state: WindowState) { 33 // 使用新的状态打开一个窗口 34 windows += state 35 println(\u0026#34;Open the new window, the windows count: ${windows.count()}\u0026#34;) 36 } 37 38 // 关闭一个指定的窗口 39 fun close(windowState: WindowState) { 40 windows.remove(windowState) 41 } 42 43 // 用于退出应用 44 @Suppress(\u0026#34;unused\u0026#34;) 45 fun exitApplication() { 46 applicationScope.exitApplication() 47 } 48} 49 50/** 定义一个默认的窗口状态 */ 51abstract class WindowState(private val windowManager: WindowManager) { 52 53 /** 每个状态可以打开新窗口 */ 54 fun openNewWindow( 55 menu: @Composable ((windowState: WindowState, menuBarScope: MenuBarScope) -\u0026gt; Unit)? = { state, scope -\u0026gt; 56 scope.defaultMenu(state) 57 }, 58 content: @Composable (windowState: WindowState) -\u0026gt; Unit, 59 ) { 60 windowManager.openNewWindow(WidgetWindowState(windowManager, content, menu)) 61 } 62 63 /** 默认的菜单栏 */ 64 @Composable 65 protected fun MenuBarScope.defaultMenu(windowState: WindowState) { 66 // 定义一个菜单项 67 DefaultMenu(windowState) 68 } 69 70 /** 关闭窗口 */ 71 fun close() { 72 windowManager.close(this) 73 } 74 75 /** 窗口的内容，抽象化，由子类实现 */ 76 @Composable 77 abstract fun createContent(applicationScope: ApplicationScope) 78} 79 80/** 默认的窗口状态 */ 81private class DefaultWindowState(windowManager: WindowManager) : WindowState(windowManager) { 82 @Composable 83 override fun createContent(applicationScope: ApplicationScope) { 84 Window( 85 onCloseRequest = this::close, 86 title = \u0026#34;Compose for Desktop example\u0026#34;, 87 icon = ImageIconPainter(), 88 ) { 89 Content(this@DefaultWindowState) // 一个默认的窗口内容 90 MenuBar { defaultMenu(this@DefaultWindowState) } // 一个默认的菜单栏 91 } 92 } 93} 94 95/** 用于创建一个窗口，所有内容外部传入 */ 96class WidgetWindowState( 97 windowManager: WindowManager, 98 private val widget: @Composable (windowState: WindowState) -\u0026gt; Unit, 99 private val menu: @Composable ((windowState: WindowState, menuBarScope: MenuBarScope) -\u0026gt; Unit)? = null, 100) : WindowState(windowManager) { 101 102 @Composable 103 override fun createContent(applicationScope: ApplicationScope) { 104 Window( 105 onCloseRequest = { close() }, 106 title = \u0026#34;Compose for Desktop example\u0026#34;, 107 icon = ImageIconPainter(), 108 ) { 109 widget(this@WidgetWindowState) 110 MenuBar { 111 menu?.invoke(this@WidgetWindowState, this) 112 } 113 } 114 } 115} 上面是定义了一个窗口管理器，只需要调用对应的方法就可以管理状态，但是状态有了还需要和应用的窗口对应起来\nCreate application 1import androidx.compose.runtime.* 2import androidx.compose.ui.window.application 3import top.kikt.examples.example.image.TrayWindowPaint 4import top.kikt.examples.window.WindowManager 5 6fun main() = application { 7 val windowManager = remember { WindowManager(this) } 8 9 println(\u0026#34;The windowManager.windows count: ${windowManager.windows.count()}\u0026#34;) 10 11 for (window in windowManager.windows) { 12 key(window) { // 使用窗口状态作为 key，保证窗口状态和窗口的一一对应 13 window.createContent(this) // 然后调用窗口状态的 createContent 方法来创建窗口 14 } 15 } 16 17 if (windowManager.windows.isEmpty()) { 18 TrayWindowPaint(windowManager) // 如果没有窗口，就创建一个托盘窗口，用于打开新窗口 19 } 20} 示例 1@Composable 2@Preview 3fun Content(window: WindowState) { 4 ListView(contentPadding = PaddingValues(10.dp)) { 5 ExampleWindowItem(\u0026#34;Hello World\u0026#34;, window) { 6 HelloWorld() 7 } 8 ExampleWindowItem(\u0026#34;Image\u0026#34;, window) { 9 ImageExample() 10 } 11 ExampleWindowItem(\u0026#34;Mouse Event\u0026#34;, window) { 12 MouseEventExample() 13 } 14 } 15} 16 17@Composable 18fun ExampleWindowItem(title: String, window: WindowState, content: @Composable () -\u0026gt; Unit) { 19 Button(onClick = { 20 window.openNewWindow { content() } 21 }) { 22 Text(\u0026#34;Open Example: $title\u0026#34;) 23 } 24} 预览 ","link":"https://kikt.top/posts/kotlin-compose/kotlin-compose-03-window/","section":"posts","tags":["Kotlin-Compose"],"title":"Kotlin Compose Kotlin Compose 03 Window"},{"body":"开发环境 macOS Idea 2022.2.1 jdk 17 开发环境这里，compose 打包时要求jdk版本大于15，而 java 的 lts 版本是8，11，17，我个人建议直接用17而不是15，开发时运行反而可以使用11，不过我个人觉得直接用17就好了\n创建项目 新建项目，选择 Compose Mutilplatform类型 这里左边可以单独选择支持的类型，右边是多类型（桌面端+安卓） 然后，等待依赖更新完成，我创建的是多类型的项目\n看看配置文件 项目的配置文件是 kts 文件，这是 Gradle 项目 groovy 以外的另一种一级语言，使用 kotlin 语法，相比 groovy 来说，语法更加的“严谨”\nsettings.kts 1// Copyright 2000-2022 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license. 2pluginManagement { // 这个闭包是用于配置项目中用到的 plugin 的一些配置，以便做到不同的 module 使用相同的配置 3 repositories { // 配置仓库 4 google() // 因为引入了安卓项目， google 仓库就是必须了的 5 gradlePluginPortal() // 这个是 gradle 的插件目录，一般很少用到 6 mavenCentral() 7 maven(\u0026#34;https://maven.pkg.jetbrains.space/public/p/compose/dev\u0026#34;) // kotlin compose 目前很多文件还是使用的这个仓库 8 } 9 10 plugins { // 这个闭包内指定了所有 plugin 的版本号，如果这里不指定，则子module中需要单独引入 11 // extra[key] 是读取了 gradle.properties 中定义的版本号 12 13 kotlin(\u0026#34;multiplatform\u0026#34;).version(extra[\u0026#34;kotlin.version\u0026#34;] as String) 14 kotlin(\u0026#34;android\u0026#34;).version(extra[\u0026#34;kotlin.version\u0026#34;] as String) 15 id(\u0026#34;com.android.application\u0026#34;).version(extra[\u0026#34;agp.version\u0026#34;] as String) 16 id(\u0026#34;com.android.library\u0026#34;).version(extra[\u0026#34;agp.version\u0026#34;] as String) 17 id(\u0026#34;org.jetbrains.compose\u0026#34;).version(extra[\u0026#34;compose.version\u0026#34;] as String) 18 } 19} 20 21rootProject.name = \u0026#34;KotlinComposeExample2\u0026#34; 22 23include(\u0026#34;:android\u0026#34;, \u0026#34;:desktop\u0026#34;, \u0026#34;:common\u0026#34;) \u0026lt;root\u0026gt;/build.gradle.kts 1group \u0026#34;top.kikt\u0026#34; 2version \u0026#34;1.0-SNAPSHOT\u0026#34; 3 4allprojects { // 给所有子项目做配置 5 repositories { // 给所有子项目指定仓库 6 google() 7 mavenCentral() 8 maven(\u0026#34;https://maven.pkg.jetbrains.space/public/p/compose/dev\u0026#34;) 9 } 10} 11 12plugins { // 配置插件， apply false 是懒加载 13 kotlin(\u0026#34;multiplatform\u0026#34;) apply false 14 kotlin(\u0026#34;android\u0026#34;) apply false 15 id(\u0026#34;com.android.application\u0026#34;) apply false 16 id(\u0026#34;com.android.library\u0026#34;) apply false 17 id(\u0026#34;org.jetbrains.compose\u0026#34;) apply false 18} android/build.gradle.kts 安卓子项目的配置文件\n1plugins { 2 id(\u0026#34;org.jetbrains.compose\u0026#34;) 3 id(\u0026#34;com.android.application\u0026#34;) 4 kotlin(\u0026#34;android\u0026#34;) 5} 6 7group \u0026#34;top.kikt\u0026#34; 8version \u0026#34;1.0-SNAPSHOT\u0026#34; 9 10repositories { 11 jcenter() 12} 13 14dependencies { 15 implementation(project(\u0026#34;:common\u0026#34;)) // 相比传统项目只有这一点不太一样 16 implementation(\u0026#34;androidx.activity:activity-compose:1.3.0\u0026#34;) 17} 18 19android { 20 compileSdkVersion(31) 21 defaultConfig { 22 applicationId = \u0026#34;top.kikt.android\u0026#34; 23 minSdkVersion(24) 24 targetSdkVersion(31) 25 versionCode = 1 26 versionName = \u0026#34;1.0-SNAPSHOT\u0026#34; 27 } 28 compileOptions { 29 sourceCompatibility = JavaVersion.VERSION_1_8 30 targetCompatibility = JavaVersion.VERSION_1_8 31 } 32 buildTypes { 33 getByName(\u0026#34;release\u0026#34;) { 34 isMinifyEnabled = false 35 } 36 } 37} desktop/build.gradle.kts 桌面子项目的配置文件\n1import org.jetbrains.compose.compose 2import org.jetbrains.compose.desktop.application.dsl.TargetFormat 3import org.jetbrains.kotlin.gradle.tasks.KotlinCompile 4 5plugins { 6 kotlin(\u0026#34;multiplatform\u0026#34;) 7 id(\u0026#34;org.jetbrains.compose\u0026#34;) 8} 9 10group = \u0026#34;top.kikt\u0026#34; 11version = \u0026#34;1.0-SNAPSHOT\u0026#34; 12 13 14kotlin { 15 jvm { 16 compilations.all { 17 kotlinOptions.jvmTarget = \u0026#34;11\u0026#34; 18 } 19 withJava() 20 } 21 sourceSets { 22 val jvmMain by getting { 23 dependencies { 24 implementation(project(\u0026#34;:common\u0026#34;)) 25 implementation(compose.desktop.currentOs) // 插件会识别当前的开发平台 26 } 27 } 28 val jvmTest by getting 29 } 30} 31 32compose.desktop { 33 application { 34 mainClass = \u0026#34;MainKt\u0026#34; 35 nativeDistributions { 36 targetFormats(TargetFormat.Dmg, TargetFormat.Msi, TargetFormat.Deb) 37 packageName = \u0026#34;KotlinComposeExample2\u0026#34; 38 packageVersion = \u0026#34;1.0.0\u0026#34; 39 } 40 } 41} common/build.gradle.kts 公用部分的配置文件\n1import org.jetbrains.compose.compose 2 3plugins { // 这里的插件都不需要再指定版本号，因为在 settings.gradle.kts 里配置过了 4 kotlin(\u0026#34;multiplatform\u0026#34;) 5 id(\u0026#34;org.jetbrains.compose\u0026#34;) 6 id(\u0026#34;com.android.library\u0026#34;) 7} 8 9group = \u0026#34;top.kikt\u0026#34; 10version = \u0026#34;1.0-SNAPSHOT\u0026#34; 11 12kotlin { 13 android() 14 jvm(\u0026#34;desktop\u0026#34;) { 15 compilations.all { 16 kotlinOptions.jvmTarget = \u0026#34;11\u0026#34; 17 } 18 } 19 sourceSets { 20 // 这里会有几处子项目的配置，所有的 dependencies 都需要配置在这里 21 val commonMain by getting { 22 dependencies { 23 api(compose.runtime) 24 api(compose.foundation) 25 api(compose.material) 26 } 27 } 28 val commonTest by getting { 29 dependencies { 30 implementation(kotlin(\u0026#34;test\u0026#34;)) 31 } 32 } 33 val androidMain by getting { 34 dependencies { 35 api(\u0026#34;androidx.appcompat:appcompat:1.2.0\u0026#34;) 36 api(\u0026#34;androidx.core:core-ktx:1.3.1\u0026#34;) 37 } 38 } 39 val androidTest by getting { 40 dependencies { 41 implementation(\u0026#34;junit:junit:4.13\u0026#34;) 42 } 43 } 44 val desktopMain by getting { 45 dependencies { 46 api(compose.preview) 47 } 48 } 49 val desktopTest by getting 50 } 51} 52 53android { 54 compileSdkVersion(31) 55 sourceSets[\u0026#34;main\u0026#34;].manifest.srcFile(\u0026#34;src/androidMain/AndroidManifest.xml\u0026#34;) 56 defaultConfig { 57 minSdkVersion(24) 58 targetSdkVersion(31) 59 } 60 compileOptions { 61 sourceCompatibility = JavaVersion.VERSION_1_8 62 targetCompatibility = JavaVersion.VERSION_1_8 63 } 64} 运行项目 桌面端的入口文件\n1// Copyright 2000-2021 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file. 2import androidx.compose.ui.window.Window 3import androidx.compose.ui.window.application 4import top.kikt.common.App 5 6 7fun main() = application { 8 Window(onCloseRequest = ::exitApplication) { 9 App() 10 } 11} 1package top.kikt.common 2 3import androidx.compose.material.Text 4import androidx.compose.material.Button 5import androidx.compose.runtime.Composable 6import androidx.compose.runtime.getValue 7import androidx.compose.runtime.mutableStateOf 8import androidx.compose.runtime.remember 9import androidx.compose.runtime.setValue 10 11@Composable 12fun App() { 13 var text by remember { mutableStateOf(\u0026#34;Hello, World!\u0026#34;) } 14 val platformName = getPlatformName() 15 16 Button(onClick = { 17 text = \u0026#34;Hello, ${platformName}\u0026#34; 18 }) { 19 Text(text) 20 } 21} 点击运行\n点击后变成了下面这样 ","link":"https://kikt.top/posts/kotlin-compose/kotlin-compose-02-create-project/","section":"posts","tags":["Kotlin-Compose"],"title":"Kotlin Compose Kotlin Compose 02 Create Project"},{"body":"Kotlin compose 是啥玩意 用 kotlin 开发桌面应用的东西，Jetbrains 出品\n优势 Kotlin compose 在我看来，是一个很“巧妙”的东西，虽然这东西是 Jetbrains 开发的，但是使用了 Google 安卓的 Jetpack compose 的 api，这就造成了如下的优势\n可以在满足一定条件的前提下，将业务逻辑由安卓端快速迁移到桌面端，共用部分代码，求同存异 利用 jvm 体系强大的三方库来快速开发 帮助不熟悉桌面开发的小伙伴使用更加“移动端”的思想来看待桌面端 文档 基于 2022-10-18 的情况，有很多的文档\n","link":"https://kikt.top/posts/kotlin-compose/kotlin-compose-01-start/","section":"posts","tags":["Kotlin-Compose"],"title":"Kotlin Compose Kotlin Compose 01 Start"},{"body":"","link":"https://kikt.top/tags/java/","section":"tags","tags":null,"title":"java"},{"body":"","link":"https://kikt.top/categories/java/","section":"categories","tags":null,"title":"java"},{"body":"","link":"https://kikt.top/tags/javassist/","section":"tags","tags":null,"title":"Javassist"},{"body":"本篇仅用于记录本人学习javassist的过程, 其中任何步骤或思想被用于非法用途与本人无关\n环境介绍 macOS Jdk8, 因为我是安卓开发, 事实上理论上也支持 14(未实测) Intellij Idea 社区版 javassist 简介 javassist 是什么东西 首先, 放上, 简而言之, 这东西是一个库, 可以用来修改 java 的字节码\n同时, 这东西不需要你了解太多的 class 在储存为.class 文件时的储存方式, 但需要你对于 java 反射有一定的了解, 因为这东西是以 jar 包的方式引入到 java 应用中, 然后可以通过封装的方式来修改 class 内方法实现\n包含但不限于如下功能\n添加,删除字段, 方法, 类. 包 修改方法, 类可见性 修改方法的实现体 应用范围 那么, 这东西有啥用呢?\n比如, 有一个库是上古时期的人提供的, 没有源码, 没有文档, 开发者早联系不上了, 但我们可能需要修改其中的一个实现\n你可能会想: 反编译啊, 重打包啊\n但事实上很难行得通, 因为你重新编译时可能需要找到它当时依赖的所有 jar 包, 然后循环依赖引入, 或者可能你的 jar 包是一个安卓 jar 包, 所以需要安卓环境, 而把 android.jar 包引入 java 工程, 想想就很带感\n而使用 javassist, 这步会显得很简单\n示例 新建一个项目\n引入 javassist, 本地引入或 maven, gradle 什么的都随你习惯, 我这里用的是 gradle+本地 jar 包\n编写代码 原始代码 1package top.kikt; 2 3public class User { 4 5 void say() { 6 System.out.println(\u0026#34;The user say!\u0026#34;); 7 } 8 9} 1package top.kikt; 2 3public class HelloWorld { 4 5 public static void main(String[] args) { 6 User user = new User(); 7 user.say(); 8 } 9} 嗯 就这样, 这个简单的项目就这样, 运行结果也很简单, 就是The user say!\n修改 say 的实现 1package top.kikt; 2 3import javassist.*; 4 5import java.io.IOException; 6 7public class Crack { 8 9 public static void main(String[] args) throws NotFoundException, CannotCompileException, IOException { 10 ClassPool pool = ClassPool.getDefault(); 11 CtClass ctClass = pool.get(\u0026#34;top.kikt.User\u0026#34;); 12 CtMethod[] says = ctClass.getDeclaredMethods(\u0026#34;say\u0026#34;); 13 CtMethod say = says[0]; 14 say.setBody(\u0026#34;{System.out.println(\\\u0026#34;The user crack say!\\\u0026#34;);}\u0026#34;); 15 16 ctClass.writeFile(\u0026#34;build/crack/java/main\u0026#34;); 17 } 18 19} 我这里就是简单的修改了 say 的实现, 简单分析\n获取一个 pool, 这个东西可以说是 assist 的核心类了, 根据类名, 获取 User 类的字节码 然后找到 say 方法, 因为我们有源码, 所以可以确定序号 0 就是这个方法 然后 setBody 就是新实现了 class.writeFile 这东西很有意思, 会按正规 jar 包的内 class 的储存方式生成 class 文件 实现修改 打包旧实现 1./gradlew jar 这样会在 build/libs 下生成一个 jar 包\n我们运行一下:\njava -cp build/libs/CrackTest-1.0-SNAPSHOT.jar top.kikt.HelloWorld\n我们看到, 实现的 User.java 里的内容\n生成 class 文件 接着就是运行这个 Crack.main 方法了\n我们通过 idea 自带的 class 文件查看器看到, say 方法的实现果然变了\n合并 class 和 jar 包 这一步需要利用 jar 命令, 这个命令是 jdk 自带的\n1$ which jar 2/Library/Java/JavaVirtualMachines/jdk1.8.0_181.jdk/Contents/Home/bin/jar 3 4$ jar 5用法: jar {ctxui}[vfmn0PMe] [jar-file] [manifest-file] [entry-point] [-C dir] files ... 6选项: 7 -c 创建新档案 8 -t 列出档案目录 9 -x 从档案中提取指定的 (或所有) 文件 10 -u 更新现有档案 11 -v 在标准输出中生成详细输出 12 -f 指定档案文件名 13 -m 包含指定清单文件中的清单信息 14 -n 创建新档案后执行 Pack200 规范化 15 -e 为捆绑到可执行 jar 文件的独立应用程序 16 指定应用程序入口点 17 -0 仅存储; 不使用任何 ZIP 压缩 18 -P 保留文件名中的前导 \u0026#39;/\u0026#39; (绝对路径) 和 \u0026#34;..\u0026#34; (父目录) 组件 19 -M 不创建条目的清单文件 20 -i 为指定的 jar 文件生成索引信息 21 -C 更改为指定的目录并包含以下文件 22如果任何文件为目录, 则对其进行递归处理。 23清单文件名, 档案文件名和入口点名称的指定顺序 24与 \u0026#39;m\u0026#39;, \u0026#39;f\u0026#39; 和 \u0026#39;e\u0026#39; 标记的指定顺序相同。 25 26示例 1: 将两个类文件归档到一个名为 classes.jar 的档案中: 27 jar cvf classes.jar Foo.class Bar.class 28示例 2: 使用现有的清单文件 \u0026#39;mymanifest\u0026#39; 并 29 将 foo/ 目录中的所有文件归档到 \u0026#39;classes.jar\u0026#39; 中: 30 jar cvfm classes.jar mymanifest -C foo/ . 和 tar 的用法差不多, 总体来说就是\n1jar uvf xxx.jar xxx.class xxx.class 大概就是这样, 但我们的 jar 在 build/libs 目录里, 而其他的在 crack 目录里, 所以这里我编写一个简单的脚本来做这个事\n1touch merge_class.sh 2chmod +x *.sh merge_class.sh\n1ROOT_PATH=$PWD 2cd build/crack/java/main 3jar uvf $ROOT_PATH/build/libs/CrackTest-1.0-SNAPSHOT.jar . # 不要忘记最后的点 简单解释一下, u是工作模式, 更新现有的jar包, v是日志, f 是指定目录, 工作目录如果不是class目录, 则打包成jar的时候\n脚本运行结果:\n1$ ./merge_class.sh 2正在添加: top/(输入 = 0) (输出 = 0)(存储了 0%) 3正在添加: top/kikt/(输入 = 0) (输出 = 0)(存储了 0%) 4正在添加: top/kikt/User.class(输入 = 452) (输出 = 311)(压缩了 31%) 1java -cp build/libs/CrackTest-1.0-SNAPSHOT.jar top.kikt.HelloWorld 实现修改成功了!\n核心类的简单说明 ClassPool, 核心类, 一般可以用过ClassPool.getDefault获取默认实例 CtClass, 表示类 转 java 的 Class 类: ctClass.toClass() 创建新的: pool.makeClass 获取已有的类, pool.get(String name) CtField, 表示字段(成员变量) 获取所有的: ctClass.getFields() 根据名字获取: ctClass.getField(String name) CtMethod, 表示方法 ctClass.getMethods() ctClass.getMethod(String name) 后记 本篇就简单的演示了一下入门级使用, 预计下篇写一些实际项目中的使用\n以上\n","link":"https://kikt.top/posts/java/crack/crack1/","section":"posts","tags":["java","Javassist"],"title":"使用javassist,修改jar包方法实现"},{"body":"","link":"https://kikt.top/tags/actions/","section":"tags","tags":null,"title":"actions"},{"body":"","link":"https://kikt.top/tags/flutter/","section":"tags","tags":null,"title":"flutter"},{"body":"","link":"https://kikt.top/categories/github/","section":"categories","tags":null,"title":"github"},{"body":"Github action 这东西是好东西, 但我看了一下, 很多朋友都是停留在用的阶段, 其实偶尔也要换换口味, 自己开发一个 action, 而不是仅仅是用\n简介 github actions 是 github 推出的一个工作流的工具, 目的是为了帮助我们在某些情况下主动触发仓库的动作, 从而完成 单元测试/CI/CD, 甚至包括 release,发布包管理工具等等\n官方关于 actions 有关的一些仓库都在这里: , github 的主语言是 js, 当然也肯定也支持 ts\n另外如果对于速度需求并不高的朋友, 也可以使用 docker, 但因为 docker 安装的过程会根据镜像大小有一定的耗时, 所以不一定适用于所有朋友\n如果，你对于本文章不是很感兴趣，可以参考\n新建 因为我对于 js 比较不喜欢, 所以使用 ts(虽然也不是很感冒, 但是会好一点)\n进入这个, 然后使用 按钮, 完成初始化的过程.\n这里我们创建一个仓库, 这个仓库的目的是自动给 issue 打上 label\n初始化后的仓库 简单介绍一下这个仓库, 有一些文件和注意事项\naction.yml 是 action 本身的配置文件(别的项目实际就是读取这个东西来确定入口在哪里), 包括参数的配置都是这东西 一个标准的 npm 项目, 指定了入口 src 内是主要的 ts 代码 ts 代码需要被编译为 js 才能使用 dist 内就是编译产物, git 的版本控制需要包含 dist 下的所有文件, 不然运行的时候会是老代码 项目本身自带 action, 主要是 CI 这个项目的 入门 开发环境 vscode, 我这里是使用 vscode 进行编辑, 你请根据自己的情况 npm(node), 我是使用 nvm 管理的 如果你的 node 大于 12.0, 理论上不用动\nclone 项目 1git clone https://github.com/CaiJingLong/action_auto_label.git 2cd action_auto_label 3npm i 官方支持库 包含了 github 官方支持的一些库, 就不一一介绍了\nactions 的核心库, 会被默认包含 如果你需要执行 cli 工具, 比如 ls, mkdir, 之类的操作, 可以用这个, 可以便利的封装过程和日志输出之类的东西 glob 匹配文件, 我们都知道 ls *.sh 这样的东西, 这个*就是 glob, 而不是正则 github 的封装, 这东西就包含了操作 github 本身的操作 因为本篇要操作 github, 所以我们把这个东西加入以下\nnpm i @actions/github\nHello world 这里要注意, ts 中不建议我们使用console.log来输出日志, 所以我们这里使用core.info方法来输出\n老规矩, 先 hello world 一下.\nsrc/main.ts\n1import * as core from \u0026#34;@actions/core\u0026#34;; 2 3async function run(): Promise\u0026lt;void\u0026gt; { 4 try { 5 core.info(`Hello world`); 6 } catch (error) { 7 core.setFailed(error.message); 8 } 9} 10 11run(); .github/workflows/issue.yml\n1name: \u0026#34;On issue\u0026#34; 2on: 3 issue: 4 types: [opened, reopened, edited] 5jobs: 6 build: 7 runs-on: ubuntu-latest 8 steps: 9 - uses: actions/checkout@v2 10 - uses: ./ npm run all 打包, 这一步很重要, 不然 dist 不会生效, 可以考虑使用 git hooks 来做\n然后是 push 代码, 接着 新建一个 issue 来触发一下\nissue 报错了, 说不是合法的 event name. 好吧, 这里需要修改为 issues, 我们重新提交一下, 然后再触发它. 因为这里有 edited 可以触发, 我们修改一下 issue 的内容, 然后重新 commit\n1name: \u0026#34;On issue\u0026#34; 2on: 3 issues: 4 types: [opened, reopened, edited] 5jobs: 6 build: 7 runs-on: ubuntu-latest 8 steps: 9 - uses: actions/checkout@v2 10 - uses: ./ 这次, 成功触发了 action, 并且输出了 Hello world.\naction.yml 配置 前面说过, 这个文件是 action 的配置文件(或者可以叫清单文件), 其中有一些配置选项\n在 actions 中可以配置参数, 以便于从外部传入, 默认的\n默认的文件内容如下:\n1name: \u0026#34;Your name here\u0026#34; # 顾名思义, action的名字 2description: \u0026#34;Provide a description here\u0026#34; # 对于action的说明 3author: \u0026#34;Your name or organization here\u0026#34; # 作者名/组织名/email 之类的信息 4inputs: # 参数的字典 5 milliseconds: # change this # 参数名, 6 required: true # 是否是必填 7 description: \u0026#34;input description here\u0026#34; # 参数的说明 8 default: \u0026#34;default value if applicable\u0026#34; # 默认值 9runs: # 运行的环境 10 using: \u0026#34;node12\u0026#34; # 运行环境为 node12 11 main: \u0026#34;dist/index.js\u0026#34; # 入口文件, 就是这个东西要求我们必须编译ts为js后才可用 看过了默认文件内容后, 我们要开始尝试修改了, 我们通过文档得知, 有如下的配置参数\n在配置中没有出现的 2 个参数\noutputs: 输出参数, 因为各个 action 之间其实互相是不知道的, 用这个, 可以做到约定式输出, 比如我在 actions 1 里执行了某个东西, 并将其中计算的结果放到这个参数内, 后面就可以用了, 可以简单理解为 action 的返回值 branding: action 对应的徽章样式, 是在里的样子 我们知道 runs 支持三种形式\njs(本篇就用的这个) composite: 复合式, 其实就是使用 linux 命令(当然如果是 macos 设备, 理论上也支持), shell 脚本 Docker: 使用 docker 环境，优点就不多说了, 配置方便, 普适性较强, 缺点是没有 js 和 composite 快, 毕竟加载 docker 需要时间, 镜像越大速度越慢 inputs 有一个需要注意的点: 在 js 代码里获取的时候, 使用原名称即可, 但如果你是在 shell 里使用(composite, 或其他语言, 比如 docker 使用 c 语言或者 java 等等), 则需要通过 INPUT_\u0026lt;VARIABLE_NAME\u0026gt;的名称在环境变量里获取\n简单的概念完成了, 接着我们就来实战一下\n环境变量 环境变量就是你在配置自己的工作流时, 可以使用 $ENV_VAR这种方式来使用环境变量, 至于来源, 看, 包括但不仅限于$HOME,$GITHUB_WORKSPACE之类的, 具体看官方文档\n配置敏感信息的问题 我们都知道, 很多情况下, 项目有一些隐秘信息, 不能直接配置在项目内, 包括但不仅限于:\ngithub token 各种账号的用户名密码 私钥信息 各种网站的 api key,app key, secret key 等等 这时候, 就需要有一些技巧来配置它们, 并在代码中读取, 配置 这一步是在 github 仓库的 setting 里完成的\n这里看到, 我们虽然用的是小写, 但是实际上写入的时候会是大写, 这里需要注意一下\n读取 这个读取的过程并不是在 js 代码中, 而是在 yml 中配置, 配置成 inputs 的值,既然需要值, 就需要对于的预配置, 然后通过 ${{secrets.\u0026lt;VAR_NAME\u0026gt; }}的方式来获取\n先定义一个选项以便于外部知道, 我们需要这个, 反应到项目中就是action.yml 1name: \u0026#34;Auto label\u0026#34; 2description: \u0026#34;Automation generate label for issues.\u0026#34; 3author: \u0026#34;Caijinglong\u0026#34; 4inputs: 5 user_name: 6 required: true 7 description: \u0026#34;User name\u0026#34; 8runs: 9 using: \u0026#34;node12\u0026#34; 10 main: \u0026#34;dist/index.js\u0026#34; 配置 workflow: .github/workflows/issue.yml\n1name: \u0026#34;On issue\u0026#34; 2on: 3 issues: 4 types: [opened, reopened, edited] 5jobs: 6 build: 7 runs-on: ubuntu-latest 8 steps: 9 - uses: actions/checkout@v2 10 - uses: ./ 11 with: 12 user_name: ${{ secrets.USER_NAME }} 测试下 1import * as core from \u0026#34;@actions/core\u0026#34;; 2 3async function run(): Promise\u0026lt;void\u0026gt; { 4 try { 5 core.info(`Hello world`); 6 const username = core.getInput(\u0026#34;user_name\u0026#34;); 7 core.info(`Hello ${username}`); 8 9 core.info(`username === admin : ${username === \u0026#34;admin\u0026#34;}`); 10 } catch (error) { 11 core.setFailed(error.message); 12 } 13} 14 15run(); 经常 push, 老要修改东西, 很麻烦, 简单些个推送脚本\n1touch push.sh 2chmod +x push.sh 3echo \u0026#34;npm run all \u0026amp;\u0026amp; git add . \u0026amp;\u0026amp; git commit -m \u0026#39;push with shell\u0026#39; \u0026amp;\u0026amp; git push\u0026#34; \u0026gt; push.sh 4 5./push.sh 然后就是使用 open issue 的方式触发了\n然后, 嗯, 结果是这样的, 这里的*** 就是被'安全化'过的, 鉴于我们 admin 是手输入的, 但是''碰巧''和 secret 里配置的一样, 所以一起被打码了, 然后, 结果是 true, 说明吧, 虽然这里被打码了, 但是并不影响真实的运行结果\n前面简单的入门配置都完成了, 接下来简单的实战一下\n实战 本篇的 action 项目是自动根据 issue 标题决定添加 issue label\n使用 github api 学习下如何使用 api, 这里使用@actions/github提供的能力\n1import * as github from \u0026#39;@actions/github\u0026#39; 2 3... 4core.info(`event name = ${github.context.eventName}`) 结果就是这样\ngithub 配置 label 先思考步骤\n获取所有的 label 匹配 issue 标题, 使用正则获取开头的[]内的内容如[bug] 标题的, 自动标注 bug label, feature/feature request 之类的自动标注 feature, 有就创建, 没有就不管 核心代码:\n1import * as core from \u0026#34;@actions/core\u0026#34;; 2import * as github from \u0026#34;@actions/github\u0026#34;; 3import * as Webhooks from \u0026#34;@octokit/webhooks\u0026#34;; 4 5export async function run(githubToken: string): Promise\u0026lt;void\u0026gt; { 6 try { 7 if (github.context.eventName !== \u0026#34;issues\u0026#34;) { 8 core.info( 9 `目前仅支持 issues 触发, 你的类型是${github.context.eventName}` 10 ); 11 return; 12 } 13 core.info(`The run token = \u0026#39;${githubToken}\u0026#39;`); 14 15 const payload = github.context 16 .payload as Webhooks.EventPayloads.WebhookPayloadIssues; 17 18 core.info(`Hello world`); 19 const username = core.getInput(\u0026#34;user_name\u0026#34;); 20 core.info(`Hello ${username}`); 21 22 core.info(`username === admin : ${username === \u0026#34;admin\u0026#34;}`); 23 24 core.info(`event name = ${github.context.eventName}`); 25 26 const octokit = github.getOctokit(githubToken); 27 28 const { owner, repo } = github.context.repo; 29 const issue_number = payload.issue.number; 30 const regex = /\\[([^\\]]+)\\]/g; 31 const array = regex.exec(payload.issue.title); 32 33 core.info( 34 `触发的issue : owner: ${owner}, repo = ${repo}, issue_number = ${issue_number}` 35 ); 36 37 if (array == null) { 38 core.info(`没有找到标签, 回复一下`); 39 await octokit.issues.createComment({ 40 owner, 41 repo, 42 issue_number, 43 body: `没有找到[xxx]类型的标签`, 44 }); 45 return; 46 } 47 48 const labelName = array[1]; 49 core.info(`预计的标签名: labelname is = ${labelName}`); 50 51 const allLabels = await octokit.issues.listLabelsForRepo({ 52 owner, 53 repo, 54 }); 55 56 const labelText = allLabels.data 57 .map\u0026lt;string\u0026gt;((data) =\u0026gt; { 58 return data.name; 59 }) 60 .join(\u0026#34;,\u0026#34;); 61 62 core.info(`找到了一堆标签 ${labelText}`); 63 64 let haveResult = false; 65 66 for (const label of allLabels.data) { 67 const labels = [label.name]; 68 if (labelName.toUpperCase() === label.name.toUpperCase()) { 69 core.info(\u0026#34;找到了标签, 标上\u0026#34;); 70 await octokit.issues.addLabels({ 71 owner, 72 repo, 73 issue_number, 74 labels, 75 }); 76 haveResult = true; 77 break; 78 } 79 } 80 81 if (!haveResult) { 82 core.info( 83 `没找到标签 ${labelName}, 回复下, 可能是新问题, 现在先短暂回复一下` 84 ); 85 await octokit.issues.createComment({ 86 owner, 87 repo, 88 issue_number, 89 body: `没有找到 ${labelName}`, 90 }); 91 } 92 93 core.info(\u0026#34;run success\u0026#34;); 94 } catch (error) { 95 core.error(\u0026#34;The action run error:\u0026#34;); 96 core.error(error); 97 core.setFailed(error.message); 98 } 99} 配置文件\n1name: \u0026#34;On issue\u0026#34; 2on: 3 issues: 4 types: [opened, reopened, edited] 5jobs: 6 build: 7 runs-on: ubuntu-latest 8 steps: 9 - uses: actions/checkout@v2 10 - uses: ./ 11 with: 12 user_name: ${{ secrets.USER_NAME }} 13 github-token: ${{ secrets.GITHUB_TOKEN }} 在编译上传后看一下\n在经过调试后, 达到了预期的效果, 找到了就标记上, 没有就不标\n也就是说, 在经历过这些以后, 就可以简单的达到我们的目的,后续的话, 可以根据需求扩展功能, 目前的瑕疵是, 部分功能调试起来并不方便\n在实际使用时为了单元测试的方便, 可以封装的更加细一些. 比如: 把,github token, issue, repo, owner, title 等参数全部抽出去, 以便于本地测试是否真的有用\n发布 写完了, 要发布了, 也就是让别人可以在 里搜到你的作品\n一般来讲有如下三个步骤\n写 README 打 tag/release 发布到 action 商店里 最终的文件样式 1. 2├── LICENSE 3├── README.md 4├── __tests__/ 5│ └── main.test.ts 6├── action.yml 7├── dist/ 8│ ├── index.js 9│ ├── index.js.map 10│ ├── licenses.txt 11│ └── sourcemap-register.js 12├── jest.config.js 13├── lib/ 14│ ├── handle.js 15│ ├── main.js 16│ └── wait.js 17├── package-lock.json 18├── package.json 19├── push.sh* 20├── src/ 21│ ├── handle.ts 22│ ├── main.ts 23│ └── wait.ts 24└── tsconfig.json 编写 README 这个就不展开说了, 抄一下别人的, 然后自己随便搞搞\n打 tag 直接使用 github web 端的 release 功能, 这样可以同时完成 tag 和 release 的, 一般来说, action 比较常见的是 1 位长度的 action, 我们直接打一个 v1.0.0, 然后使用者的话, 一般使用 xxx@v1 就可以了\n比如最常用的 actions/checkout, 目前最新 release 版本是v2.3.2, 但是你可以直接使用@v2 来使用一样\n, 使用时可以接受诸如v1 v1.0.0 commitHash, master 这样的标记, 但, 一般不建议使用@master\n发布吧 , 选中你的 action, 这个名字是你定义在action.yml里的\n提示, 需要 release, 这里就来一个 v1.0.0 吧\n当公开仓库后, 就可以看到这里多了一个 release action 的选项\n然后, 如果你是第一次使用, 可能有两个额外步骤\n发布的协议 要求必须开启两步验证, 我这里使用 , 你可以使用别的任何 github 支持的工具, 具体的过程可以百度一下 提示重名了, 我们修改一下 action.yml , 接着就可以用了\n后记 本篇结合了 github 文档和模板完成了 github action 的创建, 使用, 调用的过程 ","link":"https://kikt.top/posts/github/actions/create/","section":"posts","tags":["flutter","actions"],"title":"Github action 的开发到发布"},{"body":"","link":"https://kikt.top/tags/fastlane/","section":"tags","tags":null,"title":"fastlane"},{"body":"","link":"https://kikt.top/categories/flutter/","section":"categories","tags":null,"title":"flutter"},{"body":"自动化打包上传是一个释放双手的过程, 本文就简单重复一下打包的过程\n本文包括 iOS 和 android 篇.\n如果有需要, macOS 和 web 也可以加进来, 步骤并不复杂, 但本篇暂时不讲\n开发环境 macOS, 如果你不是 macOS, 那你只能打包安卓部分 Xcode, 因为 Xcode 会自动安装包含 git 在内的一些其他环境, 所以理论上有这个就够了 brew android sdk flutter sdk jenkins fastlane 到 flutter sdk 为止就不讲了, 我相信看这篇文章的人, 起码 flutter 程序已经开发完了, 只是因为修改个文案就要打包的事被搞的不胜其扰, 才决定自动化的\n而开发 flutter 基本上可以理解为包含如下工具/SDK\nruby git Xcode brew Android SDK Flutter SDK Jenkins 有几点要写在前面, 这东西建议使用 brew 安装, 当然你要是坚持, 也可以用 jendins 的 war/jar 包自己部署,见仁见智\n但不要使用 docker 的方式, 因为 docker 不包含 xcode 的环境, 执行起来比较麻烦\nbrew install jenkins-lts 安装命令, 执行这个等着就好了, 具体的过程就不说了, 用过 brew 的人都懂 启动, 这里使用一个小技巧启动nohup jenkins-lts \u0026gt; /tmp/jenkins.log 2\u0026gt;\u0026amp;1 \u0026amp; 用 nohup 的方式启动, 好处有如下两个 命令行窗口可以关闭, 不重启则不用重新运行, 当然你要是自己建 service 也可以, 看你自己的水平 可以记录一些日志, 当然我这里觉得不重要, 所以暂时先放在/tmp 文件夹里, 如果需要保留, 则放在别的文件夹里, 因为 /tmp 内的文件重启后会被自动删除 启动,在浏览里打开http://localhost:8080/ 这里要注意几点\n初始化运行的时候, 根据提示, 去查看对应的初始化密码, macOS 一般是在启动后在 ~/.jenkins/secrets/initialAdminPassword位置, ~ 代表你的用户目录, 比如我的就是 /Users/Caijinglong 初始化后, 建议安装的插件你就都安装上就行, 不用考虑那么多 用户名和密码一定要记住, 不然后面很麻烦 当一切准备就绪的时候, 可能是这样的, 也可能是这样的\n我这里是因为已经加入了一些任务, 初始化的应该是空的.\n安装插件 系统管理, 插件管理\n这里建议安装的插件有如下几个\n, 发布测试包到蒲公英的插件 这个插件是能把多个任务结合到一起的插件, 方便插入子任务, 比如我有 build ios 和 build android 两个任务, 这东西可以指定顺序, 让两个任务顺序执行 Jenkins 的安装告一段落, 具体的配置到了配置篇再写\nFastLane 这东西的安装看你的实际情况, 一般情况下, 使用 brew 安装也是可以的, 然后, 这东西是一个 ruby 写的自动化打包的工具, 也可以用 gem 安装\n1$ brew install fastlane 1$ sudo gem install fastlane brew 发布的版本不是最新的, 所以, 根据你的情况选择使用哪种方式安装, 提示: sudo 会要求输入密码(系统的登录密码, 输入完回车)\n蒲公英账号 官网: 具体的申请步骤就不讲了, 然后, 现在发布 apk 需要实名制, 自己传身份吧\n这里的信息上传的时候会用到, 先\n编写打包脚本 在使用 Jenkins 之前需要先在外部环境尝试, 因为 Jenkins 中调试错误比较麻烦\n创建个测试项目先\n1$ flutter create auto_build_example 2$ code auto_build_example 我这里用 vscode 打开, 大家呢则根据自己的习惯\n安卓打包脚本 这个很简单, 其实只需要flutter build apk --release -v --split-per-abi 就可以了, 你则看自己的情况修改参数即可\n1[ +3 ms] ✓ Built build/app/outputs/apk/release/app-armeabi-v7a-release.apk (5.1MB). 2[ ] ✓ Built build/app/outputs/apk/release/app-arm64-v8a-release.apk (5.4MB). 3[ ] ✓ Built build/app/outputs/apk/release/app-x86_64-release.apk (5.6MB). 打包结尾会有具体放置的位置, 我个人建议使用 v7a 的, 也就是build/app/outputs/apk/release/app-armeabi-v7a-release.apk, 因为某些 2018 2019 年的手机甚至都还是 v7a 架构(实测), 所以嘛, 先这样\n我们需要记录的信息就是 打包命令 和 打包产物的位置\niOS 打包 这个就是需要装 fastlane 的原因了, 因为使用命令行打包的命令比较复杂, 而且还有证书相关的问题, 很容易遇到问题.\n但很多问题 fastlane 都帮我们解决过了\n注意: 本篇的打包是 ad-hoc 的, 而不是 appstore 的, 所以想要使用的人, udid 必须被包含在证书内, 然后, 这个是有名额限制的, 一个自然年内, 只可以有 100 个, 来年是否继续有效, 需要续约, 具体添加的方法可以自行搜索一下(提示, 直接通过 usb 线插在电脑上, 通过 xcode register device 的会被包含在这个名额内)\n初始化 fastlane 配置 1$ fastlane init 这里有 4 个选项\n自动截图 自动发布到 beta 的 TestFlight 自动发布到 AppStore 手动配置 因为我们其实目前的目的是打包 ad-hoc 的包, 给测试人员安装, 而不用给每个人都插上手机, 所以我们选 4\n稍等片刻后会让连点几下回车, 主要就是把文档之类的地址什么的贴上来, 让有问题的朋友可以快速点进去\n然后就是, 我这的版本不是最新版,提示应该更新之类的\n修改配置文件 ios 目录下会多一个 fastlane 目录\n1$ tree fastlane 2fastlane 3├── Appfile 4└── Fastfile Appfile 是 app 的信息\nFastfile 是配置信息\n我们先修改 Fastfile\n默认的是这样的\n1# This file contains the fastlane.tools configuration 2# You can find the documentation at https://docs.fastlane.tools 3# 4# For a list of all available actions, check out 5# 6# https://docs.fastlane.tools/actions 7# 8# For a list of all available plugins, check out 9# 10# https://docs.fastlane.tools/plugins/available-plugins 11# 12 13# Uncomment the line if you want fastlane to automatically update itself 14# update_fastlane 15 16default_platform(:ios) 17 18platform :ios do 19 desc \u0026#34;Description of what the lane does\u0026#34; 20 lane :custom_lane do 21 # add actions here: https://docs.fastlane.tools/actions 22 end 23end 默认的长这样, 是 ruby 语法, 和 cocoapod 的配置文件语法基本相同, do end 可以简单理解为{}, 其中就是具体要执行的代码了\nlane :custom_lane do 这行的 custom_lane 就是任务的名字, 里面可以添加 actions, 会按照顺序执行\n我们可以按照提示打开 看看都有啥东西, 比如添加一个 然后我把任务名字修改为 ad_hoc\n1default_platform(:ios) 2 3platform :ios do 4 desc \u0026#34;Description of what the lane does\u0026#34; 5 lane :ad_hoc do 6 # add actions here: https://docs.fastlane.tools/actions 7 build_ios_app 8 end 9end 然后执行\n1$ fastlane ad_hoc 12020-08-19 13:41:19.521 xcodebuild[64867:9469238] Unknown simulator cpu type (16777228) 2 3❌ error: Signing for \u0026#34;Runner\u0026#34; requires a development team. Select a development team in the Signing \u0026amp; Capabilities editor. (in target \u0026#39;Runner\u0026#39; from project \u0026#39;Runner\u0026#39;) 4 5 6** ARCHIVE FAILED ** 7[13:41:21]: Exit status: 65 8[13:41:21]: 9[13:41:21]: Maybe the error shown is caused by using the wrong version of Xcode 10[13:41:21]: Found multiple versions of Xcode in \u0026#39;/Applications/\u0026#39; 11[13:41:21]: Make sure you selected the right version for your project 12[13:41:21]: This build process was executed using \u0026#39;/Applications/Xcode.app\u0026#39; 13[13:41:21]: If you want to update your Xcode path, either 14[13:41:21]: 15[13:41:21]: - Specify the Xcode version in your Fastfile 16[13:41:21]: ▸ xcversion(version: \u0026#34;8.1\u0026#34;) # Selects Xcode 8.1.0 17[13:41:21]: 18[13:41:21]: - Specify an absolute path to your Xcode installation in your Fastfile 19[13:41:21]: ▸ xcode_select \u0026#34;/Applications/Xcode8.app\u0026#34; 20[13:41:21]: 21[13:41:21]: - Manually update the path using 22[13:41:21]: ▸ sudo xcode-select -s /Applications/Xcode.app 23[13:41:21]: 24 25+-------------+-------------------------+ 26| Build environment | 27+-------------+-------------------------+ 28| xcode_path | /Applications/Xcode.app | 29| gym_version | 2.156.1 | 30| sdk | iPhoneOS13.5.sdk | 31+-------------+-------------------------+ 32 33[13:41:21]: ▸ note: Using new build system 34[13:41:21]: ▸ note: Building targets in parallel 35[13:41:21]: ▸ note: Planning build 36[13:41:21]: ▸ note: Constructing build description 37[13:41:21]: ▸ error: Signing for \u0026#34;Runner\u0026#34; requires a development team. Select a development team in the Signing \u0026amp; Capabilities editor. (in target \u0026#39;Runner\u0026#39; from project \u0026#39;Runner\u0026#39;) 38[13:41:21]: 39[13:41:21]: ⬆️ Check out the few lines of raw `xcodebuild` output above for potential hints on how to solve this error 40[13:41:21]: 📋 For the complete and more detailed error log, check the full log at: 41[13:41:21]: 📋 /Users/jinglongcai/Library/Logs/gym/Runner-Runner.log 42[13:41:21]: 43[13:41:21]: Looks like fastlane ran into a build/archive error with your project 44[13:41:21]: It\u0026#39;s hard to tell what\u0026#39;s causing the error, so we wrote some guides on how 45[13:41:21]: to troubleshoot build and signing issues: https://docs.fastlane.tools/codesigning/getting-started/ 46[13:41:21]: Before submitting an issue on GitHub, please follow the guide above and make 47[13:41:21]: sure your project is set up correctly. 48[13:41:21]: fastlane uses `xcodebuild` commands to generate your binary, you can see the 49[13:41:21]: the full commands printed out in yellow in the above log. 50[13:41:21]: Make sure to inspect the output above, as usually you\u0026#39;ll find more error information there 51[13:41:21]: 52+------------------+------------+ 53| Lane Context | 54+------------------+------------+ 55| DEFAULT_PLATFORM | ios | 56| PLATFORM_NAME | ios | 57| LANE_NAME | ios ad_hoc | 58+------------------+------------+ 59[13:41:21]: Error building the application - see the log above 60 61+------+------------------+-------------+ 62| fastlane summary | 63+------+------------------+-------------+ 64| Step | Action | Time (in s) | 65+------+------------------+-------------+ 66| 1 | default_platform | 0 | 67| 💥 | build_ios_app | 5 | 68+------+------------------+-------------+ 69 70[13:41:21]: fastlane finished with errors 71 72[!] Error building the application - see the log above 好吧, 有一堆的日志, 其中会告诉我们哪个任务出错了, 原因是啥\n我这里检查了一下, 这里是签名问题, 查一下 fastlane 里的解决方案, 告诉我们使用来解决\n配置 match match 其实是将一些签名的配置文件储存在某个位置, 然后达到多设备能同步的目的\n1$ fastlane match init fastlane 提供了三种储存方案, 你如果有谷歌云或者 S3, 也可以选择用那两个, 然后根据提示来\n这里我选择 git, 毕竟贫穷限制了我, 我去 gitee 创建仓库, 你也可以存在任何你认为合适的 git 仓库\n这里输入你的苹果账号\n我这里因为这个账号对应有 2 个公司开发者, 所以需要选一个. 输入 1 或 2 回车继续, 如果你只有一个, 估计这一步会自动跳过\n下一步是输入你的 app 的 bundle id\n这一步是提示, 没有找到签名文件, 其实这是因为这一步只会找现成的签名, 如果没有的话则不会自动创建, 我们去 xcode 里创建一个签名\n在这里选择一个 Team, 然后等成功后再重新执行上面的 match adhoc\n这里可能会有朋友发现, 还是会报错, 无法 match, 其实这是因为你的帐号在 appstore 上并没有对应的 App 的原因, 两个解决方案\n选择已有的 app bundle id 创建新的 app 我这里为了演示, 在公司的帐号上创建一个 app(不发布就行了 😁)\n创建新的\u0026quot;套装 ID\u0026quot; 新建一个 app 然后再去执行 match 就可以成功了\n然后查看 git 仓库\n发现也有东西了, 接着就可以回去配置 match 了\n修改 Fastline\n1platform :ios do 2 desc \u0026#34;Description of what the lane does\u0026#34; 3 lane :ad_hoc do 4 # add actions here: https://docs.fastlane.tools/actions 5 match( 6 type: \u0026#34;adhoc\u0026#34;, 7 app_identifier: \u0026#34;top.kikt.autobuildexample\u0026#34;, 8 team_id: \u0026#34;\u0026#34;, # 你的team id, 只有一个可以直接删了这行 9 ) # 添加这个 10 build_ios_app( 11 scheme: \u0026#34;Release\u0026#34;, 12 export_options: { 13 method: \u0026#34;ad-hoc\u0026#34;, 14 } 15 ) 16 end 17end team_id 注意: 如果你的 apple 帐号, 只对应一个公司, 则不用填这个, 填这个的目的是为了自动化\n接着执行\n1$ fastlane ad_hoc 多出来的两个文件, 一个是 ipa 包, 一个是对应的 dsym(用于还原堆栈)\n这个是 ad-hoc, 所以可能不需要两步验证, 但拿出来说一下, 也许后面会用到\n两步验证的问题 iOS 中打包可能会遇到两步验证的问题, 而且经常要验证, 在自己本地命令行打包的时候还可以交互一下, 但 Jenkins 是不支持交互的, 这个能否解决呢?\n答案是肯定的, 但需要经过如下的步骤\n获取 Cookie\n1$ export FASTLANE_APPLE_APPLICATION_SPECIFIC_PASSWORD=\u0026lt;PWD\u0026gt; # 上一步的app专用密码 1$ fastlane spaceauth -u \u0026lt;apple_id\u0026gt; # apple id 将 cookie 保存下载, 至于是环境变量还是文件看你自己的情况, 我这里选择的是文件的方式, 然后存到代码仓库中以便于 jenkins 读取, 你存到环境变量里也是可以的\n比如如下的 cookie(为了安全性, 我这里删除了一部分字符, 所以你拿过去是用不了的) 请根据你自己的情况来拿到这个\n1---\\n- !ruby/object:HTTP::Cookie\\n name: DES5d68a2334f25aa752d511d\\n value: HSARMTKNSRVXWFla+6da0vxQCwQOICU+fwfLb6VaikjljuH6uDxOu6UWoLsJfDGnDolKcfUcKtnU5aQ5nskxgurrnxdOubXWidJF7JzxjbyzxmH6Tq/vD3JrCTSRVX\\n domain: idmsa.apple.com\\n for_domain: true\\n path: \u0026#34;/\u0026#34;\\n secure: true\\n httponly: true\\n expires:\\n max_age: 2592000\\n created_at: 2020-08-11 09:56:46.642442000 +08:00\\n accessed_at: 2020-08-18 13:45:59.234609000 +08:00\\n- !ruby/object:HTTP::Cookie\\n name: myacinfo\\n value: DAWTKNV2da5c169c5551bd40dc5d6ffd58c42656bc39c57326c4686e7ba67cf58b38a017214dba13ef41247a84ae2909fa56863ffda004b4fcec4402e48d0a8c6a38a8b1593411a21da63fdf0b95ad37d33567598e684da6390f9b525c51cf6e1ea6e42a021dc1b798703c769d8380a23f8ac2b6890dfdc92a035acb48 domain: apple.com\\n for_domain: true\\n path: \u0026#34;/\u0026#34;\\n secure: true\\n httponly: true\\n expires:\\n max_age:\\n created_at: 2020-08-18 13:46:00.175666000 +08:00\\n accessed_at: 2020-08-18 13:46:00.176071000 +08:00\\n- !ruby/object:HTTP::Cookie\\n name: dqsid\\n value: mp0aSI6IlFYS3E3MmI1SmVkVFV5THFcsh58p8zWIpcqviQIYYqJ8oW18qxcM\\n domain: appstoreconnect.apple.com\\n for_domain: false\\n path: \u0026#34;/\u0026#34;\\n secure: true\\n httponly: true\\n expires:\\n max_age: 1800\\n created_at: \u0026amp;1 2020-08-18 13:46:00.842456000 +08:00\\n accessed_at: *1\\n 注意, 这里有两端\u0026quot;乱码\u0026quot;, 复制第一段, 第二段是 fastlane 给的示例而已, 这里提示输入 y,则自动复制到剪切板\n我创建一个文件 cookies.txt, 把这段东西粘贴进去, 这一步是为了 Jenkins 考虑\n小结 总体来说, 配置好了以后\n安卓:\n1$ flutter build apk iOS:\n1$ flutter build ios --release -v 2$ cd ios 3$ fastlane ad_hoc 打包的命令熟悉完毕后, 就到了 Jenkins 的配置了\nJenkins 的配置 配置仓库权限 Jenkins 中支持 git 来管理源码, 然后, git 需要凭证来访问, 我这里是 gitee 的, 你可以根据你的情况自己配置\n安卓自动化 我先新建一个组叫\u0026quot;自动构建\u0026quot;, 然后点击创建新的任务\n选择构建一个自由风格的软件项目\n配置源码 先配置项目的 git 地址\n然后选择凭证, 接着确定后, 点下面的保存, 先试试是否能拉到源码\n这里构建完成后, 可以看到构建过程\n然后点工作空间看看代码\n现在, 就能看到完整的代码了\n配置打包脚本 这里还没完, 需要配置打包脚本, 继续点击配置\n拉到后面, 点击构建=\u0026gt;执行 shell\n这里就是自动构建的步骤了.\n1flutter build apk --release -v --split-per-abi 2ls build/app/outputs/apk/release/ 这里简单打包, 然后查看下, 保存后点击立即构建\n这里就是打包过程了\n查看一下控制台输出\n打包完成了, 顺便执行了 ls 命令查看了一下\n上传 上传直接使用插件就可以了,还记得之前安装过 pgyer 的插件吗, 如果你要传 fir 或者自己的服务器, 那就需要你自己探索一下了\n使用 v1 还是 v2 看你自己的情况, 都可以, 我这里使用 v2 的, 把 api_key 放过来, 然后使用\nscandir 是你上传的目录 ${WORKSPACE}/build/app/outputs/apk/release 工作空间的根目录, 然后下面是文件名\n然后保存, 立即构建\n地址: 到这一步, 安卓就算是成功了\niOS 自动化 创建一个叫\u0026quot;iOS 自动化\u0026quot;的任务\n配置源码仓库 和安卓完全一样, 略过\n打包脚本 还是在构建位置,使用 shell 脚本, 但和安卓不同的时, 需要有如下的步骤\nflutter build ios 两步验证 fastlane 1, 3 在外部测试阶段完成了, 也就是说, 唯一需要注意的是两步验证的问题, 仓库里储存有 cookies, 这个东西就是用来干这个的了\n编写脚本\n1flutter build ios --release -v 2cd ios 3export FASTLANE_SESSION=$(cat login_cookie) 4fastlane ad_hoc 5ls Runner.* 上传 然后, 我们遇到了一次失败\n去查一下原因吧, 进入控制台输出\n我们看到, 蒲公英上传失败了.\n嗯, 那我们换一个方式, 不通过 jenkins 的插件了, 而是通过 fastlane 的 pgyer action 直接在 fastlane 里完成这一步, 先添加\n1$ fastlane add_plugin pgyer 中间需要 y,确定一下\n然后, 修改 fastfile\n1default_platform(:ios) 2 3platform :ios do 4 desc \u0026#34;Description of what the lane does\u0026#34; 5 lane :ad_hoc do 6 # add actions here: https://docs.fastlane.tools/actions 7 ... 8 build_ios_app( 9 scheme: \u0026#34;Release\u0026#34;, 10 export_options: { 11 method: \u0026#34;ad-hoc\u0026#34;, 12 } 13 ) 14 pgyer(api_key: \u0026#34;75123fxxx10\u0026#34;, user_key: \u0026#34;4853910323xxx22105382\u0026#34;) 15 end 16end 把 pgyer 的 action 直接加载 build_ios_app 后, 然后设置到 api_key 和 user_key, 在 查询\n接着点击立即构建, 就可以触发了\n上传完毕后是这样\nJenkins 的触发器 Jenkins 支持一些触发器\n远程触发, 设置 token, 然后通过访问 url 的方式, 或是脚本之类的方式触发\n其他工程构建后触发, 顾名思义, 就是比如我构建完安卓, 触发构建 iOS 的操作, 这样是可以细化构建步骤, 但如果本身没有关联, 强行搞到一起反而不美\n定时构建, 这个支持比较多的方式, 很类似于 Spring 的定时任务, 具体语法可以查看说明或示例\ngithub 的钩子\n轮询 SCM\nFastlane 的一些配置 fastlane 其实也支持安卓, 不过本篇因为安卓 flutter build apk 已经足够简单, 所以个人考虑不需要使用这个, 如果你的项目是 flutter module 配合 maven 或 aar 的方式置入原生的, 需要更多步骤的情况下, 可以尝试使用 fastlane 来帮你解放双手\n后记 本篇主要探索了测试阶段如何解放双手, 使用 jenkins 配合 fastlane 达到自动打包, 上传的过程\n如果需要额外告知某些人员, 可以尝试对接办公系统的 api 来达到自动通知的目的, 钉钉等程序应该都有对应接口\n本篇设计到的文件相对完整版 之所以是相对, 是因为有一些敏感信息, 例如 pgyer 的 api key, 苹果的登录 cookie, 签名仓库等等, 并不方便向所有人开放\n安卓篇\nJenkins 构建脚本\n1flutter build apk --release 构建后\nscandir: ${WORKSPACE}/build/app/outputs/apk/release\nFile name: app-armeabi-v7a-release.apk\niOS 篇\nFastfile\n1# This file contains the fastlane.tools configuration 2# You can find the documentation at https://docs.fastlane.tools 3# 4# For a list of all available actions, check out 5# 6# https://docs.fastlane.tools/actions 7# 8# For a list of all available plugins, check out 9# 10# https://docs.fastlane.tools/plugins/available-plugins 11# 12 13# Uncomment the line if you want fastlane to automatically update itself 14# update_fastlane 15 16default_platform(:ios) 17 18platform :ios do 19 desc \u0026#34;Description of what the lane does\u0026#34; 20 lane :ad_hoc do 21 # add actions here: https://docs.fastlane.tools/actions 22 match( 23 type: \u0026#34;adhoc\u0026#34;, 24 app_identifier: \u0026#34;top.kikt.autobuildexample\u0026#34;, 25 team_id: \u0026#34;xxx\u0026#34;, 26 ) 27 build_ios_app( 28 scheme: \u0026#34;Release\u0026#34;, 29 export_options: { 30 method: \u0026#34;ad-hoc\u0026#34;, 31 } 32 ) 33 pgyer(api_key: \u0026#34;xxx\u0026#34;, user_key: \u0026#34;xxx\u0026#34;) 34 end 35end Matchfile\n1git_url(\u0026#34;https://gitee.com/kikt/test_adhoc_sign_store.git\u0026#34;) 2 3storage_mode(\u0026#34;git\u0026#34;) 4 5type(\u0026#34;adhoc\u0026#34;) # The default type, can be: appstore, adhoc, enterprise or development 6 7app_identifier([\u0026#34;top.kikt.autobuildexample\u0026#34;]) 8username(\u0026#34;xxx\u0026#34;) # Your Apple Developer Portal username 9 10# For all available options run `fastlane match --help` 11# Remove the # in the beginning of the line to enable the other options 12 13# The docs are available on https://docs.fastlane.tools/actions/match Pluginfile\n1# Autogenerated by fastlane 2# 3# Ensure this file is checked in to source control! 4 5gem \u0026#39;fastlane-plugin-pgyer\u0026#39; jenkins\n1flutter build ios --release -v 2cd ios 3export FASTLANE_SESSION=$(cat login_cookie) 4fastlane ad_hoc 5ls Runner.* 以上\n","link":"https://kikt.top/posts/flutter/jenkins+fastlane/","section":"posts","tags":["jenkins","fastlane","flutter"],"title":"flutter Jenkins+fastlane 自动化打测试包, 并上传蒲公英"},{"body":"","link":"https://kikt.top/tags/jenkins/","section":"tags","tags":null,"title":"jenkins"},{"body":"","link":"https://kikt.top/tags/android/","section":"tags","tags":null,"title":"android"},{"body":"","link":"https://kikt.top/categories/android/","section":"categories","tags":null,"title":"android"},{"body":"","link":"https://kikt.top/tags/go/","section":"tags","tags":null,"title":"go"},{"body":"","link":"https://kikt.top/categories/go/","section":"categories","tags":null,"title":"go"},{"body":"","link":"https://kikt.top/tags/so/","section":"tags","tags":null,"title":"so"},{"body":"","link":"https://kikt.top/tags/%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/","section":"tags","tags":null,"title":"交叉编译"},{"body":"golang跨平台, 性能强, 周边也算丰富\n一直有一个想法, 把这东西写的代码编译成各个平台的库, 未来在 flutter 里用\n开发环境和工具 MacOS(其他的暂时不考虑) Go Go 1.14.6, 版本太低可能不能编译成 android 的 Goland , 咱现在是正版用户, 用开源项目申请的All products License , 你也可以根据自己的情况选择别的 IDE 或使用文本编辑器(vscode 也不错) Android Android Studio Cmake Android SDK Android NDK Go 部分 go 源码 add_library.go\n1package main 2 3import \u0026#34;C\u0026#34; 4 5//export add 6func add(x, y int) int { 7\treturn x + y 8} 9 10//export remove_int 11func remove_int(x, y int) int { 12\treturn x - y 13} 14 15func main() { 16} 这里有几点要注意\npackage 一定要是 main(强制规定) 一定要包含 main 函数(强制规定) import \u0026quot;C\u0026quot;, 不能少, 因为要编译出 c(c++)的头文件 每个方法前要加//export 方法名, 这里要注意 // 和 export间不能有空格 方法名和 go 的方法名必须完全一样 方法名不能是 c 内置的方法名, 比如remove就不行 编译 我在项目里内置了两个脚本, 一个是编译 android 的, 一个是编译 macOS 的, 因为篇幅和主题的原因, macOS 的就不单独拿出来了\n看看编译成安卓的脚本吧\n1export ANDROID_NDK_HOME=$ANDROID_HOME/ndk/21.0.6113669 2 3export GOARCH=arm 4export GOOS=android 5export CGO_ENABLED=1 6export CC=$ANDROID_NDK_HOME/toolchains/llvm/prebuilt/darwin-x86_64/bin/armv7a-linux-androideabi21-clang 7go build -buildmode=c-shared -o output/android/armeabi-v7a/libadd.so add_library.go 8 9echo \u0026#34;Build armeabi-v7a success\u0026#34; 10 11export GOARCH=arm64 12export GOOS=android 13export CGO_ENABLED=1 14export CC=$ANDROID_NDK_HOME/toolchains/llvm/prebuilt/darwin-x86_64/bin/aarch64-linux-android21-clang 15go build -buildmode=c-shared -o output/android/arm64-v8a/libadd.so add_library.go 16 17echo \u0026#34;Build arm64-v8a success\u0026#34; 简单来说 有几个环境变量要设置一下\nGOARCH=CPU 类型 GOOS=设备类型 CGO_ENABLED=1 CC=ndk 里的 clang,需要是对应 CPU 版本的, API 呢建议是最低 这里单独说明一下, 高版本的 ndk 用的是 clang, 低版本用的是 gcc, 这个根据你情况来, 个人建议直接用 21.0.6113669版本, 这个我测试过, 没有问题, ndk20 我也试过, 也是 ok 的 go build 命令 -buildmode=c-shared 构建类型, 使用 go help buildmode查看, 安卓一般用c-shared就可以了, 意思就是 c 类型的共享库(动态库) -o 后面跟输出的位置, 一般建议使用 libxxx.so 的格式, 相对的, 头文件也会被生成在同一目录下, xxx 就是库的名字, 对应到 Java 里加载库的方法就是System.loadLibrary(\u0026quot;xxx\u0026quot;) 而不是~~System.loadLibrary(\u0026quot;libxxx\u0026quot;)~~ 最后一个就是需要编译的 go 文件了 CPU 类型和设备类型可以使用go tool dist list查看\n我这里 1.14.6 包含的 android 对应的是:\n1$ go tool dist list|grep android 2android/386 3android/amd64 4android/arm 5android/arm64 arm 和 arm64 对应 v7 和 v8\n386 amd64 应该对应的是 x86 和 x86_64, 这个没有实测, 如果有需要的朋友可以自己尝试一下\n运行脚本./build_android_on_mac.sh即可完成编译\n安卓 创建项目 就是简单的在 Android Studio 中 New Project\nCMakeLists.txt 自己创建一个CMakeLists.txt, 注意大小写敏感, 其实这个文件名可以随便写, 但是约定俗成是这样, 建议不要变\n1cmake_minimum_required(VERSION 3.10.2) 2 3project(android_lib) 4 5set(GO_BUILD_PATH ${CMAKE_CURRENT_SOURCE_DIR}/../go/output/android) 6set(SRC ${GO_BUILD_PATH}/${CMAKE_ANDROID_ARCH_ABI}) 7 8include_directories(${SRC}) 9 10find_library( 11 std-lib 12 android 13) 14 15message(\u0026#34;CPU ABI: ${CMAKE_ANDROID_ARCH_ABI}\u0026#34;) 16 17if (${CMAKE_ANDROID_ARCH_ABI} EQUAL \u0026#34;armeabi\u0026#34;) ## 根据ABI的不同, 复制so文件到对应的文件夹 18 file(COPY ${GO_BUILD_PATH}/${CMAKE_ANDROID_ARCH_ABI}/libadd.so DESTINATION ${CMAKE_CURRENT_SOURCE_DIR}/libs/${CMAKE_ANDROID_ARCH_ABI}) # 复制库文件 19else () 20 file(COPY ${SRC}/libadd.so DESTINATION ${CMAKE_CURRENT_SOURCE_DIR}/libs/${CMAKE_ANDROID_ARCH_ABI}) # 复制库文件 21endif () 22file(COPY ${SRC}/libadd.h DESTINATION ${CMAKE_CURRENT_SOURCE_DIR}/src/main/jni) # 复制头文件 23 24file(GLOB JNI_SRC ${CMAKE_CURRENT_SOURCE_DIR}/src/main/jni/*.c ${CMAKE_CURRENT_SOURCE_DIR}/src/main/jni/*.h) # 扫描jni目录下的头文件和库文件, 并设置给JNI_SRC 25add_library(my_jni SHARED ${JNI_SRC}) # 添加jni中转库 26 27file(GLOB OUTPUT_LIBRARY libs/${CMAKE_ANDROID_ARCH_ABI}/*.so) # 找到对应cpu的so库文件 28 29target_link_libraries( 30 my_jni 31 ${std-lib} # 连接android标准库给jni, 因为golang用到了一些标准库的定义 32 ${OUTPUT_LIBRARY} # 连接给jni库 33) 我在其中加入了详细的注释, 其中具体的 Cmake 语法没法展开讲\n编写代码 C 代码 首先是 c 代码, 我们在 CMake 中定义了一个 my_jni的库, 这个库包含${CMAKE_CURRENT_SOURCE_DIR}/src/main/jni下所有的 c 和 h 文件\n然后吧, 在src/main/jni下创建 c 文件, 我这里定义的是 jni.c,别的什么也没关系\n1#include \u0026lt;jni.h\u0026gt; 2#include \u0026#34;libadd.h\u0026#34; 3 4// 5// Created by jinglong cai on 2020/8/14. 6// 7 8JNIEXPORT jint JNICALL 9Java_top_kikt_usegolibrary_JniLibrary_add(JNIEnv *env, jclass clazz, jint x, jint y) { 10 return add(x, y); 11// return x + y; 12} 13 14JNIEXPORT jint JNICALL 15Java_top_kikt_usegolibrary_JniLibrary_remove(JNIEnv *env, jclass clazz, jint x, jint y) { 16 return remove_int(x, y); 17} 嗯, 其实就两个方法, 对应了 go 里定义的两个方法, 这里是 jni 的写法\nJava 代码 JniLibrary.class\n1package top.kikt.usegolibrary; 2 3public class JniLibrary { 4 5 static { 6 System.loadLibrary(\u0026#34;my_jni\u0026#34;); 7 } 8 9 public static native int add(int x, int y); 10 11 public static native int remove(int x, int y); 12 13} 这里的两个 native 方法就是指向jni.h里定义的方法的\nMainActivity.kt\n1package top.kikt.usegolibrary 2 3import androidx.appcompat.app.AppCompatActivity 4import android.os.Bundle 5import kotlinx.android.synthetic.main.activity_main.* 6 7class MainActivity : AppCompatActivity() { 8 override fun onCreate(savedInstanceState: Bundle?) { 9 super.onCreate(savedInstanceState) 10 setContentView(R.layout.activity_main) 11 12 textView.text = \u0026#34;come from jni ${JniLibrary.add(300, 150)}\u0026#34; 13 14 textView2.text = \u0026#34;come from jni ${JniLibrary.remove(300, 150)}\u0026#34; 15 } 16 17 18} 就是简单的调用了这两个方法\n运行 结果如下\n后记 项目代码: 本篇为系列的第一篇, 不出意外, 后续应该会有对应的 iOS 篇, flutter-dart:ffi , wasm 篇则待定\n以上\n","link":"https://kikt.top/posts/go/compile-for-android/","section":"posts","tags":["android","交叉编译","go","so"],"title":"编译 go 源码为 android 动态库(so)"},{"body":"上一章, 简单的使用了一下 FocusNode 和周边的一些东西, 今天来扒一扒 FocusNode 整体的附着(attach)和分离(detach)\nflutter 环境还是针对 1.17.5\nFocus 家族的源码分析 附着 首先第一, 平时是以 FocusNode 为主要对象的, 那么这东西是怎么附着到整体的呢\n构造方法\ndebugLabel, 这东西看名字就是 debug 用的, 先不管 onKey, 一看就是接受事件用的RawKeyEvent canRequestFocus, 就是能不能接受焦点 skipTraversal, 是否接受遍历 我们再找找方法\n有几个可能用到的关键字段, 我们一个个看, 但是不一定会用的到, 但是有所了解也是好\ncontext, 这个是和控件结合 的, 单纯看这里还看不出来\n_manager, 我们知道这个在 flutter 环境中其实是全局单例的, 但是这里为了解耦所以可能是哪里传进来的, 我们理论上可以忽略\n_ancestors, 嗯.. 没有注释, 那就只能看看源码了 所以, 这个东西是把所有的父节点都装到了这个里. 嗯, 个人经验,应用层的话大概率用不上.\n_descendants,这东西也是个三无, 没事 都在源码里了, 这东西是深度为 1 的子 node 的 descendants 和子node, 然后里面递归了... 换句话说, 其实, 这东西是所有的子 node\n_hasKeyboardToken 这东西暂时没看出作用, 先放放\nchildren, 这东西就是所有子node, 怎么附着的暂时还不知道, 先放放\ntraversalChildren, 这就是上次用到的那东西的核心了, 就是靠这东西筛选了一下, 可以接受遍历的子节点, 这里就和构造方法那对上了 找了一些核心字段, 但是还是没找到怎么附着的, 我们整体看看方法名 好家伙, 一屏都要装不下了, 看看名字, 直奔 attach 这方法看起来就是附着的方法了, 咱们跟一下这个方法, 注意到其实内部只有绑定 context, 绑定 key 回调, 然后创建了一个 attachment, 这东西是何方神圣, 咱们来跟进去看看\n这东西看介绍是用来保证 FocusNode 不会被多处附着的, 怎么实现的呢\n好吧, 看上去就是检测一下自己位置对不对, 不对就重新找个父节点\nNode 的树形结构 上面简单的看了一下源码的结构, 但是可能还是不能系统的想象到底有哪些 node\n我写一个方法简单输出一下 FocusNode 的节点关系\n1import \u0026#39;package:flutter/material.dart\u0026#39;; 2 3class FocusNodePrintExample extends StatefulWidget { 4 @override 5 _FocusNodePrintExampleState createState() =\u0026gt; _FocusNodePrintExampleState(); 6} 7 8class _FocusNodePrintExampleState extends State\u0026lt;FocusNodePrintExample\u0026gt; { 9 FocusNode node = FocusNode(debugLabel: \u0026#39;the input\u0026#39;); 10 FocusNode node2 = FocusNode(debugLabel: \u0026#39;the raised button\u0026#39;); 11 FocusNode node3 = FocusNode(debugLabel: \u0026#39;the float button\u0026#39;); 12 13 @override 14 Widget build(BuildContext context) { 15 return Scaffold( 16 appBar: AppBar(), 17 body: Column( 18 children: [ 19 TextField( 20 focusNode: node, 21 ), 22 RaisedButton( 23 onPressed: () {}, 24 focusNode: node2, 25 ), 26 ], 27 ), 28 floatingActionButton: FloatingActionButton( 29 focusNode: node3, 30 onPressed: () { 31 priceAllFocusNode(); 32 }, 33 ), 34 ); 35 } 36} 37 38void printNode(int level, FocusNode node) { 39 print(\u0026#39;${\u0026#39;--\u0026#39; * level} $node\u0026#39;); 40 for (final child in node.children) { 41 printNode(level + 1, child); 42 } 43} 44 45void priceAllFocusNode() { 46 printNode(0, FocusManager.instance.rootScope); 47} 这样就比较清晰了, 一个页面, 即使在没有自己使用 FocusScope 组织的情况下也会有自己的 FocusNode, 然后所有子节点会\u0026quot;自发\u0026quot;的形成一个并列的 FocusNode 关系, 并附着到当前页的 FocusNode 上, 这个 ModalScopeState就是让每一个页面有自己的焦点区域, 从而不会互相影响\n这两处就是这东西定义FocusScope的地方, 然后这东西本身的定义是在ModalRoute里面\n而ModalRoute是各种常见的PageRoute(MaterialPageRoute,CupertinoPageRoute的父类),PopupRoute(DialogRoute的父类), 嗯,路由和页面的洗也串联起来了. 同时, 我们也知道为什么单独的 dialog 也好,页面也好, 焦点都是独立的\n改变焦点 上面把焦点的区域等等东西探索完毕, 接下来看看改变焦点的时候都做了什么, requestFocus这个方法在整个 flutter 中只定义了一次\n可以看到, 这东西可以接受一个入参, 是另一个 node, 但对于这 node 有所限制, 比如属于当前 node 的父节点. 当然不传的话, 就是调用_doRequestFocus的事了, 我们再来看看这东西了做了什么\n根据注释, 这东西在scopeNode里会被覆盖, 我们一会儿看覆盖的, 先看当前的, 比如如果焦点本身canRequestFocus是 false, 就返回了(debug 会报错我知道, 但是咱们以 release 运行结果为准).\n然后如果父节点是空, 会设置一个_requestFocusWhenReparented为 true, 看名字应该是当重新附着的时候请求焦点, 换句话说先记账,我个人对于这里的理解是, 如果你开了新页面, 因为整个旧页面都失去了焦点, 但是当这个旧页面返回前台时, 检测这个东西是 true 时, 就会重新请求焦点.\n把当前父焦点按顺序添加到末尾的意思, 具体作用不明\n然后是\n1if (hasPrimaryFocus \u0026amp;\u0026amp; (_manager._markedForFocus == null || _manager._markedForFocus == this)) { 2 return; 3} 这里的作用就是如果有有主焦点, 且已经被标记为当前焦点, 才 return, hasPrimaryFocus是表示就是当前主焦点. _markedForFocus表示虽然申请了, 但是暂时还没活动, 类似于一个脏标记, 这个变量应该是给下一帧使用的.\n1_hasKeyboardToken = true; 2assert(_focusDebug(\u0026#39;Node requesting focus: $this\u0026#39;)); 3_markNextFocus(this); 这东西理解起来就比较简单了, 获取键盘 token, 标记下一个焦点是自己\n然后, 来看看FocusScopeNode里这个方法的实现\n其实就是安排 manager 来做标记\nmanager 的处理过程 刚刚有一个方法是_markNextFocus, 这个方法会调用到 manager 里, 我们来跟一下这个方法, 看看 manager 这个单例管理类里都干了什么 如果是当前的主焦点, 就不管\n如果不是, 则调用 update 方法\n就是一个标记方法, 然后让程序在回调里执行 focusChange\n分离(detach) 核心大概就是这些, 在FocusAttachment内,如果已经附着, 则unfocus一下, 然后到 manager 里标记分离, 解除父类和子类的关系, 接着置空_node._attachment. 可以理解为生命周期, 你在绑定做了什么, 到了解绑的时候自然要反向操作\n软键盘弹起的问题 有的同学看完了焦点相关的东西会感觉奇怪了, 怎么没有软键盘的东西, 我们讲了半天焦点, 没看见有软键盘弹起的逻辑啊?\n其实这是因为前面的部分只是焦点部分, 我在前文中提及过, 在 flutter 中, 不止是文本输入框才能获取焦点, 而是任何控件(比如按钮)都存在理论上获得焦点的可能性.\n反向查找 如何反向查找呢? 我通过知识的积累(其实就是各种瞎看)知道了所有 flutter 和原生交互都是通过SystemChannels来进行的, 那我们来一路跟一跟\n挖, 就是这个, 就是这个, 但是软键盘是通过 textInput 这东西过来的, 我们看看这东西是怎么实现的\nTextInput 好吧, 就是一个 channel, 但是这东西有什么方法呢, 我们看看调用和封装吧.\n有这么一个类专门封装了这东西, 正向调用和回调\n看名字就是编辑状态, action(软键盘的回车之类的?), 更新光标, 关闭. 这里先不细看\nupdateEditingState 这就和平时的onChanged回调对应上了\nperformAction 看名字基本就知道了, 对应的是各种键盘的回车键功能\nupdateFloatingCursor 基本就是因为点击之类或者别的什么原因, 光标位置要发生变化\nconnectionClosed 这个就没啥可说的了, 断开与软键盘连接的回调\nshow 当控件有焦点时,, 就可以调用 TextInput 的show方法了, 这也就是软键盘弹出的逻辑了.\n这时候又有同学要问了, 道理我都懂, 那为啥会触发到这个方法呢? 我说你这人怎么这么讨厌...\n好吧, 从源码的角度来看, 也是有出处的\n经过这素质三连, 我觉得真相大白了, 本身focusNode是一个ChangeNotifier, 当这东西发生变化时, 自然会通知到回调方法(_handleFocusChanged), 然后我们知道之前的 manager 那边有方法会调用到这个 notify, 所以键盘自然就会弹起来了.\n后记 本篇主要是解析源码中的焦点和软键盘弹起的相关部分, 本篇系列文章也许还有第三篇, 也许没有, 一切随缘\n以上.\n","link":"https://kikt.top/posts/flutter/focusnode-2/","section":"posts","tags":["flutter","焦点","focus","focusNode"],"title":"Flutter FocusNode 焦点那点事-(二)"},{"body":"","link":"https://kikt.top/tags/focus/","section":"tags","tags":null,"title":"focus"},{"body":"","link":"https://kikt.top/tags/focusnode/","section":"tags","tags":null,"title":"focusNode"},{"body":"","link":"https://kikt.top/tags/%E7%84%A6%E7%82%B9/","section":"tags","tags":null,"title":"焦点"},{"body":"很多时候, flutter 中需要处理输入的焦点, 咱们今天就来看看控件怎么用\n本篇可以视为简单使用, 而不会深入源码去探讨怎么附着, 主要是 Focus 系列控件的使用, 和怎么在多输入框之间反复横跳\n环境说明 本篇基本基于 flutter sdk 的 1.17.5 版本来看, 其他版本应该大同小异, 但很多东西可能会随时间变化, 未来是否有效请继续验证 本篇基本是针对移动端来说的 写本文时, flutter web 的焦点比较迷, 似乎和移动版不太一样, 所以暂时略过不表 desktop 版只尝试了 macOS, 其他的桌面引擎请自行校验对错 相关 dart class flutter 中, 和焦点相关联类有如下几个:\nFocusNode: 这个可以说是最常用到的, 核心类之一 FocusManager: 单例类, 整个 flutter 应用的焦点管理核心都是这东西在处理, 包括和原生交互弹出软键盘之类的操作 Focus: 一个 Widget, 用于给控件\u0026quot;添加\u0026quot;焦点能力, 包起来就行, InkWell 之类的控件能获取焦点能力都是靠这东西 FocusScope: 一个 Widget, Focus 的子类, 被这东西包起来的所有的子 widget 的 FocusNode 都会被自动注册到这个里面, 接受统一管理 FocusScopeNode: 这东西本身是 FocusNode 的子类, 但是它主要是给 FocusScope 用的,扩展了 FocusNode 的行为 FocusTraversalPolicy, FocusTraversalGroup: 这两个东西是 focus node 的策略, 用于排序哪个是下一个焦点的问题, 这两个东西本篇应该不讲, 有兴趣的可以去看官方文档, 目前个人认为应该用不上 FocusNode 这东西讲的人很多, 我也就不展开了, 简单的说一下几个方法\ncanRequestFocus: 是否能请求焦点 context: 焦点\u0026quot;附着\u0026quot;的 widget 的 BuildContext hasFocus: 是否有焦点 unfocus: 放弃焦点, 如果当前 node 有焦点,并调用这个, 就放弃了焦点, 如果同时有软键盘弹起, 则软键盘收起 requestFocus: 请求焦点, 这个方法调用后, 会把焦点移到当前 备注: 有很多其他的方法, 对于普通朋友和正常的应用场景很难用到, 作为程序框架有提供, 但是个人观点不必一定要了解, 只要知道主要方法即可\nFocusManager 这东西是一个单例的,通过FocusManager.instance获取\n有一个常用方法了解一下: FocusManager.instance.primaryFocus.unfocus();, 调用一下, 软键盘就下去了\n这东西里面基本都是私有方法, 能调用的并不多\nFocusHighlightMode 这东西是焦点的\u0026quot;模式\u0026quot;, 对应触摸和鼠标键盘, 个人认为一般情况下用不到, 移动端就 touch 就可以了\nFocus 这东西一般情况下很少能用到, SDK 里有一些地方会用到, Focus 对象本身内部会维护一个 FocusNode, 比如按钮能响应键盘回车之类的焦点就是因为内部有这东西\n这个类在 flutter 项目中使用率不算高, 但都是关键处 _FocusableActionDetectorState: 对应 FocusableActionDetector 的状态, 这个类被用于 CheckBox, Radio, Switch\nFocusScope 这东西很少见有文档讲, 这里我简单的解析一下, 这个也可以说是后面使用的重点, 我在实际开发中遇到有输入框的情况下, 这个控件是我的首选\n简单来说, 就是在这东西子控件内的 FocusNode 都会被统一维护\n这东西构造方法可以传一些参数, 常用的无非就是 node, canRequestFocus, 之类的.\n这里有一个 skipTraversal, 这个参数后面结合例子来看才能说明白\nFocusScopeNode 一般和FocusScope成对使用\n写代码 入门级写法 嗯, 前面都是概念性的东西, 很多朋友都不想看, 而且也没啥意思\n比如有一个这样的场景\n用 app 来说, 就是 4 个输入框, 一个个的点击自然可以, 但是如果要用户体验好是不是应该可以回车一直下一步, 然后最后一条直接提交呢?\n模拟一下这个东西很多人的写法\n嗯, 点评一下, 嗯 很整齐, 那么... 当你有 10 个的时候怎么办呢? 想想就很美\n我们改写下,也许可以这样?\n好的, 算你基础扎实, 这样写自然是可以的.\n进阶 上面的写法很 dart, 但是不 flutter, 我们 flutter 的写法可以改成这样\n1import \u0026#39;package:flutter/material.dart\u0026#39;; 2 3class Example3 extends StatefulWidget { 4 @override 5 _Example3State createState() =\u0026gt; _Example3State(); 6} 7 8class _Example3State extends State\u0026lt;Example3\u0026gt; { 9 FocusScopeNode node = FocusScopeNode(); 10 11 @override 12 Widget build(BuildContext context) { 13 return Scaffold( 14 appBar: AppBar(), 15 body: FocusScope( 16 node: node, 17 child: SingleChildScrollView( 18 child: Column( 19 children: \u0026lt;Widget\u0026gt;[ 20 for (var i = 0; i \u0026lt; 10; i++) buildTextField(), 21 ], 22 ), 23 ), 24 ), 25 ); 26 } 27 28 TextField buildTextField() { 29 return TextField( 30 onEditingComplete: () { 31 if (node.focusedChild == node.children.last) { 32 print(\u0026#39;submit\u0026#39;); 33 } else { 34 node.nextFocus(); 35 } 36 }, 37 ); 38 } 39} 这次连 FocusNode 都不需要自己写了, 直接用 Scope 里的\n这个 example 的样子:\n这是因为 TextField 是 EditableText 的封装\n然后是在 EditableText 里, attach 到了 context 上 看到这里, 是不是发现其实有的东西很简单, 接下来复杂一下\n再进阶 1import \u0026#39;package:flutter/material.dart\u0026#39;; 2 3class Example3 extends StatefulWidget { 4 @override 5 _Example3State createState() =\u0026gt; _Example3State(); 6} 7 8class _Example3State extends State\u0026lt;Example3\u0026gt; { 9 FocusScopeNode node = FocusScopeNode(); 10 11 @override 12 Widget build(BuildContext context) { 13 return Scaffold( 14 appBar: AppBar(), 15 body: FocusScope( 16 node: node, 17 child: SingleChildScrollView( 18 child: Padding( 19 padding: const EdgeInsets.all(8.0), 20 child: Column( 21 children: \u0026lt;Widget\u0026gt;[ 22 for (var i = 0; i \u0026lt; 5; i++) buildTextField(), 23 Row( 24 children: \u0026lt;Widget\u0026gt;[ 25 Expanded( 26 child: TextField( 27 onEditingComplete: onEdit, 28 ), 29 ), 30 RaisedButton( 31 onPressed: () {}, 32 child: Text(\u0026#39;假装获取验证码\u0026#39;), 33 ), 34 ], 35 ), 36 for (var i = 0; i \u0026lt; 5; i++) buildTextField(), 37 ], 38 ), 39 ), 40 ), 41 ), 42 floatingActionButton: FloatingActionButton( 43 onPressed: () { 44 print(node.traversalChildren.length); 45 }, 46 child: Icon(Icons.check), 47 ), 48 ); 49 } 50 51 TextField buildTextField() { 52 return TextField( 53 onEditingComplete: onEdit, 54 ); 55 } 56 57 void onEdit() { 58 node.nextFocus(); 59 } 60} 这种偶尔旁边多了一个按钮的, 属于比较常见的方式, 然后上面代码突然就不好用了 这时候就需要改代码了\n1floatingActionButton: FloatingActionButton( 2onPressed: () { 3 print(node.children.length); // 12 4}, 5child: Icon(Icons.check), 6), 为啥变 12 了呢, 不是只有 11 个输入框吗?\n这里就和我开始说的对上了, 很多按钮也有 focus.\n那么怎么在回车时跳过这个按钮呢\n1 RaisedButton( 2 onPressed: () {}, 3 focusNode: FocusNode(skipTraversal: true), 4 child: Text(\u0026#39;假装获取验证码\u0026#39;), 5), 是的, 就是这样, 给按钮手动传入一个 FocusNode, 然后 skip 就可以了\n完整代码:\n1import \u0026#39;package:flutter/material.dart\u0026#39;; 2 3class Example3 extends StatefulWidget { 4 @override 5 _Example3State createState() =\u0026gt; _Example3State(); 6} 7 8class _Example3State extends State\u0026lt;Example3\u0026gt; { 9 FocusScopeNode node = FocusScopeNode(); 10 11 @override 12 Widget build(BuildContext context) { 13 return Scaffold( 14 appBar: AppBar(), 15 body: FocusScope( 16 node: node, 17 child: SingleChildScrollView( 18 child: Padding( 19 padding: const EdgeInsets.all(8.0), 20 child: Column( 21 children: \u0026lt;Widget\u0026gt;[ 22 for (var i = 0; i \u0026lt; 5; i++) buildTextField(), 23 Row( 24 children: \u0026lt;Widget\u0026gt;[ 25 Expanded( 26 child: TextField( 27 onEditingComplete: onEdit, 28 ), 29 ), 30 RaisedButton( 31 onPressed: () {}, 32 focusNode: FocusNode(skipTraversal: true), 33 child: Text(\u0026#39;假装获取验证码\u0026#39;), 34 ), 35 ], 36 ), 37 for (var i = 0; i \u0026lt; 5; i++) buildTextField(), 38 ], 39 ), 40 ), 41 ), 42 ), 43 floatingActionButton: FloatingActionButton( 44 onPressed: () { 45 print(node.traversalChildren.length); 46 }, 47 child: Icon(Icons.check), 48 ), 49 ); 50 } 51 52 TextField buildTextField() { 53 return TextField( 54 onEditingComplete: onEdit, 55 ); 56 } 57 58 void onEdit() { 59 node.nextFocus(); 60 } 61} 所以总结一下步骤\n将所有的输入框包在一个 FocusScope 里, 设置 FocusScopeNode. 将有焦点但不是输入框的控件设置一个 FocusNode(skipTraversal: true) 使用FocusScopeNode的nextFocus方法 后记 本篇到此, 本系列的后续预计要深爬一下源码\n以上\n","link":"https://kikt.top/posts/flutter/focusnode-1/","section":"posts","tags":["flutter","焦点","focus","focusNode"],"title":"Flutter FocusNode 焦点那点事-(一)"},{"body":"","link":"https://kikt.top/tags/caddy/","section":"tags","tags":null,"title":"caddy"},{"body":"","link":"https://kikt.top/tags/server/","section":"tags","tags":null,"title":"server"},{"body":"","link":"https://kikt.top/categories/server/","section":"categories","tags":null,"title":"server"},{"body":"最近在尝试 flutter web, 会遇到一个问题, app 没问题, 然而同样的代码在 web 里就不好使了, 主要就是跨域的问题\n搜了一下各种方案都是 nginx 的, 但是我抄过来发现不好使..\n所以自己摸索一下解决方案\n这个方案只适合于本地开发调试, 真实部署时只有两种方案\n让服务器 api 允许跨域 部署到和服务器同一个域名,同一个端口下 另: 目前个人还是觉得 flutter web 不适合商用, 比较适合的场景是, 没有 android/ios 插件的项目中做远端展示使用,比如内部就不用分发 apk/ipa 了, 那两个东西打包太慢了, 这时候直接用 flutter web 就比较靠谱了\n下载 Caddy 官网: 找最新版本下载\n因为这货是 GO 语言开发的, 所以只有单文件就可以部署了\n我是 mac os, 我用的是 brew 安装的, brew install caddy\n安装好了以后查看一下版本, 一定要是 2.0+ 版本的\n1$ caddy version 2v2.0.0 h1:pQSaIJGFluFvu8KDGDODV8u4/QRED/OPyIR+MWYYse8= 注意: 因为这东西 2.0 版本有大更改, 配置文件和 1.x 并不通用, 我这里使用的是 2.0 语法, 1.x 版本的不要对号入座\n配置 Caddyfile 注意: 文件名一定要是 Caddyfile, 大小写不能错\n1:8088 { 2 reverse_proxy /* http://xxxx:80 { 3 header_up Host {http.reverse_proxy.upstream.hostport} 4 header_down Access-Control-Allow-Headers * 5 header_down Access-Control-Allow-Origin * 6 } 7} 我这里使用的是 8088 端口, 远端端口是 80\n注意 reverse_proxy 后面的 /* 不能拉下\n接着 header_up 是反代中替换请求头 Host, 有的服务器会检查这个 host.\nheader_down 就是在下发的响应内添加响应头, 我这里测试这两个都需要有, 不然会跨域, 不知道为啥网上都说只添加Access-Control-Allow-Origin就可以了\n启动 把 caddy 配置到环境变量, 或者用完整路径启动它, Caddyfile 应该在当前运行目录下\n1$ ls 2Caddyfile 3 4$ ~/Downloads/caddy run --watch 5using adjacent Caddyfile 62020/06/06 06:12:12.262 INFO admin admin endpoint started {\u0026#34;address\u0026#34;: \u0026#34;tcp/localhost:2019\u0026#34;, \u0026#34;enforce_origin\u0026#34;: false, \u0026#34;origins\u0026#34;: [\u0026#34;localhost:2019\u0026#34;, \u0026#34;[::1]:2019\u0026#34;, \u0026#34;127.0.0.1:2019\u0026#34;]} 72020/06/06 14:12:12 [INFO][cache:0xc0006b2b90] Started certificate maintenance routine 82020/06/06 06:12:12.263 INFO tls cleaned up storage units 92020/06/06 06:12:12.264 INFO autosaved config {\u0026#34;file\u0026#34;: \u0026#34;/Users/cai/Library/Application Support/Caddy/autosave.json\u0026#34;} 102020/06/06 06:12:12.264 INFO serving initial configuration 112020/06/06 06:12:12.264 INFO watcher watching config file for changes {\u0026#34;config_file\u0026#34;: \u0026#34;Caddyfile\u0026#34;} 如果没有异常退出就说明成功了, 接着把你的请求的 host 替换为 localhost:8088 就可以了\n","link":"https://kikt.top/posts/server/caddy/cros_for_local_dev/","section":"posts","tags":["caddy","server"],"title":"用 Caddy 解决 web 开发中本地跨域的问题"},{"body":"","link":"https://kikt.top/tags/navigator/","section":"tags","tags":null,"title":"navigator"},{"body":"因为随着开发时间越来越长, 对于很多东西又有了新的理解, 是时候回头对于某些东西进行查漏补缺了\n本篇就来补一补路由的东西\nGlobalKey 这东西要单独说一说, 设置一下这东西, 你的 WidgetsApp 会把它设置给 Navigator, 这东西一旦设置成功, 后续就可以不用 Navigator.of, 拿到 NavigatorState 的实例了\n然后这东西设置成全局的, 就可以在今后跳转的时候不用 context 了, 并且可以利用这个东西里的 context 来拿到全局的 Provider 类(这个不在本篇预计范围内)\n设置:\n1MaterialApp( 2 navigatorKey: navigatorKey, 3); 使用:\n1NavigatorState get navigator =\u0026gt; navigatorKey.currentState; RouteHelper 全文如下, 但是有一个问题, 这个 navigatorKey 的 context 不能用于 showDialog, 所以需要自定义 dialog 的 route,才可以无 context 调用, 所以加了新的方法\n同样的, 以前的 helper 中 push 才需要 context,pop 不需要考虑太多,所以没有 pop 方法, 现在因为有了全局 navigatorKey 来做路由, 所以添加了 pop 相关的方法\n1import \u0026#39;package:flutter/material.dart\u0026#39;; 2 3import \u0026#39;dialog_route.dart\u0026#39;; 4 5class RouteHelper { 6 GlobalKey\u0026lt;NavigatorState\u0026gt; stateKey; 7 8 RouteHelper(this.stateKey); 9 10 NavigatorState get navigator =\u0026gt; stateKey.currentState; 11 12 AnimUtils anim = AnimUtils(); 13 14 Future\u0026lt;T\u0026gt; pushWidget\u0026lt;T\u0026gt;( 15 Widget widget, { 16 bool replaceRoot = false, 17 bool replaceCurrent = false, 18 dynamic replaceResult, 19 }) { 20 final materialRoute = MaterialPageRoute\u0026lt;T\u0026gt;(builder: (BuildContext context) { 21 return widget; 22 }); 23 return pushRoute\u0026lt;T\u0026gt;( 24 materialRoute, 25 replaceRoot: replaceRoot, 26 replaceCurrent: replaceCurrent, 27 replaceResult: replaceResult, 28 ); 29 } 30 31 Future\u0026lt;T\u0026gt; pushRoute\u0026lt;T\u0026gt;( 32 Route\u0026lt;T\u0026gt; newRoute, { 33 bool replaceRoot = false, 34 bool replaceCurrent = false, 35 dynamic replaceResult, 36 }) async { 37 assert(!(replaceCurrent \u0026amp;\u0026amp; replaceRoot), \u0026#34;这两货只有一个可以为true\u0026#34;); 38 if (replaceRoot) { 39 while (true) { 40 if (!(await navigator.maybePop())) { 41 break; 42 } 43 } 44 return navigator.pushReplacement\u0026lt;T, dynamic\u0026gt;( 45 newRoute, 46 result: replaceResult, 47 ); 48 } 49 if (replaceCurrent) { 50 return navigator.pushReplacement\u0026lt;T, dynamic\u0026gt;( 51 newRoute, 52 result: replaceResult, 53 ); 54 } 55 return navigator.push\u0026lt;T\u0026gt;(newRoute); 56 } 57 58 Future\u0026lt;T\u0026gt; showDialog\u0026lt;T\u0026gt;( 59 Widget dialog, { 60 TransitionsWidgetBuilder transitionsWidgetBuilder, 61 TransitionsWidgetBuilder pageBuilder, 62 Duration transitionsDuration = const Duration(milliseconds: 300), 63 }) { 64 // pageBuilder ??= anim.opacity; 65 pageBuilder ??= anim.empty; 66 transitionsWidgetBuilder ??= anim.opacity; 67 return pushRoute\u0026lt;T\u0026gt;( 68 DialogRoute\u0026lt;T\u0026gt;( 69 child: dialog, 70 pageBuilder: pageBuilder, 71 transitionsWidgetBuilder: transitionsWidgetBuilder, 72 transitionDuration: transitionsDuration, 73 ), 74 ); 75 } 76 77 bool pop\u0026lt;T\u0026gt;([T result]) { 78 return navigator.pop(result); 79 } 80 81 Future\u0026lt;bool\u0026gt; maybePop\u0026lt;T\u0026gt;([T result]) async { 82 return navigator.maybePop(result); 83 } 84} 85 86class AnimUtils { 87 Widget opacity(BuildContext context, Animation\u0026lt;double\u0026gt; animation, 88 Animation\u0026lt;double\u0026gt; secondaryAnimation, Widget child) { 89 return AnimatedBuilder( 90 builder: (BuildContext context, Widget child) { 91 return Opacity( 92 opacity: animation.value, 93 child: child, 94 ); 95 }, 96 animation: animation, 97 child: child, 98 ); 99 } 100 101 Widget empty(BuildContext context, Animation\u0026lt;double\u0026gt; animation, 102 Animation\u0026lt;double\u0026gt; secondaryAnimation, Widget child) { 103 return AnimatedBuilder( 104 builder: (BuildContext context, Widget child) { 105 return child; 106 }, 107 animation: animation, 108 child: child, 109 ); 110 } 111} 对应的一个关联类, 内部是 dialog 的 route 动画等东西,dialog_route.dart\n1import \u0026#39;package:flutter/material.dart\u0026#39;; 2 3typedef Widget DialogWidgetBuilder( 4 BuildContext context, 5 Animation\u0026lt;double\u0026gt; animation, 6 Animation\u0026lt;double\u0026gt; secondaryAnimation, 7 Widget child, 8); 9 10typedef Widget TransitionsWidgetBuilder( 11 BuildContext context, 12 Animation\u0026lt;double\u0026gt; animation, 13 Animation\u0026lt;double\u0026gt; secondaryAnimation, 14 Widget child, 15); 16 17class DialogRoute\u0026lt;T\u0026gt; extends PopupRoute\u0026lt;T\u0026gt; { 18 final DialogWidgetBuilder pageBuilder; 19 final TransitionsWidgetBuilder transitionsWidgetBuilder; 20 final Duration transitionDuration; 21 final bool maintainState; 22 final bool barrierDismissible; 23 final Widget child; 24 25 DialogRoute({ 26 this.pageBuilder, 27 this.maintainState = true, 28 this.transitionDuration = const Duration(milliseconds: 250), 29 this.barrierDismissible = true, 30 this.child, 31 this.transitionsWidgetBuilder, 32 }) : assert(!(pageBuilder == null \u0026amp;\u0026amp; child == null)); 33 34 @override 35 Color get barrierColor =\u0026gt; Colors.black38; 36 37 @override 38 String get barrierLabel =\u0026gt; \u0026#34;title\u0026#34;; 39 40 @override 41 Widget buildPage(BuildContext context, Animation\u0026lt;double\u0026gt; animation, 42 Animation\u0026lt;double\u0026gt; secondaryAnimation) { 43 if (pageBuilder == null) { 44 return child; 45 } 46 return pageBuilder(context, animation, secondaryAnimation, child); 47 } 48 49 @override 50 Widget buildTransitions(BuildContext context, Animation\u0026lt;double\u0026gt; animation, 51 Animation\u0026lt;double\u0026gt; secondaryAnimation, Widget child) { 52 if (transitionsWidgetBuilder == null) { 53 return super 54 .buildTransitions(context, animation, secondaryAnimation, child); 55 } 56 return transitionsWidgetBuilder( 57 context, animation, secondaryAnimation, child); 58 } 59} 60 61mixin TransitionsMixin { 62 Widget buildTransitions(BuildContext context, Animation\u0026lt;double\u0026gt; animation, 63 Animation\u0026lt;double\u0026gt; secondaryAnimation, Widget child); 64 65 Duration transitionsDuration() =\u0026gt; Duration(milliseconds: 300); 66} 67 68mixin TransitionsWidgetMixin on Widget, TransitionsMixin {} 69 70mixin TransitionsStateMixin on State, TransitionsMixin {} BaseProvider 还有一篇不得不一起说的东西: 项目中所有提供者的基类, 这个类中会封装一些项目可能用到的东西, 以方便后续的状态的提供者继承以后拥有很多能力\n1import \u0026#39;package:flutter/material.dart\u0026#39;; 2 3class BaseProvider extends ChangeNotifier { 4 static final navigatorKey = GlobalKey\u0026lt;NavigatorState\u0026gt;(); 5 6 static RouteHelper _routeHelper = RouteHelper(navigatorKey); 7 8 final _notifiers = List\u0026lt;ChangeNotifier\u0026gt;(); 9 10 final _autoDisposeList = List\u0026lt;ChangeNotifier\u0026gt;(); 11 12 void bindChangeNotifier( 13 ChangeNotifier notifier, { 14 bool autoDispose = true, 15 }) { 16 if (autoDispose) { 17 _autoDisposeList.add(notifier); 18 } 19 notifier.addListener(notifyListeners); 20 _notifiers.add(notifier); 21 } 22 23 void bindChangeNotifiers( 24 List\u0026lt;ChangeNotifier\u0026gt; notifiers, { 25 bool autoDispose = true, 26 }) { 27 for (var notifier in notifiers) { 28 bindChangeNotifier(notifier, autoDispose: autoDispose); 29 } 30 } 31 32 void unbindChangeNotifier(ChangeNotifier notifier) { 33 notifier.removeListener(notifyListeners); 34 _notifiers.remove(notifier); 35 } 36 37 RouteHelper get routeHelper =\u0026gt; _routeHelper; 38 39 NavigatorState get navigator =\u0026gt; routeHelper.navigator; 40 41 @override 42 void dispose() { 43 for (final notifier in _notifiers.toList()) { 44 unbindChangeNotifier(notifier); 45 } 46 for (final notifier in _autoDisposeList) { 47 notifier.dispose(); 48 } 49 super.dispose(); 50 } 51} 这样就简单的将 RouteHelper 单例在了 provider 里, 在书写逻辑后直接就可以使用routeHelper.push(Widget())来跳转页面\n而 MaterialApp 中就可以设置BaseProvider.navigatorKey到 navigatorKey 字段上\n然后有一点需要说明, pop 方法在官方的中有修改, 返回值从 bool 变成了 void\n请根据你自己的 flutter 版本修改返回值即可\n后记 因为遇到了 pop 返回值和 dart-pad 上不一样的问题, 然后不小心把 dartpad 关了, 懒得再复制了, 所以没有完整代码说明, 以上\n","link":"https://kikt.top/posts/flutter/route/navigator-helper2/","section":"posts","tags":["flutter","navigator","route"],"title":"Navigator Helper2"},{"body":"","link":"https://kikt.top/tags/route/","section":"tags","tags":null,"title":"route"},{"body":"今天举国哀悼, 进入各种大厂的 app 也可以看到主色都变成灰色的了\n作为程序员我们肯定会想怎么可以实现的, 我简单研究了 10 分钟, flutter 中只要在整体外面套一个 ShaderMask, 然后修改 blendMode 即可\n核心代码:\n1class MyApp extends StatelessWidget { 2 // This widget is the root of your application. 3 @override 4 Widget build(BuildContext context) { 5 return ShaderMask( 6 child: OKToast( 7 child: MaterialApp( 8 title: \u0026#39;Pick Image Demo\u0026#39;, 9 theme: ThemeData( 10 primarySwatch: Colors.lime, 11 ), 12 home: MyHomePage(title: \u0026#39;Pick Image Demo\u0026#39;), 13 ), 14 ), 15 shaderCallback: (Rect bounds) { 16 return ui.Gradient.linear(Offset.zero, 17 Offset(bounds.width, bounds.height), [Colors.grey, Colors.grey]); 18 }, 19 // blendMode: BlendMode.dst, 20 blendMode: BlendMode.saturation, 21 ); 22 } 23} 在最外层套一个ShaderMask, 然后返回一个 shader 就可以了, 这里我用的是渐变的Gradient ,还有别的方式可以用\n效果: 之前: [文件]\n之后:\n","link":"https://kikt.top/posts/flutter/grey-app/","section":"posts","tags":["flutter","灰度"],"title":"flutter 怎么实现app整体灰度"},{"body":"","link":"https://kikt.top/tags/%E7%81%B0%E5%BA%A6/","section":"tags","tags":null,"title":"灰度"},{"body":"","link":"https://kikt.top/tags/aar/","section":"tags","tags":null,"title":"aar"},{"body":"本篇主题: 在 flutter 插件中引入 aar\n本篇只包含 android 部分, iOS 的 framework 直接在 podspec 中引入就可以了,所以本篇略过不表\n做过安卓开发的朋友可能知道, aar 文件如果作为本地文件直接引入 library, 然后 app 引用 library 是会报找不到aar的, 需要在 app 中使用 flatDir 进行引入, 这种方式的缺点在于, 你必须在每个项目去配置, 很有侵入性\n熟悉 flutter 插件开发的朋友都知道,在我们开发 flutter 插件时, 插件是以 library module 的形式引入到项目中的\n这时如果 sdk 方对于安卓只提供了 aar, 在这种大前提下,我们有如下几种方法:\n使用 maven 公开服, 比如 jcenter, 或其他的 maven 仓库 使用本地 maven 仓库 本篇就使用这种本地 maven 仓库的方案来做\n完成本地 maven 的步骤 创建插件项目 第一步肯定是创建一个 flutter 插件\n1flutter create -t plugin example_for_flutter_plugin_local_maven 置入 aar 我这里用蒲公英的的 aar 举例:\n下载下来放在 android 目录下\n在插件的 android 目录下创建一个文件夹,把 aar 放进去, 我这里取名为 aar\n1mkdir android/aar 2cd android/aar 3wget https://github.com/Pgyer/mvn_repo_pgyer/blob/master/com/pgyersdk/sdk/3.0.9/sdk-3.0.9.aar?raw=true #下载 4mv sdk-3.0.9.aar?raw=true sdk.aar #改名 使用 aar 文件创建本地 maven 仓库 需要一个 maven 二进制程序, mac 的话是用$ brew install maven即可, 其他系统自行搜索 maven 安装 验证安装$ mvn -v 使用命令行创建 1mvn deploy:deploy-file -Dfile=sdk.aar -Durl=\u0026#34;file://.\u0026#34; # 这步会报错 2 3[ERROR] Failed to execute goal org.apache.maven.plugins:maven-deploy-plugin:2.7:deploy-file (default-cli) on project standalone-pom: The artifact information is incomplete or not valid: 4[ERROR] [0] \u0026#39;groupId\u0026#39; is missing. 5[ERROR] [1] \u0026#39;artifactId\u0026#39; is missing. 6[ERROR] [2] \u0026#39;version\u0026#39; is missing. 7[ERROR] 8[ERROR] -\u0026gt; [Help 1] 9[ERROR] 10[ERROR] To see the full stack trace of the errors, re-run Maven with the -e switch. 11[ERROR] Re-run Maven using the -X switch to enable full debug logging. 12[ERROR] 13[ERROR] For more information about the errors and possible solutions, please read the following articles: 14[ERROR] [Help 1] http://cwiki.apache.org/confluence/display/MAVEN/MojoExecutionException 这里-Dfile 指向 aar 文件, url 指向目标地址, 我这里因为要部署在 aar 文件夹里, 所以直接用.代表当前文件夹, 它提示我缺少 3 个东西, 组名,品名,版本号\n1mvn deploy:deploy-file -Dfile=sdk.aar -Durl=\u0026#34;file://.\u0026#34; -DgroupId=\u0026#34;com.pgyer\u0026#34; -DartifactId=\u0026#34;sdk\u0026#34; -Dversion=\u0026#34;3.0.9\u0026#34; 2 3[INFO] Scanning for projects... 4[INFO] 5[INFO] ------------------\u0026lt; org.apache.maven:standalone-pom \u0026gt;------------------- 6[INFO] Building Maven Stub Project (No POM) 1 7[INFO] --------------------------------[ pom ]--------------------------------- 8[INFO] 9[INFO] --- maven-deploy-plugin:2.7:deploy-file (default-cli) @ standalone-pom --- 10Uploading to remote-repository: file://./com/pgyer/sdk/3.0.9/sdk-3.0.9.aar 11Uploaded to remote-repository: file://./com/pgyer/sdk/3.0.9/sdk-3.0.9.aar (134 kB at 3.3 MB/s) 12Uploading to remote-repository: file://./com/pgyer/sdk/3.0.9/sdk-3.0.9.pom 13Uploaded to remote-repository: file://./com/pgyer/sdk/3.0.9/sdk-3.0.9.pom (415 B at 208 kB/s) 14Downloading from remote-repository: file://./com/pgyer/sdk/maven-metadata.xml 15Downloaded from remote-repository: file://./com/pgyer/sdk/maven-metadata.xml (292 B at 32 kB/s) 16Uploading to remote-repository: file://./com/pgyer/sdk/maven-metadata.xml 17Uploaded to remote-repository: file://./com/pgyer/sdk/maven-metadata.xml (292 B at 146 kB/s) 18[INFO] ------------------------------------------------------------------------ 19[INFO] BUILD SUCCESS 20[INFO] ------------------------------------------------------------------------ 21[INFO] Total time: 0.407 s 22[INFO] Finished at: 2020-03-30T16:00:25+08:00 23[INFO] ------------------------------------------------------------------------ 这样就 ok 了, 所有文件都生成了\n1tree . 2. 3├── com 4│ └── pgyer 5│ └── sdk 6│ ├── 3.0.9 7│ │ ├── sdk-3.0.9.aar 8│ │ ├── sdk-3.0.9.aar.md5 9│ │ ├── sdk-3.0.9.aar.sha1 10│ │ ├── sdk-3.0.9.pom 11│ │ ├── sdk-3.0.9.pom.md5 12│ │ └── sdk-3.0.9.pom.sha1 13│ ├── maven-metadata.xml 14│ ├── maven-metadata.xml.md5 15│ └── maven-metadata.xml.sha1 16└── sdk.aar 这是标准的 maven 目录结构\n这时候 sdk.aar 就没用了, 可以删除\n编辑 gradle 文件 用 studio 打开项目 example/android\n1 2// 定义一个方法, 用于获取当前moudle的dir 3def getCurrentProjectDir() { 4 String result = \u0026#34;\u0026#34; 5 rootProject.allprojects { project -\u0026gt; 6 if (project.properties.get(\u0026#34;identityPath\u0026#34;).toString() == \u0026#34;:example_for_flutter_plugin_local_maven\u0026#34;) { // 这里是flutter的约定, 插件的module名是插件名, :是gradle的约定. project前加: 7 result = project.properties.get(\u0026#34;projectDir\u0026#34;).toString() 8 } 9 } 10 return result 11} 12 13rootProject.allprojects { 14 // 这个闭包是循环所有project, 我们让这个仓库可以被所有module找到 15 def dir = getCurrentProjectDir() 16 repositories { 17 google() 18 jcenter() 19 maven { // 添加这个指向本地的仓库目录 20 url \u0026#34;$dir/aar\u0026#34; 21 } 22 } 23} 24 25dependencies { 26 implementation \u0026#34;com.pgyer:sdk:3.0.9\u0026#34; // 添加这个, 接着点sync project with gradle file 刷新一下项目就可以了. 是使用api还是implementation根据你的实际情况来看就好了 27} 后记 本篇使用了 gradle 来完成了对主项目无侵入的方式配置 maven\n这样主工程无论是任何项目可以引用到这个 aar 的内容, 当然这个方案也适用于非 flutter 项目\n仓库地址: 以上\n","link":"https://kikt.top/posts/flutter/plugin/flutter-sdk-import-aar/","section":"posts","tags":["flutter","maven","aar"],"title":"Flutter 插件开发之引入aar到安卓部分 并使用本地maven"},{"body":"","link":"https://kikt.top/tags/maven/","section":"tags","tags":null,"title":"maven"},{"body":"我是标题\n1void main(){ 2 print(\u0026#39;Hello\u0026#39;); 3} 1document.getElementById(\u0026#34;\u0026#34;); 1int main(){ 2 printf(\u0026#34;Hello world\u0026#34;); 3 return 0; 4} 1- (NSString*) log { 2 NSLog(@\u0026#34;Hi objc\u0026#34;); 3} 1fun main(){ 2 println(\u0026#34;Hello kotlin\u0026#34;) 3} 1class Project { 2 func foo(str: String){ 3 print(\u0026#34;Hello :\\(str)\u0026#34;) 4 } 5} ","link":"https://kikt.top/posts/hello/","section":"posts","tags":null,"title":"hello"},{"body":"","link":"https://kikt.top/tags/cocoapods/","section":"tags","tags":null,"title":"cocoapods"},{"body":"","link":"https://kikt.top/tags/github/","section":"tags","tags":null,"title":"github"},{"body":"","link":"https://kikt.top/categories/ios/","section":"categories","tags":null,"title":"ios"},{"body":"","link":"https://kikt.top/tags/ios/","section":"tags","tags":null,"title":"iOS"},{"body":"","link":"https://kikt.top/tags/jsdelivr/","section":"tags","tags":null,"title":"jsdelivr"},{"body":"iOS 开发时, cocoapods(后简称 pod) 是很常用的工具\n我们偶尔也会自己开发 pod 库并上传到 pod 上\npod 的源码支持多种来源, 本地 path git http 等\n一般来说, 如果是纯开源库, 我们直接把源码上传到 github , 然后使用 git 依赖即可\n但是这有一个问题, github 的速度在中国大陆并不快, 我们有没有办法加速它呢?\n这时候经过搜索, jsdelivr 出现在了搜索引擎里, 号称国内外都可用的 cdn, 我用 wget 测试了一下, 国内外都可以保证 10M+/s 的速度\njsdelivr 介绍 这东西本身最初目的是为了加速 js/css 的访问\n但是, 上面也说了, 支持\u0026quot;任何\u0026quot;在 github 上的仓库, 很好, 我就喜欢这样的东西\n版本号的坑 文档上说支持所有 ref 作为版本号, 然而不是, 我这里测试只支持 tag/release\n包体大小限制 我的目的是为了给 flutter_ijkplayer 的 iOS 仓库找一个下载地址, ijkplayer 的 iOS 部分很大, 我打包完有 150M, 用了 xz 压缩方案让包变成了 35M\n但 jsdelivr 有两个限制: 单文件不能大于 20M, 仓库的某版本不能大于 50M, 那这里就有问题了, 我的 xz 是 35M, 超过限制了, 这里我就要找解决方案了\n解决之路 思考 首先是分拆, 这个好说, macOS 的 split 命令就支持\n那合并呢? cat 命令就可以了\n但怎么在 pod 中做呢, 我搜了一下 podspec 的语法, 发现可以配置 prepare_command 参数, 这个参数在安装时会被使用, 并且使用完毕后才会校验库是否存在\n我们可以在这一步中来做真实的下载和合并操作\n有了完整思路, 我要开始着手实施了\n发包 前提: 假设我本地有一个 framework.tar.xz, 这个是已经打包好的库文件\n分割文件 1split -b 10m IJKMediaFramework.tar.xz IJKMediaFramework.tar.xz. 这里要注意最后一个参数最后有一个. 这样就能完成拆分\n1ll IJKMediaFramework.tar.xz* 2-rw-r--r-- 1 caijinglong staff 33M 3 18 11:34 IJKMediaFramework.tar.xz 3-rw-r--r-- 1 caijinglong staff 10M 3 18 11:34 IJKMediaFramework.tar.xz.aa 4-rw-r--r-- 1 caijinglong staff 10M 3 18 11:34 IJKMediaFramework.tar.xz.ab 5-rw-r--r-- 1 caijinglong staff 10M 3 18 11:34 IJKMediaFramework.tar.xz.ac 6-rw-r--r-- 1 caijinglong staff 3.0M 3 18 11:34 IJKMediaFramework.tar.xz.ad 测试一下合并 1cat IJKMediaFramework.tar.xz.* \u0026gt; IJKMediaFramework-Test.tar.xz 2 3ll IJKMediaFramework-Test.tar.xz 4-rw-r--r-- 1 caijinglong staff 33M 3 18 13:58 IJKMediaFramework-Test.tar.xz 这里大小是 ok 的. 再解压一下试试\n1mkdir test 2mv IJKMediaFramework-Test.tar.xz test 3cd test 4tar xvf IJKMediaFramework-Test.tar.xz 5 6 7ll 8drwxr-xr-x 7 caijinglong staff 224B 3 18 11:33 IJKMediaFramework.framework 9-rw-r--r-- 1 caijinglong staff 1.0K 3 18 11:33 LICENSE 10 11ll IJKMediaFramework.framework 12total 295944 13drwxr-xr-x 14 caijinglong staff 448B 3 18 11:33 Headers 14-rw-r--r-- 1 caijinglong staff 130M 3 18 11:33 IJKMediaFramework 15-rw-r--r-- 1 caijinglong staff 757B 3 18 11:33 Info.plist 16drwxr-xr-x 3 caijinglong staff 96B 3 18 11:33 Modules 17drwxr-xr-x 4 caijinglong staff 128B 3 18 11:33 libyuv 解压缩也成功了, 接着就是编写脚本了\n合并脚本 我创建了一个 cat.sh 脚本\n1wget https://cdn.jsdelivr.net/gh/CaiJingLong/flutter_ijkplayer_pod_spliter@0.2.2/IJKMediaFramework.tar.xz.aa 2wget https://cdn.jsdelivr.net/gh/CaiJingLong/flutter_ijkplayer_pod_spliter@0.2.2/IJKMediaFramework.tar.xz.ab 3wget https://cdn.jsdelivr.net/gh/CaiJingLong/flutter_ijkplayer_pod_spliter@0.2.2/IJKMediaFramework.tar.xz.ac 4wget https://cdn.jsdelivr.net/gh/CaiJingLong/flutter_ijkplayer_pod_spliter@0.2.2/IJKMediaFramework.tar.xz.ad 5cat IJKMediaFramework.tar.xz.* \u0026gt; IJKMediaFramework.tar.xz 6tar xvf IJKMediaFramework.tar.xz 7rm IJKMediaFramework.tar.xz.* IJKMediaFramework.tar.xz 这个脚本会完成下载, 连接, 解压, 删除压缩包的过程, 这样剩余的就是干净的文件了, 只包含 Framework LICENSE README\n上传 github 这里根据你自己的情况选择上传方式, 我是用的 python 脚本配合 github 的 rest v3 api 上传的, 你可以用 git 或者 gihtub 的网页端 接着有一步很重要的步骤, release 这个版本, 不然 jsdelivr 找不到\n我的脚本地址: 需要配置两个环境变量 一个是版本号 一个是 GITHUB_TOKEN, 当然如果想要用的话, 还是需要其他修改的, 比如仓库名, 拥有者名等等信息\npodspec 1Pod::Spec.new do |spec| 2 3 version = \u0026#34;0.2.2\u0026#34; 4 spec.name = \u0026#34;FlutterIJK\u0026#34; 5 spec.version = \u0026#34;#{version}\u0026#34; 6 spec.summary = \u0026#34;IJKPlayer for Flutter.\u0026#34; 7 spec.description = \u0026lt;\u0026lt;-DESC 8 IJKPlayer for flutter 9 DESC 10 11 spec.homepage = \u0026#34;https://github.com/CaiJingLong/flutter_ijkplayer_pod\u0026#34; 12 spec.license = { :type =\u0026gt; \u0026#39;MIT\u0026#39;, :file =\u0026gt;\u0026#39;LICENSE\u0026#39; } 13 spec.author = { \u0026#34;Caijinglong\u0026#34; =\u0026gt; \u0026#34;cjl_spy@163.com\u0026#34; } 14 spec.source = { :http =\u0026gt; \u0026#34;https://cdn.jsdelivr.net/gh/CaiJingLong/flutter_ijkplayer_pod_spliter@#{version}/README.tar.gz\u0026#34;} 15 spec.vendored_frameworks = \u0026#39;IJKMediaFramework.framework\u0026#39; 16 spec.frameworks = \u0026#34;AudioToolbox\u0026#34;, \u0026#34;AVFoundation\u0026#34;, \u0026#34;CoreGraphics\u0026#34;, \u0026#34;CoreMedia\u0026#34;, \u0026#34;CoreVideo\u0026#34;, \u0026#34;MobileCoreServices\u0026#34;, \u0026#34;OpenGLES\u0026#34;, \u0026#34;QuartzCore\u0026#34;, \u0026#34;VideoToolbox\u0026#34;, \u0026#34;Foundation\u0026#34;, \u0026#34;UIKit\u0026#34;, \u0026#34;MediaPlayer\u0026#34; 17 spec.libraries = \u0026#34;bz2\u0026#34;, \u0026#34;z\u0026#34;, \u0026#34;stdc++\u0026#34; 18 19 spec.platform = :ios 20 spec.ios.deployment_target = \u0026#39;8.0\u0026#39; 21 spec.requires_arc = true 22 23 spec.prepare_command = \u0026lt;\u0026lt;-CMD 24 sh cat.sh 25 CMD 26end 这样在 pod install 的过程中会完成如下步骤\n下载 https://cdn.jsdelivr.net/gh/CaiJingLong/flutter_ijkplayer_pod_spliter@#{version}/README.tar.gz 文件 version 是字符串插值的版本号 pod 会帮我们解压这个 gz 运行 gz 中的 cat.sh 脚本来完成下载, 合并, 删除多余文件的操作 trunk, 也就是上传的信息:\n1Updating spec repo `trunk` 2 CDN: trunk Relative path: deprecated_podspecs.txt modified during this run! Returning local 3 CDN: trunk Going to update 15 files 4 CDN: trunk Relative path: all_pods_versions_1_1_5.txt modified during this run! Returning local 5 CDN: trunk Relative path: all_pods_versions_4_9_1.txt modified during this run! Returning local 6 CDN: trunk Relative path: all_pods_versions_1_1_7.txt modified during this run! Returning local 7 CDN: trunk Relative path: all_pods_versions_5_d_c.txt modified during this run! Returning local 8 CDN: trunk Relative path: AlgoliaSearch.yml modified during this run! Returning local 9 CDN: trunk Relative path: all_pods_versions_e_9_d.txt modified during this run! Returning local 10 CDN: trunk Relative path: all_pods_versions_2_1_1.txt modified during this run! Returning local 11 CDN: trunk Relative path: CocoaPods-version.yml modified during this run! Returning local 12 CDN: trunk Relative path: all_pods_versions_7_f_a.txt modified during this run! Returning local 13 CDN: trunk Relative path: all_pods_versions_d_6_9.txt modified during this run! Returning local 14 CDN: trunk Relative path: all_pods_versions_6_0_4.txt modified during this run! Returning local 15 CDN: trunk Relative path: all_pods_versions_f_4_e.txt modified during this run! Returning local 16 CDN: trunk Relative path: all_pods_versions_8_d_3.txt modified during this run! Returning local 17 CDN: trunk Relative path: all_pods_versions_1_9_2.txt modified during this run! Returning local 18 CDN: trunk Relative path: all_pods_versions_c_e_7.txt modified during this run! Returning local 19 - Data URL: https://raw.githubusercontent.com/CocoaPods/Specs/48458c6e0cf376dcb2c374f6b349b960fefa883c/Specs/4/9/1/FlutterIJK/0.2.2/FlutterIJK.podspec.json 20 - Log messages: 21 - March 17th, 21:06: Push for `FlutterIJK 0.2.2\u0026#39; initiated. 22 - March 17th, 21:06: Push for `FlutterIJK 0.2.2\u0026#39; has been pushed (0.922508893 s). 这样就完成了发包的全过程\n组织结构 下面是发包时的目录结构\n1tree output/ 2output/ 3├── IJKMediaFramework.framework 4│ ├── Headers 5│ │ ├── IJKAVMoviePlayerController.h 6│ │ ├── IJKFFMonitor.h 7│ │ ├── IJKFFMoviePlayerController.h 8│ │ ├── IJKFFOptions.h 9│ │ ├── IJKKVOController.h 10│ │ ├── IJKMPMoviePlayerController.h 11│ │ ├── IJKMediaFramework.h 12│ │ ├── IJKMediaModule.h 13│ │ ├── IJKMediaPlayback.h 14│ │ ├── IJKMediaPlayer.h 15│ │ ├── IJKNotificationManager.h 16│ │ └── IJKSDLGLViewProtocol.h 17│ ├── IJKMediaFramework 18│ ├── Info.plist 19│ ├── Modules 20│ │ └── module.modulemap 21│ └── libyuv 22│ ├── include 23│ │ ├── libyuv 24│ │ │ ├── basic_types.h 25│ │ │ ├── compare.h 26│ │ │ ├── compare_row.h 27│ │ │ ├── convert.h 28│ │ │ ├── convert_argb.h 29│ │ │ ├── convert_from.h 30│ │ │ ├── convert_from_argb.h 31│ │ │ ├── cpu_id.h 32│ │ │ ├── macros_msa.h 33│ │ │ ├── mjpeg_decoder.h 34│ │ │ ├── planar_functions.h 35│ │ │ ├── rotate.h 36│ │ │ ├── rotate_argb.h 37│ │ │ ├── rotate_row.h 38│ │ │ ├── row.h 39│ │ │ ├── scale.h 40│ │ │ ├── scale_argb.h 41│ │ │ ├── scale_row.h 42│ │ │ ├── version.h 43│ │ │ └── video_common.h 44│ │ └── libyuv.h 45│ └── lib 46│ └── libyuv.a 47├── IJKMediaFramework.tar.xz 48├── IJKMediaFramework.tar.xz.aa 49├── IJKMediaFramework.tar.xz.ab 50├── IJKMediaFramework.tar.xz.ac 51├── IJKMediaFramework.tar.xz.ad 52├── LICENSE 53├── README.md 54├── README.tar.gz 55├── cat.sh 56└── files lipo 脚本 另外, 我的项目中, 我还编写了一个 lipo 脚本, 用于合并产物, 分割文件, 调用上传的 python\n后记 本篇没有单独的仓库, 但是可以参考 来作为入口看整个过程\n以上\n","link":"https://kikt.top/posts/ios/pod-use-jsdelivr-cdn-to/","section":"posts","tags":["flutter","iOS","cocoapods","github","jsdelivr"],"title":"使用 jsdelivr 加速 cocoapod 库"},{"body":"过场动画 过场动画也就是切换路由时的动画\n这个东西有几种方案可以做\n继承 PageRoute来做, 复写 5 个抽象方法, 并抽象buildTransitions 继承已有的系统类, 比如 MaterialPageRoute 或者 CupertinoPageRoute 一劳永逸的方案, 使用PageTransitionsTheme类结合 MaterialApp 的 theme 的pageTransitionsTheme属性 前两种目前网络上也有一些人做了分享, 但第三种好像很少有人使用, 我这里就来说一下PageTransitionsTheme的用法\n这东西有如下的好处:\n设置一次, 你所有的MaterialPageRoute都可以生效 对于命名路由, 也就是pushNamed体系的也有效 先分析下源码 为啥分析源码? 因为如果上来就用显得不高端\n先找一个大家都知道的切入点, 一般的过场动画都是用的 Navigator.push 方法来实现的\n看看方法里的实现, 会发现很多常见的东西, 比如, 每一个 Route 都有自己的 OverlayEntry\n然后会有一个 install 方法\n而实际调用中, 这个 Overlay 会被插入到 Overlay 栈内, 从而在界面上显示\n经过这一串的调用, 就把 Navigator push 和 Route 关联到了一起, 那么 theme 是怎么和 Route 关联起来的呢, 我们进入 MaterialPageRoute 看一下\n我们看到, 这里是从 Theme 中找到 pageTransitionsTheme, 然后调用 pageTransitionsTheme 的 buildTransitions 方法来完成构建, 所以这就是我们可以在 theme 中一次修改, 多处生效的主因了\n如何使用 前面查看到了源码是如何关联到 pageTransitionsTheme 属性的, 我们接着就是该自定义的时候了\n修改自己的 MyApp, 修改pageTransitionsTheme属性\n1 2class MyApp extends StatelessWidget { 3 // This widget is the root of your application. 4 @override 5 Widget build(BuildContext context) { 6 return MaterialApp( 7 title: \u0026#39;Flutter Demo\u0026#39;, 8 theme: ThemeData( 9 primarySwatch: Colors.blue, 10 pageTransitionsTheme: PageTransitionsTheme( 11 builders: \u0026lt;TargetPlatform, PageTransitionsBuilder\u0026gt;{ 12 TargetPlatform.iOS: createTransition(), 13 TargetPlatform.android: createTransition(), 14 }, 15 ), 16 ), 17 home: MyHomePage(title: \u0026#39;Flutter Demo Home Page\u0026#39;), 18 ); 19 } 20} 使用系统提供的一些动画 1 2PageTransitionsBuilder createTransition() { 3 return FadeUpwardsPageTransitionsBuilder(); 4} 效果如下:\n根据注释, sdk 中有如下几种动画\n其中FadeUpwardsPageTransitionsBuilder对应安卓默认的, PageTransitionsBuilder自然是对应的 iOS\nZoomPageTransitionsBuilder: OpenUpwardsPageTransitionsBuilder:\n自定义 除了已有的, 我们还可以自定义动画, 可以配合 组件来完成酷炫的动画效果, 具体的可以查看\n自定义 MyPageTransitionsBuilder\n1import \u0026#39;package:flutter/material.dart\u0026#39;; 2 3PageTransitionsBuilder createTransition() { 4 // return FadeUpwardsPageTransitionsBuilder(); 5 // return OpenUpwardsPageTransitionsBuilder(); 6 // return ZoomPageTransitionsBuilder(); 7 return MyPageTransitionsBuilder(); 8} 9 10class MyPageTransitionsBuilder extends PageTransitionsBuilder { 11 @override 12 Widget buildTransitions\u0026lt;T\u0026gt;( 13 PageRoute\u0026lt;T\u0026gt; route, 14 BuildContext context, 15 Animation\u0026lt;double\u0026gt; animation, 16 Animation\u0026lt;double\u0026gt; secondaryAnimation, 17 Widget child) { 18 return ScaleTransition( 19 scale: animation, 20 child: RotationTransition( 21 turns: animation, 22 child: child, 23 ), 24 ); 25 } 26} 效果如下\n后记 有问题请在本人下留言(github 登陆即可)\n","link":"https://kikt.top/posts/flutter/route-anim/","section":"posts","tags":["flutter","route","transition","过场动画"],"title":"flutter中的过场动画 PageTransitionsTheme"},{"body":"","link":"https://kikt.top/tags/transition/","section":"tags","tags":null,"title":"transition"},{"body":"","link":"https://kikt.top/tags/%E8%BF%87%E5%9C%BA%E5%8A%A8%E7%94%BB/","section":"tags","tags":null,"title":"过场动画"},{"body":"前言 本篇写一个将 flutter 打包为 aar 置入已有项目的方案\n与不同的是: 本篇使用新版本的 flutter 环境, 使用 build aar 命令构建 aar,并上传至 maven 私服\n开发环境 1$ flutter doctor -v 2[✓] Flutter (Channel stable, v1.12.13+hotfix.7, on Mac OS X 10.15 19A602, locale zh-Hans-CN) 3 • Flutter version 1.12.13+hotfix.7 at /Users/caijinglong/Library/Flutter/flutter_dev 4 • Framework revision 9f5ff2306b (9 天前), 2020-01-26 22:38:26 -0800 5 • Engine revision a67792536c 6 • Dart version 2.7.0 准备步骤 创建宿主工程 这个是模拟你本来的项目\n作为原生开发者自行使用 Android Studio 创建即可\n一个标准的 android 项目, 除了 gradle 版本使用 6.1.1, 和 maven 仓库使用阿里云镜像, 其他并没有什么修改\n创建 flutter 项目 这个是模拟你的 flutter 项目\n使用 module type\n$ flutter create -t module flutter_module_example\n如果你不是这种类型创建的项目, 理论上也可以用 flutter build aar, 但是不保证完全一样\n本机启动一个 maven 私服 这里使用 docker-compose 启动, 根据你自己的情况来安装, 如果你有公司的 maven 私服或你不喜欢用 docker, 则根据你自己的实际情况跳过这步或使用别的 maven 私服\n1version: \u0026#34;3\u0026#34; 2 3services: 4 nexus: 5 image: sonatype/nexus3 6 ports: 7 - 9000:8081 8 volumes: 9 - /Volumes/Samsung-T5/docker/nexus/data:/nexus-data 语法是 宿主机:docker 镜像\n端口是将 docker 的 8081 映射到本机的 9000 端口\nvolumes 是映射 nexus 的数据到本机的文件夹内\n$ docker-compose up 启动 docker\n我这里不是初次安装, 所以没有, 你如果是初次安装可以从 data 文件夹内找到 admin.password 查看初始密码\n一般初次登陆会让你设置一个, 记住它后面要用到\n这个就是私服的 maven url 地址\nflutter 项目 修改项目 本篇修改一下 flutter 项目, 引入一个path_provider\n1dependencies: 2 flutter: 3 sdk: flutter 4 5 # The following adds the Cupertino Icons font to your application. 6 # Use with the CupertinoIcons class for iOS style icons. 7 cupertino_icons: ^0.1.2 8 path_provider: any 实际开发时别用这个 any 版本号, 我只是懒得看最新版是多少而已\n构建 aar $ flutter build aar 来打包\n这里 build 完, console 日志有提示你怎么配置你的 host 项目, 如果你是自己开发, 直接用本地的 repo 目录作为仓库就可以了, 将配置复制到项目里即可\nrepositories 闭包配置可以写在在 host 项目, 也可以配置在 app module 中, 你如果不明白项目和 module 的差别, 可以请教你们安卓原生同事, 也可以自行百度\n其他的配置请配置到 app module 里\n1 2// 添加 maven 仓库 url 3repositories { 4 maven { 5 url \u0026#39;/Volumes/Samsung-T5/code/flutter/exists_blog/flutter_module_example/build/host/outputs/repo\u0026#39; // 这个是我本地的, 你根据你自己的情况肯定不一样, 不要直接复制粘贴我的, 粘贴命令行里的 6 } 7 maven { 8 url \u0026#39;http://download.flutter.io\u0026#39; // 这个是flutter的maven仓库地址 9 } 10} 11 12// 添加依赖 13dependencies { 14 debugImplementation \u0026#39;com.example.flutter_module_example:flutter_debug:1.0\u0026#39; 15 profileImplementation \u0026#39;com.example.flutter_module_example:flutter_profile:1.0\u0026#39; 16 releaseImplementation \u0026#39;com.example.flutter_module_example:flutter_release:1.0\u0026#39; 17} 18 19// 因为android项目默认是没有profile类型的, 这里需要你自己加一个, 然后配置参考debug 20android { 21 buildTypes { 22 profile { 23 initWith debug 24 } 25 } 26} 当然, 实际上不太可能是自己开发, 即便是自己开发, 也不可能家里和公司连目录结构都一模一样, 然后这里就是 maven 私服的作用了, 让依赖相同, 以便于合作开发\n分析下构建产物 这里我们注意到, 我们依赖只有一个 flutter_module_example, 没有 path_provider, 这个就是 maven 帮我们处理的了\n看目录结构, path_provider 是有的, 还分为 release profile debug\n这里是 flutter 项目对应的 pom 文件, 依赖了三部分代码, 这样 maven 就会自动帮你把这三部分代码都下载并依赖\n上传依赖 使用界面上传 这里分别上传就看见了\n因为是演示, 我只上传 release 的, 然后在 host 项目里引用\n项目里, 根目录的build.gradle\n1repositories{ 2 maven{ 3 url \u0026#39;http://localhost:9000/repository/maven-releases/\u0026#39; // 你自己的maven私服地址 4 } 5 maven{ 6 url \u0026#39;http://download.flutter.io\u0026#39; 7 } 8} app 的build.gradle\n1dependencies{ 2 implementation \u0026#39;com.example.flutter_module_example:flutter_release:1.0\u0026#39; 3} 这样就可以了\n当然肯定还有问题, 但是基本的思路已经通了, 接着就是怎么自动化的问题了\n自动化的探索 命令行上传 自动化的话, 肯定需要有工具或者命令行上传\n我这里选择的是命令行的方案\n但在这之前, 我需要先把旧的包删除掉, 以便于保证我命令行的包可以上传成功\n在 browser 视图中统统删掉\n接着进入刚刚的 repo 文件夹\n$ cd flutter_module_example/build/host/outputs/repo/com/example/flutter_module_example/flutter_release/1.0\n根据 可以使用 mvn deploy:deploy-file 命令来上传\n$ mvn deploy:deploy-file -DpomFile=flutter_release-1.0.pom -Dfile=flutter_release-1.0.aar -Durl=http://localhost:9000/repository/maven-releases/\n这里我得到了一个错误, 错误原因呢是认证失败, 也就是说没权限, 这是肯定的, 因为一个 maven 私服你能看就不错了, 没权限还想上传怕是想太多, 万一你给人挂个马怎么办?\n所以我们需要配置权限\n眼尖的同学可能发现了, 有一个 标签告诉我们如何配置权限\n点开一看, 有 3 种方式:\n配置 http 代理, 然后在代理里帮我们加上 basic 的请求头(这里就引申出一个, 可以用反代的方式, 你请求自己的某个 nginx/caddy, 然后由 nginx 帮你加 http 的 authentication 请求头, 但是这样做太复杂没必要) settings.xml 中针对仓库配置密码或私钥选项 配置 ssl 来连接 这里 ssl 比较复杂, 不适合 demo 演示, 如果你们公司有要求则根据你们公司的来\n我这里选用 settings.xml 来做, 并且为了演示方便, 我将 settings 放在项目文件夹下, 然后用mvn -s 参数引用配置文件, 这样的好处是对于系统的 mvn 配置没有侵入性, 当然你也可以按照官方的说法修改 m2 文件夹下的配置文件,这个请自行搜索如何做\n我的 maven 是 brew 安装的, 可以通过brew info maven来查看\n然后进入到\u0026lt;maven\u0026gt;/libexec/conf文件夹下, 复制 settings.xml 出来\n然后找到 servers 标签修改如下:\n1\u0026lt;servers\u0026gt; 2 \u0026lt;server\u0026gt; 3 \u0026lt;id\u0026gt;nexus\u0026lt;/id\u0026gt; 4 \u0026lt;username\u0026gt;admin\u0026lt;/username\u0026gt; 5 \u0026lt;password\u0026gt;admin\u0026lt;/password\u0026gt; 6 \u0026lt;/server\u0026gt; 7\u0026lt;servers\u0026gt; 用户名,密码换成你的\n1mvn deploy:deploy-file \\ 2-DpomFile=\u0026#34;build/host/outputs/repo/com/example/flutter_module_example/flutter_release/1.0/flutter_release-1.0.pom\u0026#34; \\ 3-DgeneratePom=false \\ 4-Dfile=\u0026#34;build/host/outputs/repo/com/example/flutter_module_example/flutter_release/1.0/flutter_release-1.0.aar\u0026#34; \\ 5-Durl=\u0026#34;http://localhost:9000/repository/maven-releases\u0026#34; \\ 6-DrepositoryId=\u0026#34;nexus\u0026#34; \\ 7-Dpackaging=aar \\ 8-s=\u0026#34;mvn-settings.xml\u0026#34; 这样就可以提交成功了\n但是这样会发现一个问题, flutter 打包出来的版本号永远是 1.0, 而 flutter 在稍后的版本提供了参数可以在 build aar 的时候修改版本号, 而对于目前应用广泛的 stable 版(1.12.13+hotfix.7)来说, 并没有这个功能\n所以, 我们需要在上传前修改 pom 文件, 将版本号根据某个规律提升或指定, 而这个是可以自动化完成的事情, 因为 pom 实质上就是 xml 文件, 而 xml 的解析对于大部分语言来说都是有三方库可以完成的\n整理思路 自动化部署需要完成如下的步骤\nflutter build aar 找到所有的 aar 文件对应的 pom 文件, 使用 xml 解析并将版本号修改, 同时修改依赖对应的版本号 上传 aar 和 pom 修改 android 端的依赖到最新的 flutter 版本号 编写脚本 思路有了, 我们编写工具完成这个步骤就可以了, 这里我使用 dart 来完成, 因为 dart 是 flutter 的开发语言, 对于 flutter 开发来说上手难度较低, 当然也可以用 python/go 等任何你熟悉的语言来完成\n1import \u0026#39;dart:convert\u0026#39;; 2import \u0026#39;dart:io\u0026#39;; 3import \u0026#39;package:xml/xml.dart\u0026#39; as xml; 4 5const targetVersion = \u0026#34;1.0.4\u0026#34;; 6 7class DeployObject { 8 File pomFile; 9 File aarFile; 10} 11 12void main() { 13 List\u0026lt;File\u0026gt; aarFiles = []; 14 List\u0026lt;String\u0026gt; needChangeList = []; 15 List\u0026lt;DeployObject\u0026gt; deploys = []; 16 17 final dir = Directory(\u0026#34;build/host/outputs/repo\u0026#34;); 18 19 // 扫描aar 20 for (final file in dir.listSync(recursive: true)) { 21 if (file.path.endsWith(\u0026#34;.aar\u0026#34;)) { 22 aarFiles.add(file); // aar文件 23 needChangeList.add( 24 file.uri.pathSegments[file.uri.pathSegments.length - 3], 25 ); // 库的名称, 为了简单, 我只扫描了项目名称, 没有扫描组名, 如果你不幸有重名, 需要自己增加对于包名的处理 26 } 27 } 28 29 for (final aar in aarFiles) { 30 final pomFile = handlePom(needChangeList, aar); // 处理pom文件 31 deploys.add(DeployObject() 32 ..aarFile = aar 33 ..pomFile = pomFile); 34 } 35 36 for (final deploy in deploys) { 37 deployPkt(deploy); 38 } 39} 40 41File handlePom(List\u0026lt;String\u0026gt; needChangeVersionList, File aarFile) { 42 final pomPath = aarFile.path.substring(0, aarFile.path.length - 3) + \u0026#39;pom\u0026#39;; 43 44 final file = File(pomPath); 45 46 final doc = xml.parse(file.readAsStringSync()); 47 48 { 49 // 修改自身的版本号 50 final xml.XmlText versionNode = 51 doc.findAllElements(\u0026#34;version\u0026#34;).first.firstChild; 52 versionNode.text = targetVersion; 53 54 // 这里添加大括号只是为了看的清楚, 实际可不加 55 } 56 57 final elements = doc.findAllElements(\u0026#34;dependency\u0026#34;); 58 for (final element in elements) { 59 final artifactId = element.findElements(\u0026#34;artifactId\u0026#34;).first.text; 60 if (needChangeVersionList.contains(artifactId)) { 61 final xml.XmlText versionNode = 62 element.findElements(\u0026#34;version\u0026#34;).first.firstChild; 63 versionNode.text = targetVersion; // 修改依赖的版本号 64 } 65 } 66 67 final buffer = StringBuffer(); 68 69 doc.writePrettyTo(buffer, 0, \u0026#34; \u0026#34;); 70 print(buffer); 71 72 return file..writeAsStringSync(buffer.toString()); 73} 74 75Future\u0026lt;void\u0026gt; deployPkt(DeployObject deploy) async { 76 final configPath = File(\u0026#39;mvn-settings.xml\u0026#39;).absolute.path; 77 List\u0026lt;String\u0026gt; args = [ 78 \u0026#39;deploy:deploy-file\u0026#39;, 79 \u0026#39;-DpomFile=\u0026#34;${deploy.pomFile.absolute.path}\u0026#34;\u0026#39;, 80 \u0026#39;-DgeneratePom=false\u0026#39;, 81 \u0026#39;-Dfile=\u0026#34;${deploy.aarFile.absolute.path}\u0026#34;\u0026#39;, 82 \u0026#39;-Durl=\u0026#34;http://localhost:9000/repository/maven-releases\u0026#34;\u0026#39;, 83 \u0026#39;-DrepositoryId=\u0026#34;nexus\u0026#34;\u0026#39;, 84 \u0026#39;-Dpackaging=aar\u0026#39;, 85 \u0026#39;-s=\u0026#34;$configPath\u0026#34;\u0026#39;, 86 ]; 87 final shell = \u0026#34;mvn ${args.join(\u0026#39; \\\\\\n \u0026#39;)}\u0026#34;; 88 final f = File( 89 \u0026#34;${Directory.systemTemp.path}/${DateTime.now().millisecondsSinceEpoch}.sh\u0026#34;); 90 f.writeAsStringSync(shell); 91 final process = await Process.start(\u0026#39;bash\u0026#39;, [f.path]); 92 final output = await utf8.decodeStream(process.stdout); 93 print(output); 94 final exitCode = await process.exitCode; 95 if (exitCode != 0) { 96 exit(exitCode); 97 } 98} 完整版的脚本在这里 只保证有 bash 环境可用, 因为是用 bash 来执行的, window 可能需要根据你的环境有所修改\n然后, 每次都会创建 n 个临时的 sh 文件用于上传\n我这里执行一下: $ dart bin/main.dart\n能看到一堆的执行成功\n然后我们查看 nexus 的 web 端, 我们能看到 1.0.4 在 maven 私服上已经有了\n点右边的 pom 文件的连接看看内容\n自身是 1.0.4 版本, 依赖的 path_provider 也是, 但 io.flutter 的引擎体系还是应该的版本号\n宿主项目的修改 接着就是修改宿主项目的依赖了, 我们最早的时候用的是 1.0 版本\n我们添加依赖\nimplementation 'com.example.flutter_module_example:flutter_release:1.0.4'\n然后 gradle sync, 等待一会儿就能同步成功了\n这样以后我们 flutter 开发人员就可以直接对安卓组说, 我更新了一个开发版, 1.0.5-dev1, 你试试能不能跑, 交互有没有问题之类的\n修改代码打开 flutter 的页面 这里就是修改 MainActivity 了\n修改布局文件: activity_main.xml\n修改下右边的 text 属性\n修改 java 文件\n1package top.kikt.flutterhost; 2 3import androidx.appcompat.app.AppCompatActivity; 4 5import android.content.Intent; 6import android.os.Bundle; 7import android.os.Handler; 8import android.os.Looper; 9import android.view.View; 10 11import io.flutter.app.FlutterActivity; 12import io.flutter.embedding.engine.FlutterEngine; 13import io.flutter.view.FlutterMain; 14 15public class MainActivity extends AppCompatActivity { 16 17 @Override 18 protected void onCreate(Bundle savedInstanceState) { 19 super.onCreate(savedInstanceState); 20 setContentView(R.layout.activity_main); 21 22 // 添加下面那段 23 findViewById(R.id.bt_to_flutter).setOnClickListener(new View.OnClickListener() { 24 @Override 25 public void onClick(View v) { 26 FlutterMain.startInitialization(getApplicationContext()); 27 FlutterMain.ensureInitializationComplete(getApplicationContext(), null); 28 Intent intent = new Intent(MainActivity.this, FlutterActivity.class); 29 startActivity(intent); 30 } 31 }); 32 } 33} 开启新页面的代码, 一点, 嗯.. crash 了\n没事, 我们查查日志\n哦, 原来是没添加 Activity 到 manifest 里, 好久没写安卓都忘了\n打开AndroidManifest.xml\n1\u0026lt;application\u0026gt; 2 \u0026lt;activity android:name=\u0026#34;io.flutter.app.FlutterActivity\u0026#34; /\u0026gt; 3\u0026lt;/application\u0026gt; 然后运行就可以跑起来了, 点下 Open flutter 按钮\n开启 flutter 页面的时候会黑屏一下, 这是因为这里需要加载 flutter 引擎, 提前加载引擎可以减少这种情况, 但无法根治, 请自行百度搜索解决方案\n这里是提前初始化的代码\n1package top.kikt.flutterhost; 2 3import androidx.appcompat.app.AppCompatActivity; 4 5import android.content.Intent; 6import android.os.Bundle; 7import android.os.Handler; 8import android.os.Looper; 9import android.view.View; 10 11import io.flutter.app.FlutterActivity; 12import io.flutter.embedding.engine.FlutterEngine; 13import io.flutter.view.FlutterMain; 14 15public class MainActivity extends AppCompatActivity { 16 17 boolean flutterInited = false; 18 19 @Override 20 protected void onCreate(Bundle savedInstanceState) { 21 super.onCreate(savedInstanceState); 22 setContentView(R.layout.activity_main); 23 24 findViewById(R.id.bt_to_flutter).setOnClickListener(new View.OnClickListener() { 25 @Override 26 public void onClick(View v) { 27 if (!flutterInited) { 28 FlutterMain.startInitialization(getApplicationContext()); 29 FlutterMain.ensureInitializationComplete(getApplicationContext(), null); 30 } 31 Intent intent = new Intent(MainActivity.this, FlutterActivity.class); 32 startActivity(intent); 33 } 34 }); 35 36 initFlutterEngine(); 37 } 38 39 void initFlutterEngine() { 40 FlutterMain.startInitialization(getApplicationContext()); 41 FlutterMain.ensureInitializationCompleteAsync(getApplicationContext(), null, new Handler(), new Runnable() { 42 @Override 43 public void run() { 44 flutterInited = true; 45 } 46 }); 47 } 48} 这里如果有用模拟器的朋友可能会遇到没找到 so 的 crash, 这是因为 x86 引擎没有 release 的 so 的原因, 而我们是单独引用 release 的原因\n我们按照官方的方案添加如下配置在 app 的 build.gradle 里\n1android{ 2 buildTypes { 3 profile { 4 initWith debug 5 } 6 } 7} 8 9dependencies{ 10 def flutterModuleVersion = \u0026#39;1.0.4\u0026#39; 11 debugImplementation \u0026#34;com.example.flutter_module_example:flutter_debug:$flutterModuleVersion\u0026#34; 12 profileImplementation \u0026#34;com.example.flutter_module_example:flutter_profile:$flutterModuleVersion\u0026#34; 13 releaseImplementation \u0026#34;com.example.flutter_module_example:flutter_release:$flutterModuleVersion\u0026#34; 14} 这样就可以了\n后记 本篇完成了打包 aar 并上传 maven 的全过程\n有问题请在下留言, 其他地方的留言不保证能看到\n以上\n","link":"https://kikt.top/posts/flutter/exists/upload-aar-to-maven/","section":"posts","tags":["flutter","maven","aar"],"title":"Flutter 1.12后 上传aar至maven私服"},{"body":"","link":"https://kikt.top/tags/azure/","section":"tags","tags":null,"title":"azure"},{"body":"","link":"https://kikt.top/categories/other/","section":"categories","tags":null,"title":"other"},{"body":"前言 最近刚刚把图床迁移到 Azure, 因为 github 的图片不太好用,国内经常看不见\n然而吧, 那是正则批量扫描 markdown 文件, 然后下载文件, 直接使用 git 管理的, 几百张的时候倒是还可以接受\n但今后如果单张图片也需要这么做, 就很麻烦了, 以前是用 picGo 上传的图片\n虽然现在 picGO 支持自己写插件, 但是 js 不是我的强项, 所以想自己写一个试试看\nApi 分析 azure 有 Rest api 可以完成上传的步骤, 然而这个 api 需要一个 commitId, 不像 github 的 api 比较智能, 直接上传就行.\n但没关系, 我们可以通过两次接口访问得到它.\n使用 postman 来测试下\n访问 https://dev.azure.com/{{organization}}/{{project}}/_apis/git/repositories/{{repositoryId}}/pushes?api-version=5.0 得到一个结果\n然后访问这个 url 参数的接口可以获取 commitId\n也就是 git 的 commit hash 值\n这里把 oldObjectId 替换成刚刚拿到的 commitId, 其他的根据自己的情况替换, 比如 comment 是注释, path 是你要放到哪个目录和名字, content 是图片的 base64 值\napi 流程通了, 接下来就是技术的选择了\n技术选型 因为 dart 没有合适的 api 可以调用到剪切板, 所以我使用 swift 来完成这一步, 然后直接 base64 后输出到控制台\n接着使用 dart 进行\u0026quot;接力\u0026quot;, 把图片的 base64 格式的图片上传到 azure 即可\n至于为啥这么做, 我只能说, swift 不支持 async await 语法, 然后常用的 http 库都不支持同步访问, 我需要链式调用 3 个 api 真的是太麻烦了\n撸码 swift 部分 创建一个 swift 的 command line 工程(macOS 版)\nmain.swift:\n1// 2// main.swift 3// ReadClipboard 4// 5// Created by cjl on 2020/1/30. 6// Copyright © 2020 cjl. All rights reserved. 7// 8 9import Foundation 10import AppKit 11 12class UploadManager{ 13 14 let pasteboard = NSPasteboard.general 15 16 func uploadFirst(){ 17 if let data = pasteboard.data(forType: .fileURL){ 18 // 上传文件类型的 19 guard let fileUri = NSString(data: data , encoding: String.Encoding.utf8.rawValue) else{ 20 print(\u0026#34;虽然是文件类型, 但解析失败 : \\(data)\u0026#34;); 21 return 22 } 23 guard let url = URL(string: fileUri as String) else{ 24 print(\u0026#34;转为 URL 失败\u0026#34;) 25 return 26 } 27 print(\u0026#34;文件类型: \\(url)\u0026#34;) 28 guard let contentData = try? Data(contentsOf: url) else{ 29 print(\u0026#34;读取文件失败\u0026#34;) 30 return 31 } 32 print(\u0026#34;content count: \\(contentData.count)\u0026#34;) 33// let last = url.lastPathComponent 34 upload(data: contentData) 35 return 36 } 37 38 // 图片类型 39 if let data = pasteboard.data(forType: .png){ 40 print(\u0026#34;图片类型, 长度: \\(data.count)\u0026#34;) 41 upload(data: data) 42 return 43 } 44 45 // 文件内容类型 46 if let data = pasteboard.data(forType: .fileContents){ 47 print(\u0026#34;文件内容类型\u0026#34;) 48 upload(data: data) 49 return 50 } 51 52 print(\u0026#34;其他类型 : \\(String(describing: pasteboard.pasteboardItems?.first?.types))\u0026#34;) 53 54 exit(-1) 55 } 56 57 func upload(data:Data){ 58 let b64s = data.base64EncodedString() 59 print(\u0026#34;base64:\\(b64s)\u0026#34;) 60 } 61} 62 63let manager = UploadManager() 64manager.uploadFirst() 这里就是获取剪切板, 只导出文件或图片类型, 然后转为 base64, 接着拼接 base64: 然后输出下\n之所以拼接是因为这样可以在 dart 端根据开头字符串来过滤其他日志信息,以便于\u0026quot;接力\u0026quot;\ndart 部分 核心代码如下:\n1import \u0026#39;dart:convert\u0026#39;; 2import \u0026#39;dart:io\u0026#39;; 3 4import \u0026#39;package:http/io_client.dart\u0026#39;; 5import \u0026#39;package:upload_image/src/uploader.dart\u0026#39;; 6import \u0026#39;package:http/http.dart\u0026#39; as http; 7 8class AzureUploader with Uploader { 9 String org; 10 String project; 11 String repo; 12 String username; 13 String password; 14 15 String get url =\u0026gt; 16 \u0026#39;https://dev.azure.com/$org/$project/_apis/git/repositories/$repo/pushes?api-version=5.0\u0026#39;; 17 18 @override 19 void initConfig(Map\u0026lt;String, dynamic\u0026gt; configs) { 20 org = configs[\u0026#39;org\u0026#39;]; 21 project = configs[\u0026#39;project\u0026#39;]; 22 repo = configs[\u0026#39;repo\u0026#39;]; 23 username = configs[\u0026#39;user\u0026#39;]; 24 password = configs[\u0026#39;token\u0026#39;]; 25 } 26 27 @override 28 Future\u0026lt;String\u0026gt; upload(String imageContent) async { 29 final lastCommitId = await _getLastCommitId(); 30 print(\u0026#39;lastCommitId = $lastCommitId\u0026#39;); 31 return _upload(imageContent, lastCommitId); 32 } 33 34 Future\u0026lt;String\u0026gt; _getLastCommitId() async { 35 final response = await http.get(url); 36 final map = json.decode(response.body); 37 final commitResponse = await http.get(map[\u0026#39;value\u0026#39;][0][\u0026#39;url\u0026#39;]); 38 return json.decode(commitResponse.body)[\u0026#39;commits\u0026#39;][0][\u0026#39;commitId\u0026#39;]; 39 } 40 41 Future\u0026lt;String\u0026gt; _upload(String imageContent, String lastCommitId) async { 42 final token = base64.encode(ascii.encode(\u0026#39;$username:$password\u0026#39;)); 43 final now = DateTime.now(); 44 final dt = now.toLocal().toString(); 45 final ms = now.millisecondsSinceEpoch; 46 47 final pathName = \u0026#39;$ms.png\u0026#39;; 48 49 final body = { 50 \u0026#39;refUpdates\u0026#39;: [ 51 { 52 \u0026#39;name\u0026#39;: \u0026#39;refs/heads/master\u0026#39;, 53 \u0026#39;oldObjectId\u0026#39;: lastCommitId, 54 }, 55 ], 56 \u0026#39;commits\u0026#39;: [ 57 { 58 \u0026#39;comment\u0026#39;: \u0026#39;add image at $dt\u0026#39;, 59 \u0026#39;changes\u0026#39;: [ 60 { 61 \u0026#39;changeType\u0026#39;: \u0026#39;add\u0026#39;, 62 \u0026#39;item\u0026#39;: { 63 \u0026#39;path\u0026#39;: pathName, 64 }, 65 \u0026#39;newContent\u0026#39;: { 66 \u0026#39;content\u0026#39;: imageContent, 67 \u0026#39;contentType\u0026#39;: \u0026#39;base64Encoded\u0026#39;, 68 } 69 } 70 ], 71 } 72 ], 73 }; 74 75 final httpClient = HttpClient(); 76 // httpClient.findProxy = (proxy) { 77 // return \u0026#39;PROXY localhost:8888\u0026#39;; 78 // }; 79 80 final client = IOClient(httpClient); 81 82 final response = await client.post( 83 url, 84 headers: { 85 \u0026#39;Authorization\u0026#39;: \u0026#39;Basic $token\u0026#39;, 86 \u0026#39;Content-Type\u0026#39;: \u0026#39;application/json\u0026#39;, 87 }, 88 body: json.encode(body), 89 ); 90 91 final commitResult = json.decode(response.body); 92 93 final repoUrl = commitResult[\u0026#39;repository\u0026#39;][\u0026#39;url\u0026#39;]; 94 95 final itemUrl = 96 \u0026#39;$repoUrl/items?path=%2F${pathName}\u0026amp;versionDescriptor%5BversionOptions%5D=0\u0026amp;versionDescriptor%5BversionType%5D=0\u0026amp;versionDescriptor%5Bversion%5D=master\u0026amp;resolveLfs=true\u0026amp;%24format=octetStream\u0026amp;api-version=5.0\u0026amp;download=true\u0026#39;; 97 98 return itemUrl; 99 } 100} 简单来说, 就是从 config 中读取出用户名,密码(token),工程名,仓库名几个属性, 然后完成 api 的调用, 接着使用 azure 图片的拼接方法来完成图片的上传\n最后解析下, 获取到仓库的 url, 拼接 pathName 就可以获取到文件了\n最后一步, 使用一个三方库, 把完成的图片 url 自动复制到剪切板\n后记 本篇的图片就是用这个方法弄的, 不过还是挺麻烦的, 所以后面我还是会做一个 picGo 的插件来完成这些步骤\n更新: 开发完成\n","link":"https://kikt.top/posts/other/upload-image-to-azure/","section":"posts","tags":["图床","azure"],"title":"上传图片到Azure"},{"body":"","link":"https://kikt.top/tags/%E5%9B%BE%E5%BA%8A/","section":"tags","tags":null,"title":"图床"},{"body":" 前言 ijkplayer 的 ffmpeg 是旧版本的, ndk 也是旧的, 程序员爱折腾, 所以想用最新的 ndk 编译最新的 ffmpeg, 当前就是 ndk20+ffmpeg4.2.2 了\n第一步自然是搜索有没有现成的, 运气不错, 找到了大佬的示例\n本篇参考了 的内容, 但因为我是 macOS, 所以进行了一些修改 包括有的东西设置后发现没生效, 在实际打包的时候会报类似下面的这种错误\n1ld: warning: building for macOS, but linking in object file (libswresample/libswresample.a(resample.o)) built for free standing 所以我根据实际的报错内容进行了修改\n编译脚本 这里只需要修改你的 NDK 为你本地的 NDK 目录即可\n最新的代码在这里: gist.github.com 需要自备梯子\n1#!/bin/bash 2 3NDK=/Volumes/Evo512/sdk/android-ndk-r20 4TOOLCHAIN=$NDK/toolchains/llvm/prebuilt/darwin-x86_64 5API=21 6 7function build_android 8{ 9echo \u0026#34;Compiling FFmpeg for $CPU\u0026#34; 10./configure \\ 11 --prefix=$PREFIX \\ 12 --libdir=$LIB_DIR \\ 13 --enable-shared \\ 14 --disable-static \\ 15 --enable-jni \\ 16 --disable-doc \\ 17 --disable-symver \\ 18 --disable-programs \\ 19 --target-os=android \\ 20 --arch=$ARCH \\ 21 --cpu=$CPU \\ 22 --cc=$CC \\ 23 --cxx=$CXX \\ 24 --enable-cross-compile \\ 25 --sysroot=$SYSROOT \\ 26 --extra-cflags=\u0026#34;-Os -fpic $OPTIMIZE_CFLAGS\u0026#34; \\ 27 --extra-ldflags=\u0026#34;$ADDI_LDFLAGS\u0026#34; \\ 28 --disable-asm \\ 29 $COMMON_FF_CFG_FLAGS 30make clean 31make -j8 32make install 33echo \u0026#34;The Compilation of FFmpeg for $CPU is completed\u0026#34; 34} 35 36# # armv8-a 37# source \u0026#34;config-env.sh\u0026#34; 38# OUTPUT_FOLDER=\u0026#34;arm64-v8a\u0026#34; 39# ARCH=arm64 40# CPU=\u0026#34;armv8-a\u0026#34; 41# TOOL_CPU_NAME=aarch64 42# TOOL_PREFIX=\u0026#34;$TOOLCHAIN/bin/$TOOL_CPU_NAME-linux-android\u0026#34; 43 44# CC=\u0026#34;$TOOL_PREFIX$API-clang\u0026#34; 45# CXX=\u0026#34;$TOOL_PREFIX$API-clang++\u0026#34; 46# SYSROOT=\u0026#34;$NDK/toolchains/llvm/prebuilt/darwin-x86_64/sysroot\u0026#34; 47# PREFIX=\u0026#34;${PWD}/android/$OUTPUT_FOLDER\u0026#34; 48# LIB_DIR=\u0026#34;${PWD}/android/libs/$OUTPUT_FOLDER\u0026#34; 49# OPTIMIZE_CFLAGS=\u0026#34;-march=$CPU\u0026#34; 50# build_android 51 52# # armv7-a 53# source \u0026#34;config-env.sh\u0026#34; 54# OUTPUT_FOLDER=\u0026#34;armeabi-v7a\u0026#34; 55# ARCH=\u0026#34;arm\u0026#34; 56# CPU=\u0026#34;armv7-a\u0026#34; 57# TOOL_CPU_NAME=armv7a 58# TOOL_PREFIX=\u0026#34;$TOOLCHAIN/bin/arm-linux-androideabi\u0026#34; 59 60# CC=\u0026#34;$TOOLCHAIN/bin/armv7a-linux-androideabi$API-clang\u0026#34; 61# CXX=\u0026#34;$TOOLCHAIN/bin/armv7a-linux-androideabi$API-clang++\u0026#34; 62# SYSROOT=\u0026#34;$NDK/toolchains/llvm/prebuilt/darwin-x86_64/sysroot\u0026#34; 63# PREFIX=\u0026#34;${PWD}/android/$OUTPUT_FOLDER\u0026#34; 64# LIB_DIR=\u0026#34;${PWD}/android/libs/$OUTPUT_FOLDER\u0026#34; 65# OPTIMIZE_CFLAGS=\u0026#34;-march=$CPU\u0026#34; 66# build_android 67 68# x86 69source \u0026#34;config-env.sh\u0026#34; 70OUTPUT_FOLDER=\u0026#34;x86\u0026#34; 71ARCH=\u0026#34;x86\u0026#34; 72CPU=\u0026#34;x86\u0026#34; 73TOOL_CPU_NAME=\u0026#34;i686\u0026#34; 74TOOL_PREFIX=\u0026#34;$TOOLCHAIN/bin/${TOOL_CPU_NAME}-linux-android\u0026#34; 75 76CC=\u0026#34;$TOOL_PREFIX$API-clang\u0026#34; 77CXX=\u0026#34;$TOOL_PREFIX$API-clang++\u0026#34; 78SYSROOT=\u0026#34;$NDK/toolchains/llvm/prebuilt/darwin-x86_64/sysroot\u0026#34; 79PREFIX=\u0026#34;${PWD}/android/$OUTPUT_FOLDER\u0026#34; 80LIB_DIR=\u0026#34;${PWD}/android/libs/$OUTPUT_FOLDER\u0026#34; 81OPTIMIZE_CFLAGS=\u0026#34;-march=i686 -mtune=intel -mssse3 -mfpmath=sse -m32\u0026#34; 82build_android 83 84# x86_64 85# source \u0026#34;config-env.sh\u0026#34; 86# OUTPUT_FOLDER=\u0026#34;x86_64\u0026#34; 87# ARCH=\u0026#34;x86_64\u0026#34; 88# CPU=\u0026#34;x86-64\u0026#34; 89# TOOL_CPU_NAME=\u0026#34;x86_64\u0026#34; 90# TOOL_PREFIX=\u0026#34;$TOOLCHAIN/bin/${TOOL_CPU_NAME}-linux-android\u0026#34; 91 92# CC=\u0026#34;$TOOL_PREFIX$API-clang\u0026#34; 93# CXX=\u0026#34;$TOOL_PREFIX$API-clang++\u0026#34; 94# SYSROOT=\u0026#34;$NDK/toolchains/llvm/prebuilt/darwin-x86_64/sysroot\u0026#34; 95# PREFIX=\u0026#34;${PWD}/android/$OUTPUT_FOLDER\u0026#34; 96# LIB_DIR=\u0026#34;${PWD}/android/libs/$OUTPUT_FOLDER\u0026#34; 97# OPTIMIZE_CFLAGS=\u0026#34;-march=$CPU\u0026#34; 98# build_android 根据自己需要的 cpu, 放开对应的注释即可\nconfig-env.sh\n这个环境是 ijkplayer 的 ffmpeg 配置\n1#! /usr/bin/env bash 2 3# shell/config.sh 4# 这个来自ijkplayer的ffmpeg配置, 会在上面的build脚本中被引入 5 6#-------------------- 7# Standard options: 8export COMMON_FF_CFG_FLAGS= 9# export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --prefix=PREFIX\u0026#34; 10 11# Licensing options: 12export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --disable-gpl\u0026#34; 13# export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --enable-version3\u0026#34; 14export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --disable-nonfree\u0026#34; 15 16# Configuration options: 17# export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --disable-static\u0026#34; 18# export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --enable-shared\u0026#34; 19# export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --enable-small\u0026#34; 20export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --enable-runtime-cpudetect\u0026#34; 21export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --disable-gray\u0026#34; 22export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --disable-swscale-alpha\u0026#34; 23 24# Program options: 25export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --disable-programs\u0026#34; 26export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --disable-ffmpeg\u0026#34; 27export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --disable-ffplay\u0026#34; 28export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --disable-ffprobe\u0026#34; 29# export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --disable-ffserver\u0026#34; 30 31# Documentation options: 32export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --disable-doc\u0026#34; 33export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --disable-htmlpages\u0026#34; 34export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --disable-manpages\u0026#34; 35export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --disable-podpages\u0026#34; 36export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --disable-txtpages\u0026#34; 37 38# Component options: 39export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --disable-avdevice\u0026#34; 40export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --enable-avcodec\u0026#34; 41export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --enable-avformat\u0026#34; 42export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --enable-avutil\u0026#34; 43export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --enable-swresample\u0026#34; 44export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --enable-swscale\u0026#34; 45export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --disable-postproc\u0026#34; 46export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --enable-avfilter\u0026#34; 47export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --disable-avresample\u0026#34; 48# export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --disable-pthreads\u0026#34; 49# export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --disable-w32threads\u0026#34; 50# export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --disable-os2threads\u0026#34; 51export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --enable-network\u0026#34; 52# export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --disable-dct\u0026#34; 53# export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --disable-dwt\u0026#34; 54# export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --disable-lsp\u0026#34; 55# export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --disable-lzo\u0026#34; 56# export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --disable-mdct\u0026#34; 57# export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --disable-rdft\u0026#34; 58# export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --disable-fft\u0026#34; 59 60# Hardware accelerators: 61export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --disable-d3d11va\u0026#34; 62export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --disable-dxva2\u0026#34; 63export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --disable-vaapi\u0026#34; 64# export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --disable-vda\u0026#34; 65export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --disable-vdpau\u0026#34; 66export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --disable-videotoolbox\u0026#34; 67 68# Individual component options: 69# export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --disable-everything\u0026#34; 70export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --disable-encoders\u0026#34; 71export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --enable-encoder=png\u0026#34; 72 73# ./configure --list-decoders 74export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --disable-decoders\u0026#34; 75export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --enable-decoder=aac\u0026#34; 76export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --enable-decoder=aac_latm\u0026#34; 77export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --enable-decoder=flv\u0026#34; 78export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --enable-decoder=h264\u0026#34; 79export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --enable-decoder=mp3*\u0026#34; 80export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --enable-decoder=vp6f\u0026#34; 81export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --enable-decoder=flac\u0026#34; 82export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --enable-decoder=hevc\u0026#34; 83export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --enable-decoder=vp8\u0026#34; 84export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --enable-decoder=vp9\u0026#34; 85export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --enable-decoder=h263\u0026#34; 86export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --enable-decoder=h263i\u0026#34; 87export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --enable-decoder=h263p\u0026#34; 88export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --enable-decoder=mpeg4\u0026#34; 89export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --enable-decoder=mjpeg\u0026#34; 90 91export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --disable-hwaccels\u0026#34; 92 93# ./configure --list-muxers 94export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --disable-muxers\u0026#34; 95export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --enable-muxer=mp4\u0026#34; 96 97# ./configure --list-demuxers 98export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --disable-demuxers\u0026#34; 99export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --enable-demuxer=aac\u0026#34; 100export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --enable-demuxer=concat\u0026#34; 101export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --enable-demuxer=data\u0026#34; 102export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --enable-demuxer=flv\u0026#34; 103export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --enable-demuxer=hls\u0026#34; 104export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --enable-demuxer=live_flv\u0026#34; 105export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --enable-demuxer=mov\u0026#34; 106export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --enable-demuxer=mp3\u0026#34; 107export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --enable-demuxer=mpegps\u0026#34; 108export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --enable-demuxer=mpegts\u0026#34; 109export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --enable-demuxer=mpegvideo\u0026#34; 110export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --enable-demuxer=flac\u0026#34; 111export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --enable-demuxer=hevc\u0026#34; 112export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --enable-demuxer=webm_dash_manifest\u0026#34; 113export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --enable-demuxer=mpeg4\u0026#34; 114export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --enable-demuxer=rtsp\u0026#34; 115export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --enable-demuxer=mjpeg\u0026#34; 116export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --enable-demuxer=avi\u0026#34; 117 118# ./configure --list-parsers 119export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --disable-parsers\u0026#34; 120export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --enable-parser=aac\u0026#34; 121export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --enable-parser=aac_latm\u0026#34; 122export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --enable-parser=h264\u0026#34; 123export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --enable-parser=flac\u0026#34; 124export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --enable-parser=hevc\u0026#34; 125export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --enable-parser=mpeg4\u0026#34; 126export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --enable-parser=mpeg4video\u0026#34; 127export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --enable-parser=mpegvideo\u0026#34; 128 129# ./configure --list-bsf 130export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --enable-bsfs\u0026#34; 131export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --disable-bsf=chomp\u0026#34; 132export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --disable-bsf=dca_core\u0026#34; 133export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --disable-bsf=dump_extradata\u0026#34; 134export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --disable-bsf=hevc_mp4toannexb\u0026#34; 135export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --disable-bsf=imx_dump_header\u0026#34; 136export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --disable-bsf=mjpeg2jpeg\u0026#34; 137export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --disable-bsf=mjpega_dump_header\u0026#34; 138export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --disable-bsf=mov2textsub\u0026#34; 139export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --disable-bsf=mp3_header_decompress\u0026#34; 140export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --disable-bsf=mpeg4_unpack_bframes\u0026#34; 141export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --disable-bsf=noise\u0026#34; 142export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --disable-bsf=remove_extradata\u0026#34; 143export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --disable-bsf=text2movsub\u0026#34; 144export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --disable-bsf=vp9_superframe\u0026#34; 145 146# ./configure --list-protocols 147export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --enable-protocols\u0026#34; 148export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --enable-protocol=async\u0026#34; 149export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --disable-protocol=bluray\u0026#34; 150export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --enable-protocol=concat\u0026#34; 151export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --enable-protocol=crypto\u0026#34; 152export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --disable-protocol=ffrtmpcrypt\u0026#34; 153export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --enable-protocol=ffrtmphttp\u0026#34; 154export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --disable-protocol=gopher\u0026#34; 155export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --disable-protocol=icecast\u0026#34; 156export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --disable-protocol=librtmp*\u0026#34; 157export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --disable-protocol=libssh\u0026#34; 158export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --disable-protocol=md5\u0026#34; 159export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --disable-protocol=mmsh\u0026#34; 160export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --disable-protocol=mmst\u0026#34; 161export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --disable-protocol=rtmp*\u0026#34; 162export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --enable-protocol=rtmp\u0026#34; 163export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --enable-protocol=rtmpt\u0026#34; 164export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --enable-protocol=rtp\u0026#34; 165export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --enable-protocol=sctp\u0026#34; 166export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --enable-protocol=srtp\u0026#34; 167export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --disable-protocol=subfile\u0026#34; 168export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --disable-protocol=unix\u0026#34; 169 170# 171export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --disable-devices\u0026#34; 172export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --disable-filters\u0026#34; 173 174# External library support: 175export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --disable-iconv\u0026#34; 176export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --disable-audiotoolbox\u0026#34; 177export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --disable-videotoolbox\u0026#34; 178 179# ... 180 181# Advanced options (experts only): 182# export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --cross-prefix=${FF_CROSS_PREFIX}-\u0026#34; 183# export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --enable-cross-compile\u0026#34; 184# export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --sysroot=PATH\u0026#34; 185# export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --sysinclude=PATH\u0026#34; 186# export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --target-os=TAGET_OS\u0026#34; 187# export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --target-exec=CMD\u0026#34; 188# export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --target-path=DIR\u0026#34; 189# export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --toolchain=NAME\u0026#34; 190# export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --nm=NM\u0026#34; 191# export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --ar=AR\u0026#34; 192# export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --as=AS\u0026#34; 193# export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --yasmexe=EXE\u0026#34; 194# export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --cc=CC\u0026#34; 195# export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --cxx=CXX\u0026#34; 196# export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --dep-cc=DEPCC\u0026#34; 197# export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --ld=LD\u0026#34; 198# export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --host-cc=HOSTCC\u0026#34; 199# export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --host-cflags=HCFLAGS\u0026#34; 200# export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --host-cppflags=HCPPFLAGS\u0026#34; 201# export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --host-ld=HOSTLD\u0026#34; 202# export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --host-ldflags=HLDFLAGS\u0026#34; 203# export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --host-libs=HLIBS\u0026#34; 204# export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --host-os=OS\u0026#34; 205# export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --extra-cflags=ECFLAGS\u0026#34; 206# export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --extra-cxxflags=ECFLAGS\u0026#34; 207# export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --extra-ldflags=ELDFLAGS\u0026#34; 208# export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --extra-libs=ELIBS\u0026#34; 209# export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --extra-version=STRING\u0026#34; 210# export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --optflags=OPTFLAGS\u0026#34; 211# export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --build-suffix=SUFFIX\u0026#34; 212# export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --malloc-prefix=PREFIX\u0026#34; 213# export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --progs-suffix=SUFFIX\u0026#34; 214# export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --arch=ARCH\u0026#34; 215# export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --cpu=CPU\u0026#34; 216# export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --enable-pic\u0026#34; 217# export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --enable-sram\u0026#34; 218# export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --enable-thumb\u0026#34; 219# export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --disable-symver\u0026#34; 220# export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --enable-hardcoded-tables\u0026#34; 221# export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --disable-safe-bitstream-reader\u0026#34; 222# export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --enable-memalign-hack\u0026#34; 223# export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --enable-lto\u0026#34; 224 225# Optimization options (experts only): 226# export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --enable-asm\u0026#34; 227# export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --disable-altivec\u0026#34; 228# export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --disable-amd3dnow\u0026#34; 229# export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --disable-amd3dnowext\u0026#34; 230# export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --disable-mmx\u0026#34; 231# export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --disable-mmxext\u0026#34; 232# export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --disable-sse\u0026#34; 233# export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --disable-sse2\u0026#34; 234# export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --disable-sse3\u0026#34; 235# export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --disable-ssse3\u0026#34; 236# export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --disable-sse4\u0026#34; 237# export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --disable-sse42\u0026#34; 238# export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --disable-avx\u0026#34; 239# export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --disable-fma4\u0026#34; 240# export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --disable-armv5te\u0026#34; 241# export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --disable-armv6\u0026#34; 242# export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --disable-armv6t2\u0026#34; 243# export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --disable-vfp\u0026#34; 244# export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --disable-neon\u0026#34; 245# export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --disable-vis\u0026#34; 246# export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --enable-inline-asm\u0026#34; 247# export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --disable-yasm\u0026#34; 248# export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --disable-mips32r2\u0026#34; 249# export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --disable-mipsdspr1\u0026#34; 250# export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --disable-mipsdspr2\u0026#34; 251# export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --disable-mipsfpu\u0026#34; 252# export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --disable-fast-unaligned\u0026#34; 253 254# Developer options (useful when working on FFmpeg itself): 255# export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --enable-coverage\u0026#34; 256# export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --disable-debug\u0026#34; 257# export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --enable-debug=LEVEL\u0026#34; 258# export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --disable-optimizations\u0026#34; 259# export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --enable-extra-warnings\u0026#34; 260# export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --disable-stripping\u0026#34; 261# export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --assert-level=level\u0026#34; 262# export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --enable-memory-poisoning\u0026#34; 263# export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --valgrind=VALGRIND\u0026#34; 264# export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --enable-ftrapv\u0026#34; 265# export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --samples=PATH\u0026#34; 266# export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --enable-xmm-clobber-test\u0026#34; 267# export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --enable-random\u0026#34; 268# export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --disable-random\u0026#34; 269# export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --enable-random=LIST\u0026#34; 270# export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --disable-random=LIST\u0026#34; 271# export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --random-seed=VALUE\u0026#34; 272export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --disable-linux-perf\u0026#34; 273export COMMON_FF_CFG_FLAGS=\u0026#34;$COMMON_FF_CFG_FLAGS --disable-bzlib\u0026#34; 修改脚本的执行权限:\n$ chmod +x build_android.sh\n$ ./build_android.sh\n接着运行就可以了\npkg-config 是自动导出的内容, 不想要就删掉即可\nijkplayer 里的 ffmpeg 应该是打包成静态库, 然后通过合并等操作来变成一个 so 的, 这里就没拆开\nandroid 中引入 有动态库, 理论上就可以在项目里跑了, 我们试试自己引入这些 so 和代码, 然后通过项目调用一下\n复制文件到项目里 $ cp -r android/libs/* myproject/libs\n完整 gradle 配置如下:\n1apply plugin: \u0026#39;com.android.application\u0026#39; 2 3apply plugin: \u0026#39;kotlin-android\u0026#39; 4 5apply plugin: \u0026#39;kotlin-android-extensions\u0026#39; 6 7android { 8 compileSdkVersion 29 9 buildToolsVersion \u0026#34;29.0.2\u0026#34; 10 defaultConfig { 11 applicationId \u0026#34;top.kikt.ffmpeg_sdl_example\u0026#34; 12 minSdkVersion 21 13 targetSdkVersion 29 14 versionCode 1 15 versionName \u0026#34;1.0\u0026#34; 16 testInstrumentationRunner \u0026#34;androidx.test.runner.AndroidJUnitRunner\u0026#34; 17 externalNativeBuild { 18 cmake { 19 cppFlags \u0026#34;\u0026#34; // cpp编译时的参数配置 20 } 21 } 22 ndk { 23 abiFilters \u0026#39;arm64-v8a\u0026#39;, \u0026#39;armeabi-v7a\u0026#39;, \u0026#39;x86\u0026#39;, \u0026#39;x86_64\u0026#39; // cpu类型 24 } 25 } 26 buildTypes { 27 release { 28 minifyEnabled false 29 proguardFiles getDefaultProguardFile(\u0026#39;proguard-android-optimize.txt\u0026#39;), \u0026#39;proguard-rules.pro\u0026#39; 30 } 31 } 32 externalNativeBuild { 33 cmake { 34 path \u0026#34;src/main/cpp/CMakeLists.txt\u0026#34; // cmake 文件配置 35 version \u0026#34;3.10.2\u0026#34; 36 } 37 } 38 compileOptions { 39 sourceCompatibility = 1.8 40 targetCompatibility = 1.8 41 } 42 43 sourceSets { 44 main { 45 jniLibs.srcDirs = [\u0026#39;libs\u0026#39;] // so库的父目录指定 46 } 47 } 48} 49 50dependencies { 51 implementation fileTree(dir: \u0026#39;libs\u0026#39;, include: [\u0026#39;*.jar\u0026#39;]) 52 implementation \u0026#34;org.jetbrains.kotlin:kotlin-stdlib-jdk7:$kotlin_version\u0026#34; 53 implementation \u0026#39;androidx.appcompat:appcompat:1.1.0\u0026#39; 54 implementation \u0026#39;androidx.core:core-ktx:1.1.0\u0026#39; 55 implementation \u0026#39;androidx.constraintlayout:constraintlayout:1.1.3\u0026#39; 56 testImplementation \u0026#39;junit:junit:4.12\u0026#39; 57 androidTestImplementation \u0026#39;androidx.test.ext:junit:1.1.1\u0026#39; 58 androidTestImplementation \u0026#39;androidx.test.espresso:espresso-core:3.2.0\u0026#39; 59} 1cmake_minimum_required(VERSION 3.4.1) # cmake版本 2 3include_directories(include) 4 5add_library( 6 ffmpeg-bridge # 自己库的名称 7 8 SHARED # 库的类型, 静态/动态 9 10 ffmpeg-bridge.cpp) # 库的源码 11 12 13file(GLOB FFMPEG_LIBS ../../../libs/${CMAKE_ANDROID_ARCH_ABI}/*.so) # 这里是找到对应的CPU 14message(\u0026#34;ffmpeg libs : ${FFMPEG_LIBS}\u0026#34;) # app/.cxx/cmake/debug/arm64-v8a/build_output.txt 这里可以看到日志 15 16find_library( 17 log-lib 18 log) 19 20target_link_libraries( # Specifies the target library. 21 ffmpeg-bridge 22 ${log-lib} 23 ${FFMPEG_LIBS} 24 ) ffmpeg-bridge.cpp:\n1#include \u0026lt;jni.h\u0026gt; 2#include \u0026lt;string\u0026gt; 3#include \u0026lt;android/log.h\u0026gt; 4 5#ifdef __cplusplus 6#if __cplusplus 7extern \u0026#34;C\u0026#34; { 8#endif 9#endif 10#include \u0026lt;libavutil/avutil.h\u0026gt; 11#include \u0026lt;libavformat/avformat.h\u0026gt; 12#ifdef __cplusplus 13#if __cplusplus 14} 15#endif 16#endif 17 18extern \u0026#34;C\u0026#34; void logToAndroid(void *ptr, int level, const char *fmt, va_list vl) { 19 if (level == AV_LOG_INFO) { 20 __android_log_vprint(ANDROID_LOG_INFO, \u0026#34;ffmpeg\u0026#34;, fmt, vl); 21 } else if (level == AV_LOG_DEBUG) { 22 __android_log_vprint(ANDROID_LOG_DEBUG, \u0026#34;ffmpeg\u0026#34;, fmt, vl); 23 } 24} 25 26extern \u0026#34;C\u0026#34; JNIEXPORT jstring JNICALL 27Java_top_kikt_ffmpeg_1sdl_1example_MainActivity_stringFromJNI( 28 JNIEnv *env, 29 jobject /* this */) { 30 std::string hello = \u0026#34;Hello from C++\u0026#34;; 31 return env-\u0026gt;NewStringUTF(hello.c_str()); 32} 33 34extern \u0026#34;C\u0026#34; 35JNIEXPORT void JNICALL 36Java_top_kikt_ffmpeg_1sdl_1example_FFmpeg_dumpInfo(JNIEnv *env, jclass clazz, jstring url) { // 这个是映射的Java native方法, 具体的含义可以用搜索引擎搜javah相关的东西, 这里就不细说了 37 av_log_set_callback(logToAndroid); 38 AVFormatContext *context = nullptr; 39 40 const char *cUrl = (*env).GetStringUTFChars(url, nullptr); 41 42 avformat_open_input(\u0026amp;context, cUrl, nullptr, nullptr); 43 44 av_dump_format(context, -1, cUrl, 0); 45 46 if (context) { 47 avformat_close_input(\u0026amp;context); 48 } 49} 1package top.kikt.ffmpeg_sdl_example; 2 3public class FFmpeg { 4 5 static { 6 System.loadLibrary(\u0026#34;ffmpeg-bridge\u0026#34;); // 引入so库, 至于其他的库, 因为在cmake里配置link了, 我实测不需要单独引入 7 } 8 9 public static native void dumpInfo(String url); // 映射到ffmpeg-bridge中的对应方法 10 11} 接着在项目里调用就可以像是调用 ffmpeg 中的 av_dump_format 方法一样了\n这里还要说明一下, 在 c/cpp 端还有一种是用函数指针的方式来映射方法, 可以\n这种方法在方法声明时不需要遵循那个包名_类名_方法名的命名方式, 但是需要定义一些其他的东西, 这个可以百度搜索一下具体的定义规则, 这里就顺便说一下而已\n1package top.kikt.ffmpeg_sdl_example 2 3import android.os.Bundle 4import android.util.Log 5import androidx.appcompat.app.AppCompatActivity 6import kotlinx.android.synthetic.main.activity_main.* 7import java.io.File 8 9class MainActivity : AppCompatActivity() { 10 11 override fun onCreate(savedInstanceState: Bundle?) { 12 super.onCreate(savedInstanceState) 13 setContentView(R.layout.activity_main) 14 15 sample_button.setOnClickListener { 16 FFmpeg.dumpInfo(\u0026#34;http://media.w3.org/2010/05/sintel/trailer.mp4\u0026#34;) // 这里因为没有在异步线程调用, 所以会卡UI, 忽略即可😁 17 } 18 19 } 20} 这个也很简单, 就是 dump 一个信息, xml 可以看项目源码\ndemo 里用的是另一个方法, 就是抽取视频的首帧, 转为 jpg 格式, 存在文件里\n然后我发现了, 我找了网上的 5 个视频来做这个尝试, 只有一个视频首帧不是黑屏 真不知道播放器的库里 issue 为啥一个个都要求用首帧来做封面, 然后吧解释过自己传一个好看的封面才是正道也不听, 还自认为是刚需\n后记 因为偷懒, 提取首帧为 jpeg 图片的 so 库只有 x86 有, 也就是仅支持模拟器端, 其他的 cpu 类型没加 mjpeg 的编码器和封装器\n现在还没做 OpenSSL 关联, 所以 https tls 之类的都没法用\n以上\n","link":"https://kikt.top/posts/android/ffmpeg/compile-with-ndk20/","section":"posts","tags":["ffmpeg","android","ndk"],"title":"Android 记录在macOS上使用 NDK20 编译ffmpeg4.2.2的过程"},{"body":"","link":"https://kikt.top/tags/ffmpeg/","section":"tags","tags":null,"title":"ffmpeg"},{"body":"","link":"https://kikt.top/tags/ndk/","section":"tags","tags":null,"title":"ndk"},{"body":"2019 年结束了, 本年做了什么呢?\n1940 次 github 提交\n公司工作 今年公司的工作并不繁重, 让我有了更多的时间来提升自己的专业技能\n在工作中使用 flutter 作为基础开发 app, 从而实现了更轻松的跨平台\n年中开发了一个新的商城 app, 当然也是 flutter\n年底用了三周时间优化了蓝牙体系\n个人开源工作 年初开源了 flutter_ijkplayer 项目\n年中零零散散开源了一些库\nQ3 重构了 photo_manager 底层\n年底开源了两个蓝牙库(spp/ble), 一个图片处理库\n编程技能 没有太多时间来对于 golang 提升, web 方面基本没学习, java 也没太碰\n但在 dart/flutter 这条路上越走越远了\n业余时间最多的是在音视频处理方面, ffmpeg 和 SDL 目前也算初步入坑了\n2020 年小目标 c/c++ 语言有更深入的学习, 结合 golang/cgo 完成跨语言调用, 以便于未来开发 go-flutter-desktop 的插件 音视频处理方面, 结合 flutter 继续深入 入坑 opencv, 结合 ffmpeg 进一步处理视频 初步完成对于 flutter framework/flutter engine/sky 的了解, 以便于未来对 flutter engine/flutter framework 提有效的建议 进一步完善已开源的项目 好好学英语 挣点小钱 ","link":"https://kikt.top/posts/blog/end-of-2019/","section":"posts","tags":["总结"],"title":"2019 总结"},{"body":"","link":"https://kikt.top/tags/%E6%80%BB%E7%BB%93/","section":"tags","tags":null,"title":"总结"},{"body":"","link":"https://kikt.top/categories/%E6%9D%82%E9%A1%B9/","section":"categories","tags":null,"title":"杂项"},{"body":"","link":"https://kikt.top/tags/dart/","section":"tags","tags":null,"title":"dart"},{"body":"","link":"https://kikt.top/categories/dart/","section":"categories","tags":null,"title":"dart"},{"body":"","link":"https://kikt.top/tags/dart-2.6/","section":"tags","tags":null,"title":"dart 2.6"},{"body":"什么叫可执行二进制 以前虽然看似也可以生成二进制执行文件, 类似 pub/flutter 命令, 但是那实际也是调用 dart 命令来完成的, 也就是说, 你必须具备 dart 环境才可以\n比如以前的 c,后来的 go, 都可以编译成一个可执行文件, 比如./hello-world就可以运行, 然后在控制台输出结果\n而在 dart 2.6 版本中, 这个东西变成了现实\n如何做 1main(List\u0026lt;String\u0026gt; arguments) { 2 print(\u0026#34;hello dart!\u0026#34;); 3} 使用$ dart2native bin/main.dart来完成编译过程, 然后会生成一个main.exe, 虽然看着是 exe, 但这个东西是一个当前系统下的可执行二进制文件\n1./bin/main.exe 2hello dart! 嗯, 这东西目前还不支持交叉编译, 也就是 mac 只能生成 mac 的, windows 只能生成 windows 的, 但是应该有很多人请愿, 未来一定会有相关的支持\n目前可以使用 github actions, 或者 docker 之类的东西来跨平台编译\n好处 单文件的部署方便, 未来写工具也会很方便\n劣势 不支持交叉编译\n文件较大, 一个简单的 helloworld 就有 6.7mb 之大, 相对应的, c 可能只有几 k, go 默认情况下也不到 1m,经过优化也能接近 c 的大小\n可用度 暂时是一个玩具, 在支持交叉编译前还是考虑使用 pub global 比较好\n后记 本篇是 dart 2.6 新特性的一部分\n以上\n","link":"https://kikt.top/posts/dart/2-6-exec/","section":"posts","tags":["dart","dart 2.6","可执行"],"title":"dart 2.6(一) 生成可执行二进制"},{"body":"","link":"https://kikt.top/tags/%E5%8F%AF%E6%89%A7%E8%A1%8C/","section":"tags","tags":null,"title":"可执行"},{"body":"","link":"https://kikt.top/tags/mac/","section":"tags","tags":null,"title":"mac"},{"body":"","link":"https://kikt.top/tags/opencv/","section":"tags","tags":null,"title":"opencv"},{"body":"写在前面, 最近因为某些原因要用到 OpenCV, 加上这东西既然有 android 的库, 那说明 java 也有, 作为老本行我还是挺喜欢 Java 这个语言的\n打算在 mac 上使用, 但是发现没有编译好的 dylib 库, 所以只能自己动手了\n使用 MacPorts 的失败之路 这条路实测不通\n这个 port 我通过 pkg 安装不上, 没有报错原因, 还给我残留了垃圾 通过编译 port 源码的方式安装完毕后, 安装 opencv 的过程需要安装一个 db48, 结果失败了, 猜测是 port 需要使用 db48 作为数据库来管理自己的库或者别的什么原因, 总之失败了 查看日志是 Xcode 的问题, 说已知 11.1 有问题, 请更新到 11.2 巴拉巴拉的..., 问题是开发人员知道 11.2 的问题更大... 用这版本 Xcode 的人 不能上传 appstore...\n11.1 有问题请修复 11.1 的问题.. 而不是简单让人升级, 升级 xcode 需要升级系统, 然后需要经历数个小时的折磨, 这只会让人放弃这个东西\nbrew 内应该有 opencv 的库, 但是还需要对应去寻找 Java 和 mac 的相同版本, 因为 opencv 并没有单独提供 Java 的源码下载\n到这里, 简单使用三方管理二进制库的方案就失败了, 只能自己动手了\n自己编译 首先进入 opencv 官网的 , 下载\n然后解压缩, 默认应该是这样的:\n是使用 cmake 进行管理的, 我们先安装个 cmake, $ brew install cmake, 或者你如果是 android 开发者,可以使用 android sdk 中的 cmake 工具, 或者你可以下载一个 cmake 的, 现在自己版本的\n1cd opencv-4.1.1 2cmake -S . -B build 这样会在 build 文件夹内生成所有的 build 文件\n接着执行下面的步骤, 这一步很慢, 可能需要半小时, 也可能会短一些, 但是 10 分钟以上还是需要的, 虽然我这次没出错, 但是三方库出错概率相当高... , 所以这就是我为什么希望可以拿到编译成品库的原因了...\n1cd build 2make -j8 # 这步很重要, 可以开启多核优化, 能加快编译速度 这一步完成后, 在build/lib里就会有很多的 dylib 文件, 这样 c/c++ 层面的动态库就准备完毕了.\n然后就是 java 的源码了, 在build/modules/java文件夹里就是 java 相关的文件了, 我们先执行以下操作\n1cd build/modules/java 2make -j8 经过一段时间 java 的源码会被生成在这个文件夹里, jar/opencv/java, 可以直接复制这个源码到项目里, 但是我比较疑惑的是, 这东西不是应该是一个 jar 包吗?\n运行 因为我用的是 Idea\n需要添加-Djava.library.path=/Users/cai/Downloads/sdk/opencv/opencv-4.1.1/build/lib参数到 VM options 里,\n在 java 中引入 so 库\n1import org.opencv.core.Core; 2 3public class OpenCVExample1 { 4 static { 5 System.loadLibrary(Core.NATIVE_LIBRARY_NAME); 6 } 7} 这一步完成后就可以在 idea 里愉快的使用 OpenCV 了\n后记 作为移动开发者, 平时可能更多的是在安卓上使用 OpenCV, 官方提供了 android 的原生支持, 我们不需要太多的考虑编译过程, 只需要引入即可.\n但是毕竟有的时候, 本地运行代码的速度会快很多, 很适合做很多测试功能, 因为 android 这东西试验三方代码实在是太慢了.\n以上\n","link":"https://kikt.top/posts/java/mac/compile-opencv4/","section":"posts","tags":["java","opencv","mac"],"title":"在 Mac 上编译 OpenCV4 + Idea 使用Java调用"},{"body":"","link":"https://kikt.top/tags/c/","section":"tags","tags":null,"title":"c"},{"body":"","link":"https://kikt.top/tags/ffi/","section":"tags","tags":null,"title":"ffi"},{"body":"写在前面, 对于无源码的项目, 理论上必须有头文件,不然你不知道里面都定义了什么鬼东西.\n本篇虽然是写无源码的项目, 但实际上还是会有源码部分, 只是通过 cmake,clang,xcodebuild,ndk 等工具编译成 so/framework 以供 android/ios 引入\n生成动态库 整体的目录结构是这样的, 如果你只是要引入库, 可以跳过这步, 这步的主要做源码生成库的步骤\n1$ tree -L 3 cpp-source 2tree -L 3 cpp-source 3cpp-source 4├── android 5│ ├── CMakeLists.txt 6│ ├── build_android.sh 7│ └── cmd 8│ └── android.sh 9├── ios 10│ ├── CMakeLists.txt 11│ ├── build_ios.sh 12│ ├── cmd 13│ │ └── ios_abi_build.sh 14│ └── ios.toolchain.cmake 15└── src 16 ├── some.cpp 17 └── some.h src 为源码\nsome.cpp\n1#include \u0026#34;some.h\u0026#34; 2#include \u0026lt;stdint.h\u0026gt; 3 4extern \u0026#34;C\u0026#34; __attribute__((visibility(\u0026#34;default\u0026#34;))) __attribute__((used)) int32_t 5native_add(int32_t x, int32_t y) { 6 return x + y; 7} android ios 分别对应平台的 Cmake 配置文件和打包脚本\n打包 android 使用 Cmake 配置, 然后通过 ndk 完成这个步骤\nCmakeLists.txt:\n1cmake_minimum_required (VERSION 2.6) # cmake version 2 3project(SOME) # project name 4 5set(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${PROJECT_SOURCE_DIR}/../../android/libs/$ENV{ABI}) # set output path 6 7aux_source_directory(${PROJECT_SOURCE_DIR}/../src SRC_FILES) # scan source code files 8 9add_library(some SHARED ${SRC_FILES}) # add source code files to library, and set build type to dynamic library. 然后有两个打包脚本\n主脚本, 负责循环 abi, 调用副脚本, 并且完成生成的步骤 副脚本, 根据 abi 执行 cmake, 并且完成 make 的过程 主脚本build_android.sh\n1rm -rf ./build 2a=\u0026#34;armeabi-v7a arm64-v8a x86 x86_64\u0026#34; 3for abi in $a; 4do 5export ABI=$abi 6sh cmd/android.sh 7done 副脚本cmd/android.sh\n1export NDK_HOME=$(which adb)/../../ndk-bundle # or set to your ndk home 2 3export MAKE_PATH=build/make-cache 4 5export TARGET_ABI=$ABI 6 7create_makefile() { 8 cmake \\ 9 -DANDROID_ABI=$TARGET_ABI \\ 10 -DANDROID_PLATFORM=android-16 \\ 11 -DCMAKE_BUILD_TYPE=release \\ 12 -DANDROID_NDK=$NDK_HOME \\ 13 -DCMAKE_TOOLCHAIN_FILE=$NDK_HOME/build/cmake/android.toolchain.cmake \\ 14 -DANDROID_TOOLCHAIN=clang -B $MAKE_PATH -S . 15} 16 17create_makefile 18 19cd $MAKE_PATH 20 21make clean 22make 只需要执行\n1cd cpp-source/android 2./build_android.sh 就会生成对应的 so 文件\n这里直接生成到插件的 libs 目录内了, 后续只需要引入即可, 引入的过程请看后面的引入篇\n打包 ios 主要使用项目提供的脚本,配合cmake 和 xcodebuild 来完成打包这个步骤\n两个脚本\nbuild_ios.sh:\n负责 cmake 和提供当前的 sdk 版本号, 调用副脚本完成打包 framework 的过程\n并且将不同 abi 的二进制文件使用lipo进行合并操作\n1rm -fr build 2mkdir build 3 4cd build 5 6cmake .. -G Xcode -DCMAKE_TOOLCHAIN_FILE=../ios.toolchain.cmake -DPLATFORM=OS64COMBINED 7cmake --build . --config Release --target install 8 9cd .. 10 11DEVICE=$(xcodebuild -showsdks|grep \u0026#34;iphoneos\u0026#34;| awk \u0026#39;{print $4}\u0026#39;) 12ABI=$DEVICE sh cmd/ios_abi_build.sh 13 14SIMU=$(xcodebuild -showsdks|grep \u0026#34;iphonesimulator\u0026#34;| awk \u0026#39;{print $6}\u0026#39;) 15ABI=$SIMU sh cmd/ios_abi_build.sh 16 17cd build/output 18cp -rf $DEVICE fat 19lipo -create $DEVICE/Release/some.framework/some $SIMU/Release/some.framework/some -output fat/Release/some.framework/some 20 21cd ../.. 22 23cp -rf build/output/fat/Release/some.framework ../../ios cmd/ios_abi_build.sh:\n负责调用xcodebuild 完成构建 framework 的过程\n1echo \u0026#34;build ios $ABI\u0026#34; 2cd build 3 4cmake .. -G Xcode -DCMAKE_TOOLCHAIN_FILE=../ios.toolchain.cmake -DPLATFORM=OS64COMBINED 5cmake --build . --config Release --target install 6 7# xcodebuild -project SOME.xcodeproj -configuration Release -sdk $ABI -alltargets clean build 8xcodebuild OTHER_CFLAGS=\u0026#34;-fembed-bitcode\u0026#34; -project SOME.xcodeproj -configuration Release -sdk $ABI -alltargets clean build CODE_SIGN_IDENTITY=\u0026#34;\u0026#34; CODE_SIGNING_REQUIRED=NO 只需要执行下面的命令即可打出一个 fat 的包给模拟器和真机同时可用\n1cd cpp-source/ios 2./build_ios.sh 插件项目 现在开始, 假装没有源码, 只有 so 和 framework\nandroid 因为 so 是分 abi 在 libs 目录下的, 而 so 库的默认目录应该是 jniLibs 目录\n所以需要修改 gradle 以引入 so 库\nandroid/build.gradle\n1android { 2 // ... 3 sourceSets{ 4 // ... 5 main.jniLibs.srcDirs = [\u0026#39;libs\u0026#39;] 6 } 7} 这样就完成了 so 库引入的过程\nios 修改flutter_no_cpp_src.podspec\n1s.vendored_frameworks = \u0026#39;some.framework\u0026#39; 这样就完成了 ios 库的引入\ndart 1import \u0026#39;dart:async\u0026#39;; 2 3import \u0026#39;package:flutter/services.dart\u0026#39;; 4import \u0026#39;dart:ffi\u0026#39;; // For FFI 5import \u0026#39;dart:io\u0026#39;; // For Platform.isX 6 7final DynamicLibrary nativeAddLib = Platform.isAndroid 8 ? DynamicLibrary.open(\u0026#34;libsome.so\u0026#34;) 9 : DynamicLibrary.open(\u0026#34;some.framework/some\u0026#34;); 10 11final int Function(int x, int y) nativeAdd = nativeAddLib 12 .lookup\u0026lt;NativeFunction\u0026lt;Int32 Function(Int32, Int32)\u0026gt;\u0026gt;(\u0026#34;native_add\u0026#34;) 13 .asFunction(); 这样nativeAdd方法就是调用前面的c++方法来完成 a+b 的过程\n静态库的问题 因为 android 只支持 so 动态库, 不支持静态库, 所以略过不表\n而 ios 则同时支持静态和动态库, 这里暂时使用的是 framework 形式的动态库, 静态库的话, 可以搜索下如何转化成动态库并打包成 framework 即可\n后记 以上\n","link":"https://kikt.top/posts/flutter/ffi/2-first-party/","section":"posts","tags":["flutter","dart","c","ffi"],"title":"在 flutter 上使用 c 代码 - (二) 无源码的项目"},{"body":"在 flutter 的 1.10.x 后的分支, dart:ffi 被并入 flutter, 现在 flutter 中也可以使用 ffi 了。\n这东西是啥玩意呢, 就是让 dart 可以直接调用 c/c++ 代码等东西的库, FFI(foreign function interface)， 在这里。\n但是在当前版本中, 这东西在官方说明中依然处于技术预览版, 就是可用, 但后续不保证 api 不变更。\n开发环境 首先我是 mac 系统, windows 系统不保证脚本的可用和工具的可用, linux 的话可能一些必要工具需要使用自己平台的包管理工具, 并且涉及到 ios 部分, 必须使用 mac。\n所有需要的工具包\nXcode(或 XcodeBuild 命令行工具) brew clang cmake Android 工具链 Android SDK NDK Android Studio(可选) Gradle Flutter 工具链 SDK 1.10.x+ vscode(可选, 这东西看你的情况,作为示例的话只要是文本编辑器即可, 我本人使用这个作为主要的文本编辑器) 这里说的是包含后续所有用到的东西, 并不仅仅是本文。 其中对于 flutter 开发者可能需要单独安装的应该只有 NDK 和 Cmake, 这两个东西是包含在 android sdk 下的, 可以使用 android studio 下载, 也可以单独下载\nffi 的简单介绍 根据说明\n可以理解为, 将 c 的类型和 dart 的类型关联起来, 然后 ffi 会在内部将两端关联起来, 完成调用\n有如下几种类型 基本就是对应 c 中的类型, 对应 Void 各种长度的 有无符号的整型, 单双精度浮点, 指针, 方法\n转化的过程 c 源码核心就这点, 其他的都做不知即可\n1void hello_world() 2{ 3 printf(\u0026#34;Hello World\\n\u0026#34;); 4} 导包, 这个是第一步要做的\n1import \u0026#39;dart:ffi\u0026#39; as ffi; 1// 定义一个ffi类型 2typedef hello_world_func = ffi.Void Function(); 3 4// 将ffi类型定义为dart类型 5typedef HelloWorld = void Function(); 6 7// 打开动态库, dylib是mac上的动态库的后缀 8final dylib = ffi.DynamicLibrary.open(\u0026#39;hello_world.dylib\u0026#39;); 9 10// 这里是最难理解的一步, 后面会详细解说 11final HelloWorld hello = dylib 12 .lookup\u0026lt;ffi.NativeFunction\u0026lt;hello_world_func\u0026gt;\u0026gt;(\u0026#39;hello_world\u0026#39;) 13 .asFunction(); 14 15// 调用 16hello(); 详细理解转化过程 这里以 lookup 方法为切入点,详细理解下这里做了什么, 以便于后面我们可以自行完成这个过程\nlookup 方法签名如下:\n1external Pointer\u0026lt;T\u0026gt; lookup\u0026lt;T extends NativeType\u0026gt;(String symbolName); 参数 很好理解, 传入一个方法名, 让我们能找到 c 方法\n泛型 这个是方法的类型签名的 dart:ffi 表现形式.\nc 方法的签名是这样的: void hello_world(), 所以我们就需要一个对应的类型, 也就是上面定义的 ffi 类型\nffi.Void Function()\n返回类型 这里的返回值是用于在实际调用时,转化 c 方法的返回值为 dart 的类型来使用的, 所以就是对应的 dart 类型\n1 2/// 定义是这样的 3void Function() 4 5/// 接收的asFunction方法 6final void Function() hello = XXXX; 写起来的时候可能是这样的,\n实例 1extern \u0026#34;C\u0026#34; { 2// __attribute__((visibility(\u0026#34;default\u0026#34;))) __attribute__((used)) // 虽然说需要这行, 但是没这行也没报错 3int32_t native_add(int32_t x, int32_t y) { return x + y; } 4 5double double_add(double x, double y) { return x + y; } 6} 1import \u0026#39;dart:ffi\u0026#39;; 2 3final DynamicLibrary dylib = Platform.isAndroid 4 ? DynamicLibrary.open(\u0026#34;libnative_add.so\u0026#34;) 5 : DynamicLibrary.open(\u0026#34;native_add.framework/native_add\u0026#34;); 6 7final int Function(int x, int y) nativeAdd = dylib 8 .lookup\u0026lt;NativeFunction\u0026lt;Int32 Function(Int32, Int32)\u0026gt;\u0026gt;(\u0026#34;native_add\u0026#34;) 9 .asFunction(); 10 11final double Function(double, double) doubleAdd = dylib 12 .lookup\u0026lt;NativeFunction\u0026lt;Double Function(Double, Double)\u0026gt;\u0026gt;(\u0026#34;double_add\u0026#34;) 13 .asFunction(); 打包和运行 在 dart vm 中,可以有多种方案, 只要能编译出 dylib 即可\n官方的中是直接使用 make, 内部使用 gcc 打包编译\n这里有一个,是设置 dylib 的目录到环境变量中, 以便于运行时可以找到动态库\n在 flutter 中使用 接着就要开始在 flutter 中使用了, 和在 dart vm 中使用不一样, 不能使用环境变量, 而是需要将库置入到项目中\n创建仓库 直接使用 $ flutter create -t plugin native_add 的方式即可\ncpp 文件 native_add.cpp\n1#include \u0026lt;stdint.h\u0026gt; 2 3extern \u0026#34;C\u0026#34; { 4// __attribute__((visibility(\u0026#34;default\u0026#34;))) __attribute__((used)) 5int32_t native_add(int32_t x, int32_t y) { return x + y; } 6 7double double_add(double x, double y) { return x + y; } 8} dart 文件 1final DynamicLibrary dylib = Platform.isAndroid 2 ? DynamicLibrary.open(\u0026#34;libnative_add.so\u0026#34;) 3 : DynamicLibrary.open(\u0026#34;native_add.framework/native_add\u0026#34;); 4 5final int Function(int x, int y) nativeAdd = dylib 6 .lookup\u0026lt;NativeFunction\u0026lt;Int32 Function(Int32, Int32)\u0026gt;\u0026gt;(\u0026#34;native_add\u0026#34;) 7 .asFunction(); 8 9final double Function(double, double) doubleAdd = dylib 10 .lookup\u0026lt;NativeFunction\u0026lt;Double Function(Double, Double)\u0026gt;\u0026gt;(\u0026#34;double_add\u0026#34;) 11 .asFunction(); 界面:\n1 2class MyHomePage extends StatefulWidget { 3 MyHomePage({Key key, this.title}) : super(key: key); 4 5 final String title; 6 7 @override 8 _MyHomePageState createState() =\u0026gt; _MyHomePageState(); 9} 10 11class _MyHomePageState extends State\u0026lt;MyHomePage\u0026gt; { 12 int _counter = 0; 13 14 void _incrementCounter() { 15 setState(() { 16 _counter = nativeAdd(_counter, 1); 17 }); 18 } 19 20 @override 21 Widget build(BuildContext context) { 22 return Scaffold( 23 appBar: AppBar( 24 title: Text(widget.title), 25 ), 26 body: Center( 27 child: Column( 28 mainAxisAlignment: MainAxisAlignment.center, 29 children: \u0026lt;Widget\u0026gt;[ 30 Text( 31 \u0026#39;You have pushed the button this many times:\u0026#39;, 32 ), 33 Text( 34 \u0026#39;$_counter\u0026#39;, 35 style: Theme.of(context).textTheme.display1, 36 ), 37 Text( 38 \u0026#34;native double value = ${doubleAdd(_counter.toDouble(), _counter.toDouble())}\u0026#34;), 39 ], 40 ), 41 ), 42 floatingActionButton: FloatingActionButton( 43 onPressed: _incrementCounter, 44 tooltip: \u0026#39;Increment\u0026#39;, 45 child: Icon(Icons.add), 46 ), 47 ); 48 } 49} ios ios 中, 直接将 cpp 文件置入 ios/classes 文件夹内即可, 然后因为 podspec 中包含默认配置的原因, 这个文件会被自动引入项目\n1s.source_files = \u0026#39;Classes/**/*\u0026#39; 运行项目:\nAndroid android 中其实有两种方法, 一是用传统的 ndk 方式, 就是 Android.mk 那种方案, 我们略过这种方案, 因为配置比较复杂, 我们使用第二种方案, 官方推荐的 cmake 方案\n因为 ios 中, 文件被置入源码中, 我这里直接使用相对路径去引入这个文件\nCMakeLists.txt:\n1cmake_minimum_required(VERSION 3.4.1) # for example 2 3add_library( native_add 4 5 # Sets the library as a shared library. 6 SHARED 7 8 # Provides a relative path to your source file(s). 9 ../ios/Classes/native_add.cpp ) 指定源码对应的库是哪个库 指定库的类型, 这里是动态库, 所以用 SHARED 指定源码目录 然后因为我们使用了 cmake, 为了让安卓项目知道, 我们需要修改 gradle 文件\n1android{ 2 // ... 3 externalNativeBuild { 4 cmake { 5 path \u0026#34;CMakeLists.txt\u0026#34; 6 } 7 } 8} 这里在 android 节点下, 添加属性即可, 这里是指定 Cmake 使用的文件\n接着就可以运行项目了, 和 android 中一样\n简单总结 现在 ffi 处于初始阶段, 还有诸多不足.\n比如, 文档的缺失, 现在如何传递字符串,数组都是问题, 虽然有结构体的定义, 也能看到部分说明, 但没有简单的示例帮助开发者快速使用.\n只有基本数据类型, 目前可能还不需要借用 c 来解决, 未来则要看 ffi 会开放到什么程度.\n后记 项目地址: 以上\n","link":"https://kikt.top/posts/flutter/ffi/1-first-party/","section":"posts","tags":["flutter","dart","c","ffi"],"title":"在 flutter 上使用 c 代码 - (一) 有源码的项目"},{"body":"好久没水文章了, 强行水一篇\ndart 中不可避免会出现文件读取的情况, 甚至是很大的文件, 比如 200M 的文件\n如果一次性读入内存,虽然也行得通, 但是如果在 flutter 中开启个 200M 大小的字节数组, 一不小心可能就 crash 了, 这时候就需要使用大文件读取的方案\n异步读取 核心方法:\n1file.openRead(); 这个方法可以指定开始和结束的坐标, 并开启一个 stream\nstream 回调信息是 List\u0026lt;int\u0026gt;,单次最大读取 65536 个字节\n示例 1class FileUtils { 2 File file; 3 4 FileUtils(this.file); 5 6 // 读取文件的某个范围返回 7 Future\u0026lt;List\u0026lt;int\u0026gt;\u0026gt; getRange(int start, int end) async { 8 if (file == null || !file.existsSync()) { 9 throw FileNotExistsError(); 10 } 11 if (start \u0026lt; 0) { 12 throw RangeError.range(start, 0, file.lengthSync()); 13 } 14 if (end \u0026gt; file.lengthSync()) { 15 throw RangeError.range(end, 0, file.lengthSync()); 16 } 17 18 final c = MyCompleter\u0026lt;List\u0026lt;int\u0026gt;\u0026gt;(); 19 20 List\u0026lt;int\u0026gt; result = []; 21 file.openRead(start, end).listen((data) { 22 result.addAll(data); 23 }).onDone(() { 24 c.reply(result); 25 }); 26 27 return c.future; 28 } 29} 用到的 completer 在这里\n1import \u0026#39;dart:async\u0026#39;; 2 3class MyCompleter\u0026lt;T\u0026gt; { 4 Completer\u0026lt;T\u0026gt; completer = Completer(); 5 6 MyCompleter(); 7 8 Future\u0026lt;T\u0026gt; get future =\u0026gt; completer.future; 9 10 void reply(T result) { 11 if (!completer.isCompleted) { 12 completer.complete(result); 13 } 14 } 15} 这里主要是封装了一个指定某个范围返回的方法, 比如我写了一个简单的 dart 包, 通过读取元数据的方案, 来读取图片大小, 这样不用通过完整的解码即可完成, 效率比 dart:ui.Image 解码后查看宽高要高的多\n项目地址: 比如判断一个文件是不是 jpeg 格式, 需要判断开头两个字节和结尾两个字节是不是 0xFF 0xD9 开头, 0xFF 0xD8 结尾\n原始代码是这样的, 很不清晰, 也比较难以阅读: 经过修改后是这样的\n1 static Future\u0026lt;bool\u0026gt; isJpg(File file) async { 2 if (file == null || !file.existsSync()) { 3 return false; 4 } 5 6 const start = [0xFF, 0xD9]; 7 const end = [0xFF, 0xD8]; 8 9 final completer = MyCompleter\u0026lt;bool\u0026gt;(); 10 11 void foo() async { 12 final util = FileUtils(file); 13 final length = file.lengthSync(); 14 15 final startList = await util.getRange(0, 2); 16 final endList = await util.getRange(length - 2, length); 17 18 const eq = ListEquality(); 19 20 completer.reply(eq.equals(start, startList) \u0026amp;\u0026amp; eq.equals(end, endList)); 21 } 22 23 foo(); 24 25 return completer.future; 26 } 同步读取 当然有的时候，你在 flutter 的 build 方法中操作文件，那就不适合用异步了，因为太多的 FutureBuilder 也是很烦的，这个时候可以用同步方法。\n1 List\u0026lt;int\u0026gt; getRangeSync(File file, int start, int end) { 2 final accessFile = file.openSync(); 3 try { 4 accessFile.setPositionSync(start); 5 return accessFile.readSync(end - start).toList(); 6 } finally { 7 accessFile.closeSync(); 8 } 9 } 手动 close 是一个好习惯\n关于 readInfoSync 这个方法我在实际用的时候会出现问题，具体原因不太清楚\n后记 项目地址: 1pub get 2 3dart bin/main.dart 以上\n","link":"https://kikt.top/posts/dart/file/read/","section":"posts","tags":["flutter","dart","大文件"],"title":"dart 大文件读取"},{"body":"","link":"https://kikt.top/tags/%E5%A4%A7%E6%96%87%E4%BB%B6/","section":"tags","tags":null,"title":"大文件"},{"body":"","link":"https://kikt.top/tags/ide/","section":"tags","tags":null,"title":"ide"},{"body":"","link":"https://kikt.top/tags/idea/","section":"tags","tags":null,"title":"idea"},{"body":"","link":"https://kikt.top/tags/jetbrains/","section":"tags","tags":null,"title":"jetbrains"},{"body":"","link":"https://kikt.top/categories/jetbrains/","section":"categories","tags":null,"title":"jetbrains"},{"body":"","link":"https://kikt.top/tags/live-template/","section":"tags","tags":null,"title":"live template"},{"body":"Jetbrains 全家桶,包括 android studio, 支持一个东西叫 Live Template\n这个东西可以预先储存一个模板, 帮助我们快速开发, 这个功能很多朋友应该都知道,也在用\n本篇使用dart作为主要示例语言, dart 语言语法比较简单, 有 java/js 等常用语言基础的都应该能看懂\n简单使用 虽然想要重点介绍 groovyScript 的脚本使用, 但是也应该简单介绍下 Live Template\n比如我可以存一个 stful, 然后会自动生成一段代码, 当然这个模板是 flutter 开发自带的\n进阶 自己搞一个小模板 这个模板就生成一个我们自己的类库调用, 比如我自己封装了一个 http 访问\n1final response = await HttpHelper.fetchString(url); 以这段代码为例, 我们一个小 app 可能有 100 个接口, 这时候 LiveTemplate 就派上用场了\n我这里为了图省事, 直接指定只要是 dart 语言都生效 指定变量 使用两个$符号把变量包起来, 就可以指定变量名称 $1$\n相同的变量会被同时编辑\n变量名是自己定义的\n表达式后面会说\n默认值, 只有在没有表达式的时候才有用\n是否跳过是说, 如果设置了表达式或者默认值就不再需要手动输入了, 适用于你确定表达式没错的情况\n表达式(函数) Jetbrains 有一个页面来讲预置的表达式和对应的说明\n包括一些常见的功能\nclipboard(): 剪切板 camelCase(String): 驼峰 capitalize(String): 首字母大写 className(): 类名 date(sDate): 日期 fileName(): 文件名 fileNameWithoutExtension(): 无扩展文件名 groovyScript(\u0026quot;groovy code\u0026quot;, arg1) :执行 groovy 脚本 比如我可以组合使用一些功能以达到快速输入类名的功能\n比如我的 dart 文件名为 test_page.dart 我使用如下的函数 capitalize(camelCase(fileNameWithoutExtension()))\n会自动根据文件名生成一个符合 dart 规范的大写驼峰类名\ngroovy 脚本的使用 前面讲了一些基础, 这一节来说说 groovy 脚本\ngroovy 是一个 Apache 的语言, 可以编译成 java class,也可以直接运行\n开发 android 时绕不开的 gradle 就是 groovy 语法\n官网: 安装 其他环境看情况自己下载\nMac 可以用这个: $ brew install groovy\n基本语法 就不讲了\n用 idea 打开,然后看提示 😁\n编写一个基本的脚本 根据 Jetbrains 的说明, 需要 return 一个字符串\n我脚本内容如下:\n1def a = \u0026#39;I come from groovy\u0026#39;; 2return a 在 groovy 中,单引号和双引号基本同义, 建议代码中使用单引号, 因为这样复制到 idea 里不用转义, 当然如果你用了字符串插值的方式另当别论, groovy 中字符串插值只可以用双引号, 这一点和 shell 很类似\n在 live template 中使用 groovy groovyScript(\u0026quot;def a = 'I come from groovy';return a\u0026quot;)\n把这个丑陋的东西复制到表达式框里, 就是把 groovy 脚本的内容放在一个字符串里, 然后作为 groovyScript 的第一参数\n嗯 成功了\ngroovyScript 的简单讲解 类似于 java 或其他语言的不定参数\ngroovyScript 函数支持参数传递\n在 groovy 脚本的内容中, _1,是第一个参数, _2, _3依此类推, 据说支持到_n,也就是无限多\n例子: groovyScript(\u0026quot;return _1\u0026quot;,fileNameWithoutExtension()) 直接把无扩展名的文件名作为值返回.\n后记 基本的东西就到这了, 抛砖引玉, groovy 可以做的东西很多, 毕竟是一门语言\n以上\n","link":"https://kikt.top/posts/jetbrains/template/live-template/","section":"posts","tags":["live template","模板","jetbrains","idea","ide","工具","编程技巧"],"title":"Live Template groovy脚本的使用"},{"body":"","link":"https://kikt.top/categories/tools/","section":"categories","tags":null,"title":"tools"},{"body":"","link":"https://kikt.top/tags/%E5%B7%A5%E5%85%B7/","section":"tags","tags":null,"title":"工具"},{"body":"","link":"https://kikt.top/tags/%E6%A8%A1%E6%9D%BF/","section":"tags","tags":null,"title":"模板"},{"body":"","link":"https://kikt.top/tags/%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/","section":"tags","tags":null,"title":"编程技巧"},{"body":"在一个正常的应用程序中, 表单是用户交互的很重要的一部分\nflutter 中你可以自己\u0026quot;绑定\u0026quot;用户的输入数据和 state 中的字段\n当然, 还有另一个选择, Flutter 内置了 Form 组件给我们使用, 这个组件是 flutter 框架提供出来帮助我们操作表单的一个组件, 应该是官方较为推荐的方案\n不过 Form 的相关中文文章不太多, 基本都是介绍一下 TextFormField 的使用, 更多的 api 云里雾里的, 可能有些朋友不太好理解\n我粗略的解析下源码和自定义, 帮助看过的朋友理解下 Form 体系\nForm 体系的简单使用 自动校验 官方提供给了我们一些组件来结合 Form 使用, 最常见的就是 TextFormField\n1import \u0026#39;package:flutter/material.dart\u0026#39;; 2 3class SimpleUseComponent extends StatefulWidget { 4 @override 5 _SimpleUseComponentState createState() =\u0026gt; _SimpleUseComponentState(); 6} 7 8class _SimpleUseComponentState extends State\u0026lt;SimpleUseComponent\u0026gt; { 9 @override 10 Widget build(BuildContext context) { 11 return Form( 12 onChanged: () { 13 print(\u0026#34;form change\u0026#34;); 14 }, 15 child: Column( 16 children: \u0026lt;Widget\u0026gt;[ 17 TextFormField( 18 initialValue: \u0026#34;你好\u0026#34;, 19 validator: (value) { 20 if (value.isEmpty) return \u0026#34;不能为空\u0026#34;; 21 return null; 22 }, 23 autovalidate: true, 24 ), 25 ], 26 ), 27 ); 28 } 29} 当我输入/删除时, 会出现日志: 'form change'\n有一个autovalidate的属性, 这个属性可以在TextFormField设置,也可以在Form设置, 自动提交验证的意思, 默认是 false.\n当我将所有字符都删除时, 会出现'不能为空'的提示. 这个是由 validator 实现的, 因为我设置了autovalidate为 true, 然后这个返回值如果是 null, 则说明验证通过, 不通过则返回不通过的字符串.\n点击后校验 当然,有些表单不要求自动校验, 可能是点击某个按钮后来校验, 这种情况下, 就需要使用 Form.of 来获取到表单状态\n话不多说, 代码在下面:\n1 2class SimpleUseClickComponent extends StatefulWidget { 3 @override 4 _SimpleUseClickComponentState createState() =\u0026gt; 5 _SimpleUseClickComponentState(); 6} 7 8class _SimpleUseClickComponentState extends State\u0026lt;SimpleUseClickComponent\u0026gt; { 9 @override 10 Widget build(BuildContext context) { 11 return Form( 12 onChanged: () { 13 print(\u0026#34;form change\u0026#34;); 14 }, 15 child: Column( 16 children: \u0026lt;Widget\u0026gt;[ 17 TextFormField( 18 validator: (value) { 19 if (value.isEmpty) return \u0026#34;不能为空\u0026#34;; 20 return null; 21 }, 22 ), 23 Builder( // 这个 Builder 是 24 builder: (ctx) =\u0026gt; RaisedButton( 25 child: Text(\u0026#39;check\u0026#39;), 26 onPressed: () { 27 final formState = Form.of(ctx); 28 formState.validate(); // 验证 29 // formState.reset(); // 重置 30 // formState.save(); // 保存 31 }, 32 ), 33 ), 34 ], 35 ), 36 ); 37 } 38} validate 会触发 FormState 的 validation 回调\nreset 会触发 FormFieldState 的 reset 回调, 默认实现是将输入框设置为初始值\nsave 会触发 FormFieldState 的 save 回调, 可以在里面写一些逻辑(比如保存信息到数据库等等)\nForm 体系源码 架构查看 Form 组件是 widgets 包内的的一个 Widget, 不是 Material 和 Cupertino 包内的, 它没有用户界面, 更多的是逻辑层面的一个组件\nForm 体系中有 5 个类, 3 个 typedef 组成\nFormScope 是一个InheritedWidget, 一般带of方法的组件都会对应一个这个东西, 是获取 Form 中 FormState 的容器类\nFormState 就是 Form 对应的 state\nFormField是Form下的子组件的通用类, 每个实现/继承了这个类的子类就可以被Form管理, 比如 TextFieldForm 就是这么一个组件\nFormFieldState 是 FormField 对应的状态, 其中包含了一些状态信息\n源码解析 通过回调等手段实现了内部的交互, 详细看截图\nForm 解析 FormState 解析 FormField 解析 FormFieldState 解析 自定义 Form 子组件 有的时候表单中并不只有文本输入, 还会有 Checkbox 等组件, 我这里举两个例子来自定义一个 Form 子组件\n自定义 CheckboxFormField 1import \u0026#39;package:flutter/material.dart\u0026#39;; 2 3class CheckboxFormField extends FormField\u0026lt;bool\u0026gt; { 4 CheckboxFormField({ 5 bool initValue, 6 }) : super( 7 builder: CheckboxFormField.buildWidget, 8 initialValue: initValue, 9 ); 10 11 static Widget buildWidget(FormFieldState\u0026lt;bool\u0026gt; field) { 12 return Checkbox( 13 onChanged: (bool value) { 14 field.didChange(value); 15 }, 16 value: field.value, 17 ); 18 } 19} 一个简单的自定义 CheckboxFormField 就完成了\n置入 Form 中\n1import \u0026#39;package:flutter/material.dart\u0026#39;; 2 3import \u0026#39;custom_field.dart\u0026#39;; 4 5class FormComponent extends StatefulWidget { 6 @override 7 _FormComponentState createState() =\u0026gt; _FormComponentState(); 8} 9 10class _FormComponentState extends State\u0026lt;FormComponent\u0026gt; { 11 @override 12 Widget build(BuildContext context) { 13 return Form( 14 onChanged: () { 15 print(\u0026#34;on change\u0026#34;); 16 }, 17 child: ListView( 18 children: \u0026lt;Widget\u0026gt;[ 19 CheckboxFormField(), 20 ], 21 ), 22 ); 23 } 24} 当我点击时, 就会回调 on change\n自定义 SliderFormField 1class SliderFormField extends FormField\u0026lt;double\u0026gt; { 2 SliderFormField() 3 : super( 4 builder: SliderFormField.buildWidget, 5 initialValue: 50, 6 ); 7 8 static Widget buildWidget(FormFieldState\u0026lt;double\u0026gt; field) { 9 return Slider( 10 onChanged: (double value) { 11 field.didChange(value); 12 }, 13 value: field.value, 14 min: 0, 15 max: 100, 16 divisions: 100, 17 ); 18 } 19} 置入 Form 中\n1import \u0026#39;package:flutter/material.dart\u0026#39;; 2 3import \u0026#39;custom_field.dart\u0026#39;; 4 5class FormComponent extends StatefulWidget { 6 @override 7 _FormComponentState createState() =\u0026gt; _FormComponentState(); 8} 9 10class _FormComponentState extends State\u0026lt;FormComponent\u0026gt; { 11 GlobalKey\u0026lt;FormState\u0026gt; formKey = GlobalKey(); 12 13 @override 14 Widget build(BuildContext context) { 15 return Form( 16 key: formKey, 17 onChanged: () { 18 print(\u0026#34;on change\u0026#34;); 19 }, 20 child: ListView( 21 children: \u0026lt;Widget\u0026gt;[ 22 CheckboxFormField(), 23 SliderFormField(), 24 RaisedButton( 25 onPressed: () { 26 formKey.currentState.reset(); 27 }, 28 child: Text(\u0026#34;reset\u0026#34;), 29 ), 30 ], 31 ), 32 ); 33 } 34} 加入了一个Key用于获取FormState, 触发reset方法\n截图:\n后记 本篇解析了一下 Form 的使用和源码, 帮助朋友们更好的理解使用\n以上\n","link":"https://kikt.top/posts/flutter/form/form1/","section":"posts","tags":["flutter","form","表单"],"title":"flutter Form 表单组件的初步解析"},{"body":"","link":"https://kikt.top/tags/form/","section":"tags","tags":null,"title":"form"},{"body":"","link":"https://kikt.top/tags/%E8%A1%A8%E5%8D%95/","section":"tags","tags":null,"title":"表单"},{"body":"","link":"https://kikt.top/tags/app/","section":"tags","tags":null,"title":"app"},{"body":"","link":"https://kikt.top/tags/desktop/","section":"tags","tags":null,"title":"desktop"},{"body":"","link":"https://kikt.top/tags/dmg/","section":"tags","tags":null,"title":"dmg"},{"body":"前篇对于 go-flutter 引擎进行了初步的探索, 打包终产物是一个二进制文件配合一些资源文件\n本篇研究如何将终产物变成一个 app, 进一步变成 dmg, 就和你网上下载的工具一样\n本篇默认你拥有全套的工具, git xcode flutter go hover\n打包出 go 终产物 这里以大佬的 为例\n1cd /tmp 2git clone https://github.com/fluttercandies/JsonToDart.git 3cd JsonToDart/Flutter/desktop 打包\n1hover build 这里可能很快也可能很慢, 根据你的工程大小和网络速度而言, 网络速度是因为要下载 flutter 依赖和 go-flutter 引擎相关的东西, 工程大小影响编译速度\n然后可以看到当前的目录结构\n1tree -L 2 desktop/build/outputs/darwin 2desktop/build/outputs/darwin 3├── FlutterEmbedder.framework 4│ ├── FlutterEmbedder -\u0026gt; Versions/Current/FlutterEmbedder 5│ ├── Headers -\u0026gt; Versions/Current/Headers 6│ ├── Modules -\u0026gt; Versions/Current/Modules 7│ ├── Resources -\u0026gt; Versions/Current/Resources 8│ └── Versions 9├── assets 10│ └── icon.png 11├── flutter_assets 12│ ├── AssetManifest.json 13│ ├── FontManifest.json 14│ ├── LICENSE 15│ ├── fonts 16│ ├── isolate_snapshot_data 17│ ├── kernel_blob.bin 18│ ├── packages 19│ └── vm_snapshot_data 20├── icudtl.dat 21└── json_to_dart 其中这个 json_to_dart 就是可运行的二进制文件 我们可以直接通过$ desktop/build/outputs/darwin/json_to_dart来运行\n当然这种情况下, 运行图标是这样的\n要求完美(有强迫症)的法空大佬要求要做成 app 的样子, 我就去研究了一下, 完成了这么一个终产物\n双击打开是这样的 制作 app 文件 本篇内容很多来自于\n图标部分的话使用了一个叫 iconkit 的软件结合命令行制作\n新建一个文件夹 嗯, 就是一个正常的文件夹, 名字随意(后面会改), 后面所有的修改除重命名本文件夹以外, 都在这个文件夹里进行\nContents 文件夹 新建一个 Contents 文件夹, 至于为什么要这么命名, 其实是苹果对于 app 的规定, 遵守就好\n里面的东西如下:\nInfo.plist app 的清单文件, 后面看\nMacOS go-flutter 那步打包的所有文件复制进来\nResource 资源文件都会在这里,图标之类的\nInfo.plist 这个是清单文件,一个 xml, 但是语法比较怪\nkey 和 value 分别是某个标签的 content\n1\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; 2\u0026lt;!DOCTYPE plist PUBLIC \u0026#34;-//Apple//DTD PLIST 1.0//EN\u0026#34; \u0026#34;http://www.apple.com/DTDs/PropertyList-1.0.dtd\u0026#34;\u0026gt; 3\u0026lt;plist version=\u0026#34;1.0\u0026#34;\u0026gt; 4\u0026lt;dict\u0026gt; 5 \u0026lt;key\u0026gt;CFBundleExecutable\u0026lt;/key\u0026gt; 6 \u0026lt;string\u0026gt;json_to_dart\u0026lt;/string\u0026gt; 7 \u0026lt;key\u0026gt;CFBundleIconFile\u0026lt;/key\u0026gt; 8 \u0026lt;string\u0026gt;icon.icns\u0026lt;/string\u0026gt; 9 \u0026lt;key\u0026gt;CFBundleIdentifier\u0026lt;/key\u0026gt; 10 \u0026lt;string\u0026gt;com.github.flutter.jsontodart\u0026lt;/string\u0026gt; 11 \u0026lt;key\u0026gt;NSHighResolutionCapable\u0026lt;/key\u0026gt; 12 \u0026lt;true/\u0026gt; 13 \u0026lt;key\u0026gt;LSUIElement\u0026lt;/key\u0026gt; 14 \u0026lt;true/\u0026gt; 15\u0026lt;/dict\u0026gt; 16\u0026lt;/plist\u0026gt; CFBundleExecutable: 你要运行的二进制, 这里是 json_to_dart\nCFBundleIconFile: 应用图标的指向, 相对 Resources 文件的路径\nCFBundleIdentifier: 应用唯一标示, 这里根据你的情况写\nNSHighResolutionCapable: 是否支持高清(Retina 屏,建议设置为 true)\nLSUIElement: 不知道什么意思, 好像是说 UI 的什么信息\n制作应用图标 准备一个 1024x1024 的图作为 icon\n打开 IconKit, 把图片文件拖到中间的十字上\n然后储存一下\n这里做成 icns 还是直接用 iconset 由你自己决定\n做成 icns 的话是一个文件, iconset 是一个文件夹, 如果资源不多直接用文件夹, 资源太多, 可以整合一下\n使用这个命令制作 $ iconutil -c icns -o App.icns AppIcon.iconset, 这里注意 文件夹必须改成iconset扩展名,不然转化会报错\n使用什么名字根据你自己的想法来\n重命名 到最外面重命名文件夹, 加上.app 后缀, 就会自动变成一个 app 了\n运行 看效果图\n打包 dmg 到了这步已经可以使用了, 但是一般情况下, 会使用 dmg 格式来分发应用\ndmg 是一个磁盘映像, 制作很简单, 使用 mac 自带的工具就可以了\n创建映像 打开磁盘工具 cmd+n 新建 大小要选能放下的大小, 这里终产物有 70m, 我就填个 100MB 然后选读写,存储,选择位置\n修改映像内容 把 app 拖进来\n再创建一个/Application 的\u0026quot;快捷方式\u0026quot;, 在 finder 中 cmd+shift+g 然后输入/+回车来到根目录, 创建一个替身\n这时候会要输入密码, 这个是由于操作根目录需要 root 权限的原因\n接着把这个快捷方式拖到 dmg 里, 就完成了基本的制作\n导出映像 这个映像是不建议直接分发的, 先推出\n然后在磁盘工具中转换一下\n改名字, 选压缩, 加密与否看你的情况\n这里转换失败的话检查一下你之前那个自己制作的 dmg 是不是没有推出\n对比下大小:\n导出后的 dmg 比较小\n版本升级 后续制作好 app 后, 只需要替换 100MB 映像内的 app 即可\n后记 简单的制作了一下 app+dmg, 顺便了解了一下 app 的包内容是如何排布的\n以上\n","link":"https://kikt.top/posts/flutter/desktop/go-desktop-engine/flutter-go-desktop-2/","section":"posts","tags":["flutter","desktop","go","dmg","app"],"title":"Go Flutter Desktop (二) go 二进制程序打包为 mac app(dmg)"},{"body":"Flutter 在去年的时候就有一个第三方的桌面引擎, 是用 golang 开发的\nGithub 地址是:https://github.com/go-flutter-desktop/go-flutter\n目前在 mac,linux,windows 均可用, 作为一个 mac 用户, 除了 retina 下字显得有点小, 感觉没有单独适配外, 总体感觉是优于官方的 desktop 引擎的\n另外我是真实的 golang 脑残粉, 我觉得 golang 这东西真的太好了, 用 golang, 准不会错\n开发环境 需要的开发环境, 因为我是 MacOS, 我以 macOS 为例,其他的请参考对应的系统\nXcode 命令行体系, 这个东西包含很多开发套件(Git), 无论你是否用 XCode 开发,都建议装一个... Flutter 环境和配套工具, 这个跑不掉,作为 flutter 开发者... go 语言环境(使用 brew 安装), 1.12+, IDE 用 Jetbrains 家的 goland (你用 VSCode 的话看你自己的情况) 环境安装 对 flutter 桌面版本感兴趣的一定接触过 flutter 开发, 我就默认你有 flutter 全套开发环境\ngo 语言环境安装 $ brew install go\n如果你的 go 比较老, 请升级,使用$ brew upgrade go\n配置 GOPATH 环境变量\n$ vi ~/.bash_profile\n1export GOPATH=~/code/go # 这个是必须配置的, 等号后的部分根据你的情况修改, 简单来说里面放的是你自己的代码,不是go的SDK,不是go的SDK,不是go的SDK, 具体的话是你 go 语言的三方库源码/自己写的go代码/中间产物/应用程序所在的目录 2PATH=$PATH:$GOPATH/bin # 这个是选配, 但是强烈建议配置,不然以后的go工具链需要全路径引用 你下载的 go 相关的东西会被装在这个文件夹里\ngo-flutter 的环境 需要使用一个叫做 hover 的工具, 这个工具是由 go 编写的, 编译打包运行都使用这个工具\n$ go get -u github.com/go-flutter-desktop/hover, 这样这个工具会被安装到$GOPATH/bin目录下\n当你可以直接在命令行输入 hover 可以出现如下情况时就说明可用了\n1➜ ~ hover -h 2Hover helps developers to release Flutter applications on desktop. 3 4Usage: 5 hover [flags] 6 hover [command] 7 8Available Commands: 9 build Build a desktop release 10 help Help about any command 11 init Initialize a flutter project to use go-flutter 12 run Build and start a desktop release, with hot-reload support 13 14Flags: 15 -h, --help help for hover 16 17Use \u0026#34;hover [command] --help\u0026#34; for more information about a command. 18➜ ~ 安装 hover 出现问题的话可以参考\n运行 example 官方提供了几个 example: 1cd /tmp 2git clone https://github.com/go-flutter-desktop/examples.git flutter-examples 3cd flutter-examples/pointer_demo 4flutter pub get 5hover run 通过以上几个步骤就可以把项目跑起来了\n是一个关于鼠标移入移出监听的 demo\n将原项目改为 desktop 官方说明文档是这样的, 不想看英文的, 可以跳过官方文档直接看我的中文说明\n这里要注意, 因为插件系统的原因, 如果不是纯 dart 插件, 则插件内容不能用\n我模拟一下这个过程, 创建一个+++的 helloworld 工程, 你如果是要改造已有项目, 则应该 cd 到你的 flutter 的根目录进行 $ hover init 项目url的操作, 这里根据官方说, url 无所谓, 后面可改\n1flutter create flutter_example_1 2cd flutter_example_1 3flutter pub get 4hover init github.com/Caijinglong/flutter-go-example # 初始化 desktop 工程 这时候运行项目$ hover run会有一个提示: Target file \u0026quot;lib/main_desktop.dart\u0026quot; not found.\n我们查询可知, 可能是考虑到兼容性的问题, go 引擎的项目使用 main_desktop.dart 作为入口, 我们创建一个文件\nmain_desktop.dart:\n1import \u0026#39;package:flutter/foundation.dart\u0026#39;; 2import \u0026#39;package:flutter/widgets.dart\u0026#39;; 3 4import \u0026#39;main.dart\u0026#39;; 5 6void main() { 7 debugDefaultTargetPlatformOverride = TargetPlatform.fuchsia; 8 runApp(MyApp()); 9} $ hover run\n这样项目就跑起来了\n测试基础的项目 测试下常用的几项:\n事件响应 ListView 图片 输入框情况 事件响应 点击事件是可行的,数字可加, 说明鼠标事件能响应, 其他的长按双击等等都是 flutter 实现的, 理论上就不需要测试了\n最开始的官方 demo 中有鼠标移入移出事件\nListView 滚动 1import \u0026#39;package:flutter/material.dart\u0026#39;; 2 3class ListViewPage extends StatefulWidget { 4 @override 5 _ListViewPageState createState() =\u0026gt; _ListViewPageState(); 6} 7 8class _ListViewPageState extends State\u0026lt;ListViewPage\u0026gt; { 9 @override 10 Widget build(BuildContext context) { 11 return Scaffold( 12 appBar: AppBar(), 13 body: ListView.builder( 14 itemBuilder: _buildItem, 15 ), 16 ); 17 } 18 19 Widget _buildItem(BuildContext context, int index) { 20 return ListTile( 21 title: Text(index.toString()), 22 ); 23 } 24} 没有移动端的惯性, 可以响应鼠标滚轮上下\n改成横向的\n1 Widget build(BuildContext context) { 2 return Scaffold( 3 appBar: AppBar(), 4 body: ListView.builder( 5 itemBuilder: _buildItem, 6 scrollDirection: Axis.horizontal, 7 ), 8 ); 9 } 横向同样没惯性, shift+滚动可以横向\n图片 网络图片 1import \u0026#39;package:flutter/material.dart\u0026#39;; 2 3class ImagePage extends StatefulWidget { 4 @override 5 _ImagePageState createState() =\u0026gt; _ImagePageState(); 6} 7 8class _ImagePageState extends State\u0026lt;ImagePage\u0026gt; { 9 @override 10 Widget build(BuildContext context) { 11 return Scaffold( 12 appBar: AppBar(), 13 body: ListView( 14 children: \u0026lt;Widget\u0026gt;[ 15 Container( 16 width: 500, 17 height: 500, 18 child: Image.network( 19 \u0026#34;https://raw.githubusercontent.com/kikt-blog/image/master/img/20190704171705.png\u0026#34;), 20 ), 21 ], 22 ), 23 ); 24 } 25} 网络图片可行\n文件 File 的图片, 直接使用本地图片就可以了, 我因为是 mac,所以是这样的,windows 可能是c:\\\\XXXX\\\\XXX\\\\X.jpg\n1Container( 2 width: 500, 3 height: 500, 4 child: Image.file(File(\u0026#34;/Users/cai/Desktop/auto-angle.jpg\u0026#34;)), 5), 内存 memory , 这里需要模拟一下\n读取上面的文件,然后转为 Uint8List\n1Container( 2 width: 500, 3 height: 500, 4 child: Image.memory( 5 Uint8List.fromList( 6 File(\u0026#34;/Users/cai/Desktop/auto-angle.jpg\u0026#34;).readAsBytesSync(), 7 ), 8 ), 9), 资产 asset: 这种方式的加载我印象中去年这个引擎需要使用约定式文件夹, 与 flutter-web 的方式类似\n而现在不需要这种方式了, 直接与 flutter 官方的方式一致,只需要在 pubspec.yaml 中配置即可\n1flutter: 2 # The following line ensures that the Material Icons font is 3 # included with your application, so that you can use the icons in 4 # the material Icons class. 5 uses-material-design: true 6 7 # To add assets to your application, add an assets section, like this: 8 assets: 9 - assets/ 1Container( 2 width: 500, 3 height: 500, 4 child: Image.asset(R.ASSETS_HAVE_EXIF_JPG), 5), 1/// generate by resouce_generator library, shouldn\u0026#39;t edit. 2class R { 3 /// ![preview](file:///private/tmp/flutter-go-example/./assets/have-exif.jpg) 4 static const String ASSETS_HAVE_EXIF_JPG = \u0026#34;assets/have-exif.jpg\u0026#34;; 5} 这里插入一句, 图片会根据 exif 信息旋转至正确的方向 但是图片多了后 ListView 的滚动性能似乎变差了\n输入框 使用 Material 体系的 TextField 作为测试, Cupertino 和 Widget 体系的输入框请自行测试吧\n有如下几个测试方向(有其他的需求可说, 我会加入)\n输入响应 显示行为 系统快捷键 鼠标行为 输入响应 这个很好理解, 就是用键盘能否输入字符... 因为 flutter 上的官方的 plugin 就没法输入(我都是道听途说)\n1import \u0026#39;package:flutter/material.dart\u0026#39;; 2 3class InputPage extends StatefulWidget { 4 @override 5 _InputPageState createState() =\u0026gt; _InputPageState(); 6} 7 8class _InputPageState extends State\u0026lt;InputPage\u0026gt; { 9 @override 10 Widget build(BuildContext context) { 11 return Scaffold( 12 appBar: AppBar(title: Text(\u0026#39;input\u0026#39;)), 13 body: Container( 14 child: TextField(), 15 ), 16 ); 17 } 18} 输入英文还算正常\n试试中文:\n文字位置正常,输入框没跟随\n显示行为 单行没问题, 试试多行, 直接回车不行 我们需要将 TextField 设置为多行, 我这里分别设置 10/50 行\n50 行的话,一页放不下,滚动也算正常 但是这里有一个问题, 中英文混合的情况下, 水滴不正常\n开头和结尾都是英文则没问题, 都是中文同理 系统快捷键+鼠标行为 常用的几个快捷键(复制,粘贴,全选)都是 OK 的, 基本行为和正常的输入框完全吻合,这里要给好评, 比官方桌面引擎好用多了, 其他系统的请自行测试\n鼠标行为顺便一起测试了,基本符合正常的操作习惯\n插件 这个版本的插件和官方的不一样, 需要用 golang 去写, 而不是各自平台的, 当然如果各自平台有特殊的 api, 也需要使用 golang 去调用\n总体有如下几个步骤:\n创建插件 编写代码(go+dart) 引入插件 官方文档在此: 创建并编写插件 go 端 打开 goland, 或者其他的什么编辑器\n具体的 golang 知识没法展开讲解,\n可以理解为在 gopath 的 src 目录下创建一个包, 大部分情况下模仿别人, 建议放在 github.com 目录下\n$ mkdir -p src/github.com/caijinglong/go-flutter-plugin/version\n创建一个目录, 这个就是我插件的文件夹\nversion.go:\n1package version 2 3import ( 4 \u0026#34;github.com/go-flutter-desktop/go-flutter\u0026#34; 5 \u0026#34;github.com/go-flutter-desktop/go-flutter/plugin\u0026#34; 6) 7 8const ( 9 channelName = \u0026#34;top.kikt/go/version\u0026#34; 10 getVersion = \u0026#34;getVersion\u0026#34; 11) 12 13type VersionPlugin struct{} 14 15var _ flutter.Plugin = \u0026amp;VersionPlugin{} 16 17func (VersionPlugin) InitPlugin(messenger plugin.BinaryMessenger) error { 18 channel := plugin.NewMethodChannel(messenger, channelName, plugin.StandardMethodCodec{}) 19 channel.HandleFunc(getVersion, getVersionFunc) 20 return nil; 21} 22 23func getVersionFunc(arguments interface{}) (reply interface{}, err error) { 24 return \u0026#34;0.0.1\u0026#34;, nil 25} 这个文件就是我们的插件, 必须要有的是结构体声明, 初始化插件的方法\n下面那个getVersionFunc就是我们处理的方法, 这里可以使用 golang 编程,返回你需要通过 golang 获取的数据或任何东西, 我这里返回了一个简单的字符串\ndart 端 1import \u0026#39;package:flutter/services.dart\u0026#39;; 2 3class GetVersionPlugin { 4 static const _channel = const MethodChannel(\u0026#34;top.kikt/go/version\u0026#34;); 5 6 static Future\u0026lt;String\u0026gt; get version async =\u0026gt; _channel.invokeMethod(\u0026#34;getVersion\u0026#34;); 7} 发布插件 为了让我们的 flutter 应用可以找到这个插件, 需要一些配置\ngo-flutter 使用的是 go module 的方案管理的 go 包\n我们需要如下几步\n1cd $GOPATH/src/github.com/caijinglong/go-flutter-plugin/version 2export GO111MODULE=on 3go mod init github.com/caijinglong/go-flutter-plugin/version 4go mod tidy 目前我们的目录结构是这样的\n1/Users/cai/code/go/src/github.com/caijinglong/go-flutter-plugin/version 2├── go.mod 3├── go.sum 4└── version.go 要想发布, 其实得发布到 github 上, 这样别人才能访问, 我们目前不这么做, 仅本地使用\n引入插件 这里需要修改 desktop/cmd 目录下的 options.go 文件\n1package main 2 3import ( 4 \u0026#34;github.com/caijinglong/go-flutter-plugin/version\u0026#34; 5 \u0026#34;github.com/go-flutter-desktop/go-flutter\u0026#34; 6) 7 8var options = []flutter.Option{ 9 flutter.WindowInitialDimensions(800, 1280), 10 flutter.AddPlugin(version.VersionPlugin{}), 11} 这时候重新运行下项目会报一个错\n1build github.com/Caijinglong/flutter-go-example/desktop/cmd: cannot load github.com/caijinglong/go-flutter-plugin/version: cannot find module providing package github.com/caijinglong/go-flutter-plugin/version 这个是因为插件没有发布到 github 所致, 我们先在本地测试下, 需要按照官方文档修改一下\n1module github.com/Caijinglong/flutter-go-example/desktop 2 3go 1.12 4 5require ( 6 github.com/go-flutter-desktop/go-flutter v0.24.1 7 github.com/pkg/errors v0.8.1 8 .com/stretchr/objx v0.2.0 // indirect 9) 10 11replace github.com/caijinglong/go-flutter-plugin/version =\u0026gt; /Users/cai/code/go/src/github.com/caijinglong/go-flutter-plugin/version // 添加这行 接着就可以运行了\n运行 代码如下:\n1import \u0026#39;package:flutter/material.dart\u0026#39;; 2 3import \u0026#39;get_version_plugin.dart\u0026#39;; 4 5class PluginPage extends StatefulWidget { 6 @override 7 _PluginPageState createState() =\u0026gt; _PluginPageState(); 8} 9 10class _PluginPageState extends State\u0026lt;PluginPage\u0026gt; { 11 @override 12 Widget build(BuildContext context) { 13 return Scaffold( 14 appBar: AppBar(), 15 body: FutureBuilder\u0026lt;String\u0026gt;( 16 future: GetVersionPlugin.version, 17 builder: (c, snapshot) { 18 if (!snapshot.hasData) { 19 return Container(); 20 } 21 return Text(snapshot.data); 22 }, 23 ), 24 ); 25 } 26} 后记 本章简单使用了一下 go-flutter 项目, 仓库地址: 这里需要注意下, 由于 go 插件的原因,直接 clone 是跑不起来的, 你需要配置 go 以后, 把 go 插件复制到$GOPATH/src/github.com/caijinglong/go-flutter-plugin/version目录内\n后面有时间补测下打包产物\n以上\n","link":"https://kikt.top/posts/flutter/desktop/go-desktop-engine/flutter-go-desktop-1/","section":"posts","tags":["flutter","desktop","go"],"title":"Go Flutter Desktop (一) 初探"},{"body":"","link":"https://kikt.top/tags/exists/","section":"tags","tags":null,"title":"exists"},{"body":"","link":"https://kikt.top/tags/framework/","section":"tags","tags":null,"title":"framework"},{"body":"之前写了一篇关于如何将 flutter 直接打包成 android aar 的文章, 本篇写一写如何将 flutter 打包成 framework 以便于直接让没有 flutter 环境的 iOS 开发者使用, 因为国内很多项目都有这样的要求\n本篇并不会做完全的工程集成化, 只是做一下如何将 flutter 的 framework 打出来, 并且置入到 iOS 原生工程中, 因为各项目一定户会有自己的特殊性, 不可能完全一样\n本篇打包脚本部分参考了 的内容,但是又有一些针对 flutter 版本的变化和 flutter type 不同的情况进行的修改, 不观看连接中的内容并不会影响观看\n开发环境 MacOS\nXCode 10\ngit\nflutter 及 flutter 的相关工具链\ncocoapods\n创建几个工程 iOS 原生工程 使用 xcode 创建 这个原生工程就是模拟你的原有工程\nFlutter 工程 这里我只使用 flutter module 的方式, 如果你 flutter 是 app 的方式创建的,则打包脚本的内容需要根据应用结构有所调整\n$ flutter create -t module flutter_module_for_ios\n这次直接在里面添加一个带有原生功能的插件, 和 android 篇相同依然选择 那个插件\n修改 pubspec.yaml:\n1dependencies: 2 shared_preferences: ^0.5.3+1 创建脚本 观察结构 打包 iOS,然后观察 build 文件夹\n1flutter packages get 2flutter build ios --release --no-codesign 1tree build/ios/Release-iphoneos 2build/ios/Release-iphoneos 3├── FlutterPluginRegistrant 4│ └── libFlutterPluginRegistrant.a 5├── Runner.app 6│ ├── AppIcon20x20@2x.png 7│ ├── AppIcon20x20@2x~ipad.png 8│ ├── AppIcon20x20@3x.png 9│ ├── AppIcon20x20~ipad.png 10│ ├── AppIcon29x29.png 11│ ├── AppIcon29x29@2x.png 12│ ├── AppIcon29x29@2x~ipad.png 13│ ├── AppIcon29x29@3x.png 14│ ├── AppIcon29x29~ipad.png 15│ ├── AppIcon40x40@2x.png 16│ ├── AppIcon40x40@2x~ipad.png 17│ ├── AppIcon40x40@3x.png 18│ ├── AppIcon40x40~ipad.png 19│ ├── AppIcon60x60@2x.png 20│ ├── AppIcon60x60@3x.png 21│ ├── AppIcon76x76@2x~ipad.png 22│ ├── AppIcon76x76~ipad.png 23│ ├── AppIcon83.5x83.5@2x~ipad.png 24│ ├── Assets.car 25│ ├── Base.lproj 26│ │ ├── LaunchScreen.storyboardc 27│ │ │ ├── 01J-lp-oVM-view-Ze5-6b-2t3.nib 28│ │ │ ├── Info.plist 29│ │ │ └── UIViewController-01J-lp-oVM.nib 30│ │ └── Main.storyboardc 31│ │ ├── BYZ-38-t0r-view-8bC-Xf-vdC.nib 32│ │ ├── Info.plist 33│ │ └── UIViewController-BYZ-38-t0r.nib 34│ ├── Debug.xcconfig 35│ ├── Flutter.xcconfig 36│ ├── Frameworks 37│ │ ├── App.framework 38│ │ │ ├── App 39│ │ │ ├── Info.plist 40│ │ │ └── flutter_assets 41│ │ │ ├── AssetManifest.json 42│ │ │ ├── FontManifest.json 43│ │ │ ├── LICENSE 44│ │ │ ├── fonts 45│ │ │ │ └── MaterialIcons-Regular.ttf 46│ │ │ └── packages 47│ │ │ └── cupertino_icons 48│ │ │ └── assets 49│ │ │ └── CupertinoIcons.ttf 50│ │ └── Flutter.framework 51│ │ ├── Flutter 52│ │ ├── Info.plist 53│ │ └── icudtl.dat 54│ ├── Info.plist 55│ ├── PkgInfo 56│ ├── Release.xcconfig 57│ └── Runner 58├── Runner.app.dSYM 59│ └── Contents 60│ ├── Info.plist 61│ └── Resources 62│ └── DWARF 63│ └── Runner 64├── libPods-Runner.a 65└── shared_preferences 66 └── libshared_preferences.a 67 6818 directories, 46 files 发现打包出来的是.a 文件, 这里我们需要修改一下 ios 目录下的文件, 以便于打包出来 framework 文件, 因为 framework 是 apple 提供的一种打包方案, 直接将所有需要的资源包括头文件,库文件都聚集到了一起,方便引用, 而.a 文件就不一样了, 还需要包含对应的头文件\n修改.ios 下的 podfile\n在第一行添加这个\n1use_frameworks! 然后先清除一下刚刚打包的内容 $ flutter clean\n1flutter build ios --release --no-codesign 1tree build/ios/Release-iphoneos 2build/ios/Release-iphoneos 3├── FlutterPluginRegistrant 4│ ├── FlutterPluginRegistrant.framework 5│ │ ├── FlutterPluginRegistrant 6│ │ ├── Headers 7│ │ │ ├── FlutterPluginRegistrant-umbrella.h 8│ │ │ └── GeneratedPluginRegistrant.h 9│ │ ├── Info.plist 10│ │ └── Modules 11│ │ └── module.modulemap 12│ └── FlutterPluginRegistrant.framework.dSYM 13│ └── Contents 14│ ├── Info.plist 15│ └── Resources 16│ └── DWARF 17│ └── FlutterPluginRegistrant 18├── Pods_Runner.framework 19│ ├── Headers 20│ │ └── Pods-Runner-umbrella.h 21│ ├── Info.plist 22│ ├── Modules 23│ │ └── module.modulemap 24│ └── Pods_Runner 25├── Runner.app 26│ ├── AppIcon20x20@2x.png 27│ ├── AppIcon20x20@2x~ipad.png 28│ ├── AppIcon20x20@3x.png 29│ ├── AppIcon20x20~ipad.png 30│ ├── AppIcon29x29.png 31│ ├── AppIcon29x29@2x.png 32│ ├── AppIcon29x29@2x~ipad.png 33│ ├── AppIcon29x29@3x.png 34│ ├── AppIcon29x29~ipad.png 35│ ├── AppIcon40x40@2x.png 36│ ├── AppIcon40x40@2x~ipad.png 37│ ├── AppIcon40x40@3x.png 38│ ├── AppIcon40x40~ipad.png 39│ ├── AppIcon60x60@2x.png 40│ ├── AppIcon60x60@3x.png 41│ ├── AppIcon76x76@2x~ipad.png 42│ ├── AppIcon76x76~ipad.png 43│ ├── AppIcon83.5x83.5@2x~ipad.png 44│ ├── Assets.car 45│ ├── Base.lproj 46│ │ ├── LaunchScreen.storyboardc 47│ │ │ ├── 01J-lp-oVM-view-Ze5-6b-2t3.nib 48│ │ │ ├── Info.plist 49│ │ │ └── UIViewController-01J-lp-oVM.nib 50│ │ └── Main.storyboardc 51│ │ ├── BYZ-38-t0r-view-8bC-Xf-vdC.nib 52│ │ ├── Info.plist 53│ │ └── UIViewController-BYZ-38-t0r.nib 54│ ├── Debug.xcconfig 55│ ├── Flutter.xcconfig 56│ ├── Frameworks 57│ │ ├── App.framework 58│ │ │ ├── App 59│ │ │ ├── Info.plist 60│ │ │ └── flutter_assets 61│ │ │ ├── AssetManifest.json 62│ │ │ ├── FontManifest.json 63│ │ │ ├── LICENSE 64│ │ │ ├── fonts 65│ │ │ │ └── MaterialIcons-Regular.ttf 66│ │ │ └── packages 67│ │ │ └── cupertino_icons 68│ │ │ └── assets 69│ │ │ └── CupertinoIcons.ttf 70│ │ ├── Flutter.framework 71│ │ │ ├── Flutter 72│ │ │ ├── Info.plist 73│ │ │ └── icudtl.dat 74│ │ ├── FlutterPluginRegistrant.framework 75│ │ │ ├── FlutterPluginRegistrant 76│ │ │ └── Info.plist 77│ │ └── shared_preferences.framework 78│ │ ├── Info.plist 79│ │ └── shared_preferences 80│ ├── Info.plist 81│ ├── PkgInfo 82│ ├── Release.xcconfig 83│ └── Runner 84├── Runner.app.dSYM 85│ └── Contents 86│ ├── Info.plist 87│ └── Resources 88│ └── DWARF 89│ └── Runner 90└── shared_preferences 91 ├── shared_preferences.framework 92 │ ├── Headers 93 │ │ ├── SharedPreferencesPlugin.h 94 │ │ └── shared_preferences-umbrella.h 95 │ ├── Info.plist 96 │ ├── Modules 97 │ │ └── module.modulemap 98 │ └── shared_preferences 99 └── shared_preferences.framework.dSYM 100 └── Contents 101 ├── Info.plist 102 └── Resources 103 └── DWARF 104 └── shared_preferences 105 10637 directories, 65 files Runner.app 这个熟悉的名字下虽然看似包含所有的 framework,但是仔细观察, 这些 framework 内不包含头文件, 所以其实是用不了的\n可以使用的是如图所示的几个\n根据上面的 tree 图可以看到,其中包含了全部的库文件, 但除此以外,还需要两个库:\nApp.framework: 这个包含了 flutter 的资源 Flutter.framework: 这个是 Flutter 的 engine 运行库, 每个 flutter 应用必然有的东西 这两个东西需要从.ios 中找到\nApp.framework: .ios/Flutter/App.framework Flutter.framework: .ios/Flutter/engine/Flutter.framework 这样就集齐了所有的库文件, 问题是, 这样是手动做的, 我们需要一个自动化的方案把重复的工作都完成\n所以我根据开头的文章内的脚本编写了一个脚本:\n1if [ -z $out ]; then 2 out=\u0026#39;ios_frameworks\u0026#39; 3fi 4 5echo \u0026#34;准备输出所有文件到目录: $out\u0026#34; 6 7find . -d -name build | xargs rm -rf 8flutter clean 9rm -rf $out 10rm -rf build 11 12flutter packages get 13flutter build ios --release --no-codesign 14 15mkdir $out 16 17cp -r build/ios/Release-iphoneos/*/*.framework $out 18cp -r .ios/Flutter/App.framework $out 19cp -r .ios/Flutter/engine/Flutter.framework $out 接着可以通过sh build_ios.sh 来自动打包,并且将所有文件复制到 ios_frameword 目录下, 嗯 这个目录可以通过 out=ios_out sh build_ios.sh来改变\n关联库文件和工程 原生工程的管理方式有很多种, 比如只使用 xcode 来管理\ncocoapod(支持 oc 和 swift)\n单独针对 swift 还有 Carthage, Swift Package Manager\n当然这里我还是用 cocoapod 的方案, 其他的方案请自行研究\n使用 cocoapod 管理原生工程 为原生工程添加一个 Podfile\n1cd top.kikt.existsapp 2touch Podfile 3code Podfile # 这一步是用 vscode 打开 你也可以用 vim 或其他任何文本编辑器 修改 Podfile\n1platform :ios, \u0026#39;8.0\u0026#39; 2use_frameworks! 3 4target \u0026#39;top.kikt.existsapp\u0026#39; do 5 6end 然后继续在命令行里 $ pod install\n如果没有报错, 则说明原生项目现在已经被 pod 管理了\n将 framework 作为一个 pod 库 因为找遍了 podfile 的相关文档, 没有找到可以直接引用 framework 的方式\n所以需要一个 pod 库作为\u0026quot;中转\u0026quot;\n新建一个库 $ pod lib create flutter-lib, 然后按顺序回答问题, 这目录根据你自己的实际情况来\n我的是和 iOS 原生同级目录\n1$ pod lib create flutter-lib 2Cloning `https://github.com/CocoaPods/pod-template.git` into `flutter-lib`. 3Configuring flutter-lib template. 4 5------------------------------ 6 7To get you started we need to ask a few questions, this should only take a minute. 8 9If this is your first time we recommend running through with the guide: 10 - https://guides.cocoapods.org/making/using-pod-lib-create.html 11 ( hold cmd and double click links to open in a browser. ) 12 13 14What platform do you want to use?? [ iOS / macOS ] 15 \u0026gt; 16ios 17What language do you want to use?? [ Swift / ObjC ] 18 \u0026gt; objc 19 20Would you like to include a demo application with your library? [ Yes / No ] 21 \u0026gt; no 22 23Which testing frameworks will you use? [ Specta / Kiwi / None ] 24 \u0026gt; none 25 26Would you like to do view based testing? [ Yes / No ] 27 \u0026gt; no 28 29What is your class prefix? 30 \u0026gt; 31 32You need to provide an answer. 33What is your class prefix? 34 \u0026gt; FFF 35 36Running pod install on your new library. 37 38Analyzing dependencies 39Fetching podspec for `flutter-lib` from `../` 40Downloading dependencies 41Installing flutter-lib (0.1.0) 42Generating Pods project 43Integrating client project 44 45[!] Please close any current Xcode sessions and use `flutter-lib.xcworkspace` for this project from now on. 46Sending stats 47Pod installation complete! There is 1 dependency from the Podfile and 1 total pod installed. 48 49[!] Automatically assigning platform `ios` with version `9.3` on target `flutter-lib_Tests` because no platform was specified. Please specify a platform for this target in your Podfile. See `https://guides.cocoapods.org/syntax/podfile.html#platform`. 50 51 Ace! you\u0026#39;re ready to go! 52 We will start you off by opening your project in Xcode 53 open \u0026#39;flutter-lib/Example/flutter-lib.xcworkspace\u0026#39; 54 55To learn more about the template see `https://github.com/CocoaPods/pod-template.git`. 56To learn more about creating a new pod, see `https://guides.cocoapods.org/making/making-a-cocoapod`. 创建完成后, 修改 flutter-lib.podspec 文件\n这里需要先把刚刚的 framework 复制到项目中\n默认有一堆注释都可以删掉\n然后添加这么一行\n1s.ios.vendored_frameworks = \u0026#39;ios_frameworks/App.framework\u0026#39;, \u0026#39;ios_frameworks/Flutter.framework\u0026#39;, \u0026#39;ios_frameworks/FlutterPluginRegistrant.framework\u0026#39;, \u0026#39;ios_frameworks/shared_preferences.framework\u0026#39; 这个方案是临时的, 后面肯定会写成动态查找的方案, 不可能有一个库写一次\n现在我的 podspec 文件是这样的\n1Pod::Spec.new do |s| 2 s.name = \u0026#39;flutter-lib\u0026#39; 3 s.version = \u0026#39;0.1.0\u0026#39; 4 s.summary = \u0026#39;A short description of flutter-lib.\u0026#39; 5 s.description = \u0026lt;\u0026lt;-DESC 6TODO: Add long description of the pod here. 7 DESC 8 9 s.homepage = \u0026#39;https://github.com/cjl_spy@163.com/flutter-lib\u0026#39; 10 s.license = { :type =\u0026gt; \u0026#39;MIT\u0026#39;, :file =\u0026gt; \u0026#39;LICENSE\u0026#39; } 11 s.author = { \u0026#39;cjl_spy@163.com\u0026#39; =\u0026gt; \u0026#39;cjl_spy@163.com\u0026#39; } 12 s.source = { :git =\u0026gt; \u0026#39;https://github.com/cjl_spy@163.com/flutter-lib.git\u0026#39;, :tag =\u0026gt; s.version.to_s } 13 s.ios.deployment_target = \u0026#39;8.0\u0026#39; 14 s.static_framework = true 15 # s.source_files = \u0026#39;flutter-lib/Classes/**/*\u0026#39; 16 s.ios.vendored_frameworks = \u0026#39;ios_frameworks/App.framework\u0026#39;, \u0026#39;ios_frameworks/Flutter.framework\u0026#39;, \u0026#39;ios_frameworks/FlutterPluginRegistrant.framework\u0026#39;, \u0026#39;ios_frameworks/shared_preferences.framework\u0026#39; 17end 在原生项目中引用这个库 1platform :ios, \u0026#39;8.0\u0026#39; 2use_frameworks! 3 4target \u0026#39;top.kikt.existsapp\u0026#39; do 5 pod \u0026#39;flutter-lib\u0026#39;, :path =\u0026gt; \u0026#39;../flutter-lib\u0026#39; 6end 接着在原生项目中$ pod install\n运行项目可能会有两种错误:\n信息包含什么 System 之类的, 这个是需要修改构建系统\n运行项目还可能会报一个 bitcode 的错误, 这里需要修改一个选项 将这里修改为 NO\n我的项目目前为止能跑起来不报错了, 但是目前项目还没有启动 Flutter 的页面, 到这一步后我是按照 进行修改的\n我给的例子仅有 oc 的,swift 的请自行参考 wiki\n修改AppDelegate.h\n1#import \u0026lt;UIKit/UIKit.h\u0026gt; 2#import \u0026lt;Flutter/Flutter.h\u0026gt; 3 4@interface AppDelegate : FlutterAppDelegate 5@property (nonatomic,strong) FlutterEngine *flutterEngine; 6@end AppDelegate.m\n1#import \u0026lt;FlutterPluginRegistrant/GeneratedPluginRegistrant.h\u0026gt; // Only if you have Flutter Plugins 2 3#include \u0026#34;AppDelegate.h\u0026#34; 4 5@implementation AppDelegate 6 7// This override can be omitted if you do not have any Flutter Plugins. 8- (BOOL)application:(UIApplication *)application 9 didFinishLaunchingWithOptions:(NSDictionary *)launchOptions { 10 self.flutterEngine = [[FlutterEngine alloc] initWithName:@\u0026#34;io.flutter\u0026#34; project:nil]; 11 [self.flutterEngine runWithEntrypoint:nil]; 12 [GeneratedPluginRegistrant registerWithRegistry:self.flutterEngine]; 13 return [super application:application didFinishLaunchingWithOptions:launchOptions]; 14} 15 16@end 接着就是启动 Flutter 的事情了, 这个根据你业务逻辑自行实现, 核心代码是如下几行\n1#import \u0026lt;Flutter/Flutter.h\u0026gt; 2#import \u0026#34;AppDelegate.h\u0026#34; 3#import \u0026#34;ViewController.h\u0026#34; 4 5@implementation ViewController 6- (void)viewDidLoad { 7 [super viewDidLoad]; 8 UIButton *button = [UIButton buttonWithType:UIButtonTypeCustom]; 9 [button addTarget:self 10 action:@selector(handleButtonAction) 11 forControlEvents:UIControlEventTouchUpInside]; 12 [button setTitle:@\u0026#34;Press me\u0026#34; forState:UIControlStateNormal]; 13 [button setBackgroundColor:[UIColor blueColor]]; 14 button.frame = CGRectMake(80.0, 210.0, 160.0, 40.0); 15 [self.view addSubview:button]; 16} 17 18- (void)handleButtonAction { 19 FlutterEngine *flutterEngine = [(AppDelegate *)[[UIApplication sharedApplication] delegate] flutterEngine]; 20 FlutterViewController *flutterViewController = [[FlutterViewController alloc] initWithEngine:flutterEngine nibName:nil bundle:nil]; 21 [self presentViewController:flutterViewController animated:false completion:nil]; 22} 23@end 优化脚本 优化 podspec 文件 这一步的目的是, 遍历文件夹, 不再单独的每个引用 framework 文件\npodspec 使用的是 ruby 语法, 也就是说本身就支持编程, 这时候如果再用 shell 或者 dart 就有点增加复杂度了\n如果不了解 ruby 语法, 你也可以用自己的方法解决(shell,python,dart 什么都随你), 我也是边写边看的 ruby 语法, 按照如下方式修改\n1Pod::Spec.new do |s| 2 s.name = \u0026#39;flutter-lib\u0026#39; 3 s.version = \u0026#39;0.1.0\u0026#39; 4 s.summary = \u0026#39;A short description of flutter-lib.\u0026#39; 5 s.description = \u0026lt;\u0026lt;-DESC 6TODO: Add long description of the pod here. 7 DESC 8 9 s.homepage = \u0026#39;https://github.com/cjl_spy@163.com/flutter-lib\u0026#39; 10 s.license = { :type =\u0026gt; \u0026#39;MIT\u0026#39;, :file =\u0026gt; \u0026#39;LICENSE\u0026#39; } 11 s.author = { \u0026#39;cjl_spy@163.com\u0026#39; =\u0026gt; \u0026#39;cjl_spy@163.com\u0026#39; } 12 s.source = { :git =\u0026gt; \u0026#39;https://github.com/cjl_spy@163.com/flutter-lib.git\u0026#39;, :tag =\u0026gt; s.version.to_s } 13 s.ios.deployment_target = \u0026#39;8.0\u0026#39; 14 s.static_framework = true 15 # s.source_files = \u0026#39;flutter-lib/Classes/**/*\u0026#39; 16 p = Dir::open(\u0026#34;ios_frameworks\u0026#34;) 17 arr = Array.new 18 p.each do |f| 19 if f == \u0026#39;.\u0026#39; || f == \u0026#39;..\u0026#39; 20 else 21 arr.push(\u0026#39;ios_frameworks/\u0026#39;+f) 22 end 23 end 24 25 s.ios.vendored_frameworks = arr 26end 然后执行 pod install\n优化 shell 脚本 1if [ -z $out ]; then 2 out=\u0026#39;ios_frameworks\u0026#39; 3fi 4 5echo \u0026#34;准备输出所有文件到目录: $out\u0026#34; 6 7find . -d -name build | xargs rm -rf 8flutter clean 9rm -rf $out 10rm -rf build 11 12flutter packages get 13flutter build ios --release --no-codesign 14 15mkdir $out 16 17cp -r build/ios/Release-iphoneos/*/*.framework $out 18cp -r .ios/Flutter/App.framework $out 19cp -r .ios/Flutter/engine/Flutter.framework $out 20 21cp -r $out ../flutter-lib/ios_frameworks # 添加这步 验证下别的插件 添加插件到 pubspec.yaml\n1dependencies: 2 path_provider: ^1.1.0 $ flutter pub get\n这里有个小坑,当添加了 pubspec 插件后, flutter/.ios/Podfile 的内容会被恢复成默认状态\n所以需要再修改一下 shell 脚本:\n1if [ -z $out ]; then 2 out=\u0026#39;ios_frameworks\u0026#39; 3fi 4 5echo \u0026#34;准备输出所有文件到目录: $out\u0026#34; 6 7echo \u0026#34;清除所有已编译文件\u0026#34; 8find . -d -name build | xargs rm -rf 9flutter clean 10rm -rf $out 11rm -rf build 12 13flutter packages get 14 15addFlag(){ 16 cat .ios/Podfile \u0026gt; tmp1.txt 17 echo \u0026#34;use_frameworks!\u0026#34; \u0026gt;\u0026gt; tmp2.txt 18 cat tmp1.txt \u0026gt;\u0026gt; tmp2.txt 19 cat tmp2.txt \u0026gt; .ios/Podfile 20 rm tmp1.txt tmp2.txt 21} 22 23echo \u0026#34;检查 .ios/Podfile文件状态\u0026#34; 24a=$(cat .ios/Podfile) 25if [[ $a == use* ]]; then 26 echo \u0026#39;已经添加use_frameworks, 不再添加\u0026#39; 27else 28 echo \u0026#39;未添加use_frameworks,准备添加\u0026#39; 29 addFlag 30 echo \u0026#34;添加use_frameworks 完成\u0026#34; 31fi 32 33echo \u0026#34;编译flutter\u0026#34; 34flutter build ios --release --no-codesign 35 36echo \u0026#34;编译flutter完成\u0026#34; 37mkdir $out 38 39cp -r build/ios/Release-iphoneos/*/*.framework $out 40cp -r .ios/Flutter/App.framework $out 41cp -r .ios/Flutter/engine/Flutter.framework $out 42 43echo \u0026#34;复制framework库到临时文件夹: $out\u0026#34; 44 45libpath=\u0026#39;../flutter-lib\u0026#39; 46 47rm -rf \u0026#34;$libpath/ios_frameworks\u0026#34; 48mkdir $libpath 49cp -r $out $libpath 50 51echo \u0026#34;复制库文件到: $libpath\u0026#34; 顺便润色了一下,加了一点日志\n运行下项目, 跑了一下, 果然没有问题了\n这里有一个插曲请注意,我脚本里用了 gsed 命令,这个工具是 GNU-sed 的缩写, 因为 mac 的 sed 命令有一些问题比较难用\n请使用$ brew install gnu-sed安装一下, 否则这个命令可能失败\n备注: 因为有反馈, gsed 在不同的 mac 上会出现把文本变成一行的问题, 现在采用另一种方案,不再需要 gsed\n总结 建议: 请将 flutter,原生和 flutter 的 framework 所在的 pod 库作为 3 个单独的库,便于管理(有 pod 的私服请按照自己的方案实现 framework 的共享)\n然后脚本中的目录什么的需要根据你的实际情况进行调整\n打包的使用总结 flutter 方:\n创建一个 pod 库 使用脚本打包并把所有的文件复制到 pod 库内 git commit + push ios 方:\ngit pull pod install run 后记 到目前为止, iOS 也算是完成了加入到已有工程, 原生方只使用 pod+git 理论上就达到了可以不用 flutter 依然可运行的目的\n仓库看这里: 以上\n","link":"https://kikt.top/posts/flutter/exists/add-flutter-to-ios/","section":"posts","tags":["flutter","ios","exists","framework"],"title":"把flutter作为framework添加到已存在的iOS中"},{"body":"","link":"https://kikt.top/tags/docker/","section":"tags","tags":null,"title":"docker"},{"body":"","link":"https://kikt.top/tags/%E5%B7%B2%E6%9C%89%E9%A1%B9%E7%9B%AE/","section":"tags","tags":null,"title":"已有项目"},{"body":"对于已有工程想要尝鲜 Flutter, 很多公司给出了最佳实践方案, android 中是使用 aar 加入项目中, 这样原生开发对于 flutter 环境就没有要求了, 只要 flutter 打包后上传 maven 即可, 但是这部分的过程坑很多, 后面我会再补充这种方案\n我也摸索了一个实践方案, 将所有项目的 aar 由 flutter 方打包 aar 后将 aar 置入某一个固定位置 ,并置入一个 git 库管理, 然后 android 原生方直接 pull 后引入项目即可\n高能预警: 本篇会结合 flutter, android, aar, gradle, maven, docker 的知识来完成所有的步骤\n并不是每一个都会详细说明, 如果有不明白的可以在 的本文下面留言, 我会更新文章或给予解答, 其他渠道的可能不会有时间看\n开发环境 本人设备环境 MacOS 10.13.6 (17G65)\nflutter: Flutter 1.5.4-hotfix.2 • channel stable\n12019-10-25 更新说明: 这篇文章因为发布时效的原因, 当时还没有 `$ flutter build aar` 这个命令 2所以本人并没有实测两个东西的优劣性 预计需要的环境 1xcode 2android sdk 3gradle 4android studio 5flutter sdk 6docker # 这个 这些环境我默认你都有, 没有的话本篇不讲\nwindows 用户? 对不住, 自己找寻其中的差别吧...\nflutter 创建 flutter module 使用命令行创建:\n$ flutter create -t module flutter_module\n1cd flutter_module 2flutter build apk 这里理论上会生成一个 aar\n1tree .android/Flutter/build/outputs 2.android/Flutter/build/outputs 3├── aar 4│ └── flutter-release.aar 5└── logs 6 └── manifest-merger-release-report.txt 嗯,就这个东西\n我们其实可以直接把这个 aar 放在宿主中,然后通过配置 aar 本地引用来直接使用这个工程, 但是这样可能并不利于持续集成\n所以我们要用到 maven 这个利器\nps: 这里有个坑, 就是纯 flutter 项目可以, 但是如果你的 flutter 项目包含了对于第三方项目的依赖, 则 aar 可能不会包含其他的内容, 我们放在最后面再想办法解决\nmaven 的处理方式(看看就行,作为错误尝试的步骤) 本篇主要讲的是 maven 的方式, 没有原生 plugin 的很简单, 但是有原生 plugin 的 flutter 步骤过于复杂, 最终没实现, 当然理论上肯定是可以实现的\n因为本篇讲解的是本人解决 flutter 附着到已有工程的尝试,所以将放弃的过程也记录下来, 如果你只是想看最终的实现方案可以跳过本篇和后续所有涉及到 maven 的步骤\nmaven 是一个包管理工具\n如果你公司有自己的私服, 则跳过这一章直接看下一章, 我这里只是使用 docker 创建一个 maven 私服环境\n使用的镜像是 sonatype/nexus3\n配置 可选: $ docker pull sonatype/nexus3\n我比较熟悉的有两种方式:\n命令行直接运行\n1docker run --name test_nexus -d -p 8099:8081 -v /Volumes/Evo512/docker/nexus/nexus-data:/nexus-data sonatype/nexus3 使用 docker-compose\n1version: \u0026#39;2\u0026#39; 2 3services: 4 my-nexus: 5 image: sonatype/nexus3 6 ports: 7 - 8099:8081 8 networks: 9 - nexus-net 10 volumes: 11 - /Volumes/Evo512/docker/nexus/nexus-data:/nexus-data 12 13networks: 14 nexus-net: 15 driver: bridge 1docker-compose -d up 使用 docker-compose 就是类似于配置文件的方式\n运行 在浏览器打开 http://localhost:8099\n登录的用户名密码,默认是 admin admin123\n点开 maven, 毛也没有\n上传 aar 使用 gradle 上传 aar 使用 android studio 打开 flutter_module 下的.android 目录, 经过一顿同步得到的可能是这样的: 一片空白毛都没有...\n这时候请 close, 重新打开, 现在是这个鬼样子的\n采用 project 视图模式\n在.android 下增加一个 gradle 文件,名字自取\n比如我的就叫 update_aar.gradle\n1apply plugin: \u0026#39;maven\u0026#39; 2 3def GROUP = \u0026#39;top.kikt.flutter_lib\u0026#39; 4def ARTIFACT_ID = \u0026#39;module_example\u0026#39; 5def VERSION_NAME = \u0026#34;1.0.0\u0026#34; 6 7def SNAPSHOT_REPOSITORY_URL = \u0026#39;http://localhost:8099/repository/maven-snapshots/\u0026#39; 8def RELEASE_REPOSITORY_URL = \u0026#39;http://localhost:8099/repository/maven-releases/\u0026#39; 9def REPOSITORY_URL = VERSION_NAME.toUpperCase().endsWith(\u0026#34;-SNAPSHOT\u0026#34;) ? SNAPSHOT_REPOSITORY_URL : RELEASE_REPOSITORY_URL 10 11 12def NEXUS_USERNAME = \u0026#39;admin\u0026#39; 13def NEXUS_PASSWORD = \u0026#39;admin123\u0026#39; 14 15afterEvaluate { project -\u0026gt; 16 uploadArchives { 17 repositories { 18 mavenDeployer { 19 pom.groupId = GROUP 20 pom.artifactId = ARTIFACT_ID 21 pom.version = VERSION_NAME 22 repository(url: REPOSITORY_URL) { 23 authentication(userName: NEXUS_USERNAME, password: NEXUS_PASSWORD) 24 } 25 } 26 } 27 } 28 task androidJavadocs(type: Javadoc) { 29 source = android.sourceSets.main.java.srcDirs 30 classpath += project.files(android.getBootClasspath().join(File.pathSeparator)) 31 } 32 task androidJavadocsJar(type: Jar, dependsOn: androidJavadocs) { 33 classifier = \u0026#39;javadoc\u0026#39; 34 from androidJavadocs.destinationDir 35 } 36 task androidSourcesJar(type: Jar) { 37 classifier = \u0026#39;sources\u0026#39; 38 from android.sourceSets.main.java.sourceFiles 39 } 40 41 //解决 JavaDoc 中文注释生成失败的问题 42 tasks.withType(Javadoc) { 43 options.addStringOption(\u0026#39;Xdoclint:none\u0026#39;, \u0026#39;-quiet\u0026#39;) 44 options.addStringOption(\u0026#39;encoding\u0026#39;, \u0026#39;UTF-8\u0026#39;) 45 options.addStringOption(\u0026#39;charSet\u0026#39;, \u0026#39;UTF-8\u0026#39;) 46 } 47 artifacts { 48 archives androidSourcesJar 49 archives androidJavadocsJar 50 } 51} 这个文件呢, 就是上传用的 gradle 文件, 来源于\n前几个 def 要根据你的 maven 来修改, 包名, 端口, 用户名,密码\n接着引入 gradle 文件到项目中\n修改: Flutter/build.gradle\n1android{ 2 /// .... 3} 4 5apply from: \u0026#34;${rootDir.path}/update_aar.gradle\u0026#34; 按照下图点击 可能会报错\n111:58:23: Executing task \u0026#39;uploadArchives\u0026#39;... 2 3Executing tasks: [uploadArchives] 4 5 6FAILURE: Build failed with an exception. 7 8* Where: 9Settings file \u0026#39;/Volumes/Evo512/code/flutter/add_to_exists_android/flutter_module/.android/settings.gradle\u0026#39; line: 7 10 11* What went wrong: 12A problem occurred evaluating settings \u0026#39;android_generated\u0026#39;. 13\u0026gt; /Volumes/Evo512/code/flutter/add_to_exists_android/flutter_module/.android/Flutter/include_flutter.groovy (/Volumes/Evo512/code/flutter/add_to_exists_android/flutter_module/.android/Flutter/include_flutter.groovy) 14 15* Try: 16Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output. Run with --scan to get full insights. 17 18* Get more help at https://help.gradle.org 19 20BUILD FAILED in 0s 2111:58:23: Task execution finished \u0026#39;uploadArchives\u0026#39;. 似乎是由于路径不对的原因, 请使用如下的方式修改 setting.gradle:\n1// Generated file. Do not edit. 2include \u0026#39;:app\u0026#39; 3 4rootProject.name = \u0026#39;android_generated\u0026#39; 5setBinding(new Binding([gradle: this])) 6//evaluate(new File(\u0026#39;include_flutter.groovy\u0026#39;)) 7evaluate(new File(\u0026#34;$rootDir.path/include_flutter.groovy\u0026#34;)) 同步 gradle 后\n接着双击 就可以上传成功了\n然后打开 nexus 查看: http://localhost:8099/#browse/search/maven\n有显示, 说明这个 aar 上传是成功的\n后面再上传更改版本号即可\nAndroid 项目(host) 新建项目 引入 maven 依赖 添加仓库 根目录 build.gradle, 根据节点增加一个 maven 仓库:\n1allprojects { 2 repositories { 3 google() 4 jcenter() 5 maven { 6 url \u0026#39;http://localhost:8099/repository/maven-releases/\u0026#39; 7 } 8 } 9} 引入库, 在 nexus 的管理界面里可以查看引用方式:\n接着在app/build.gradle中修改\n1 2dependencies { 3 // ... 4 implementation \u0026#39;top.kikt.flutter_lib:module_example:1.0.0\u0026#39; 5} 经过 sync 以后,使用 project 视图, 可以找到这个库:\n编码 新建 MyFlutterActivity.java\n1package top.kikit.androidhost; 2 3import android.os.Bundle; 4 5import io.flutter.app.FlutterActivity; 6import io.flutter.plugins.GeneratedPluginRegistrant; 7 8/// create 2019-06-14 by cai 9 10public class MyFlutterActivity extends FlutterActivity { 11 12 @Override 13 protected void onCreate(Bundle savedInstanceState) { 14 super.onCreate(savedInstanceState); 15 GeneratedPluginRegistrant.registerWith(this); 16 } 17} 添加到清单文件\n1\u0026lt;application\u0026gt; 2 \u0026lt;activity android:name=\u0026#34;.MyFlutterActivity\u0026#34; /\u0026gt; 3\u0026lt;/application\u0026gt; 修改 MainActivity.java\n1package top.kikit.androidhost; 2 3import android.content.Intent; 4import android.os.Bundle; 5 6import androidx.appcompat.app.AppCompatActivity; 7 8public class MainActivity extends AppCompatActivity { 9 10 @Override 11 protected void onCreate(Bundle savedInstanceState) { 12 super.onCreate(savedInstanceState); 13 setContentView(R.layout.activity_main); 14 Flutter.startInitialization(this.getApplicationContext()); 15 Intent intent = new Intent(this, MyFlutterActivity.class); 16 startActivity(intent); 17 } 18} 这里模拟一进来直接进 FlutterActivity 的场景\n建议你的 Android 同事在合适的时机调用 Flutter.startInitialization(this.getApplicationContext()); 这个是官方给出的初始化 flutter 引擎的代码, 否则首屏可能会慢\n运行项目 初次运行可能会报错 提示一个 androidO 什么的玩意\n两种方案\nminSDK 修改为 26, 这个简直不科学 在 app/build.gradle 下的 android 节点下增加这个代码 1android{ 2 compileOptions { 3 sourceCompatibility 1.8 4 targetCompatibility 1.8 5 } 6} 将源码和目标代码等级都设置为 1.8\n嗯 这里插一句, 我的 host 使用的是 androidX, 而 flutter 使用的是 android.support, 所以需要按照 androidX 的迁移流程修改一下, 如果你新建项目的时候勾选了 androidX, 则这里应该不用修改\nandroidX 的问题可以查看我的, 虽然是 flutter 分类下的,但是对于普通 android 工程也适用\n运行结果如下: 在 flutter 中添加带有原生功能的库 这里注意!!!!!!, 请先备份前面几个文件\n这里注意!!!!!!, 请先备份前面几个文件\n这里注意!!!!!!, 请先备份前面几个文件\n这里注意!!!!!!, 请先备份前面几个文件\n这里注意!!!!!!, 请先备份前面几个文件\n这里注意!!!!!!, 请先备份前面几个文件\n这里注意!!!!!!, 请先备份前面几个文件\n这里注意!!!!!!, 请先备份前面几个文件\n因为一旦 flutter packages get, 则 前面的文件就木有了\n在 flutter 中添加库 这里简单举例一下, 使用一个比较常用的shared_preferences\n修改 flutter 的 yaml 文件\n1dependencies: 2 shared_preferences: ^0.5.3+1 $ flutter packages get\n这一步后, 之前的那几个文件没有了...\n建议: 把 build.gradle 和 setting.gradle 复制到 module 级别的某个目录下, 比如叫 template\n然后用脚本来做这个上传的事情\n复制模板到对应目录 通过环境变量设置 aar 的版本号 使用 gradle 命令来完成插件的调用 上传新版本的 aar 修改版本号为 1.0.1\n这里上传成功了\n到 android host 中用了一下, 果不其然和网上的朋友们说的一样报错了\n1ERROR: Unable to resolve dependency for \u0026#39;:app@debug/compileClasspath\u0026#39;: Could not resolve io.flutter.plugins.sharedpreferences:shared_preferences:1.0-SNAPSHOT. 2Show Details 3Affected Modules: app 4 5 6ERROR: Unable to resolve dependency for \u0026#39;:app@debugAndroidTest/compileClasspath\u0026#39;: Could not resolve io.flutter.plugins.sharedpreferences:shared_preferences:1.0-SNAPSHOT. 7Show Details 8Affected Modules: app 9 10 11ERROR: Unable to resolve dependency for \u0026#39;:app@debugUnitTest/compileClasspath\u0026#39;: Could not resolve io.flutter.plugins.sharedpreferences:shared_preferences:1.0-SNAPSHOT. 12Show Details 13Affected Modules: app 查看对应的 pom.xml(我这里是 1.0.2),道理是一样的\n1\u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; 2 xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; 3 \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; 4 \u0026lt;groupId\u0026gt;top.kikt.flutter_lib\u0026lt;/groupId\u0026gt; 5 \u0026lt;artifactId\u0026gt;module_example\u0026lt;/artifactId\u0026gt; 6 \u0026lt;version\u0026gt;1.0.2\u0026lt;/version\u0026gt; 7 \u0026lt;packaging\u0026gt;aar\u0026lt;/packaging\u0026gt; 8 \u0026lt;dependencies\u0026gt; 9 \u0026lt;dependency\u0026gt; 10 \u0026lt;groupId\u0026gt;io.flutter.plugins.sharedpreferences\u0026lt;/groupId\u0026gt; 11 \u0026lt;artifactId\u0026gt;shared_preferences\u0026lt;/artifactId\u0026gt; 12 \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; 13 \u0026lt;scope\u0026gt;compile\u0026lt;/scope\u0026gt; 14 \u0026lt;/dependency\u0026gt; 15 \u0026lt;dependency\u0026gt; 16 \u0026lt;groupId\u0026gt;com.android.support\u0026lt;/groupId\u0026gt; 17 \u0026lt;artifactId\u0026gt;support-v13\u0026lt;/artifactId\u0026gt; 18 \u0026lt;version\u0026gt;27.1.1\u0026lt;/version\u0026gt; 19 \u0026lt;scope\u0026gt;compile\u0026lt;/scope\u0026gt; 20 \u0026lt;/dependency\u0026gt; 21 \u0026lt;dependency\u0026gt; 22 \u0026lt;groupId\u0026gt;com.android.support\u0026lt;/groupId\u0026gt; 23 \u0026lt;artifactId\u0026gt;support-annotations\u0026lt;/artifactId\u0026gt; 24 \u0026lt;version\u0026gt;27.1.1\u0026lt;/version\u0026gt; 25 \u0026lt;scope\u0026gt;compile\u0026lt;/scope\u0026gt; 26 \u0026lt;/dependency\u0026gt; 27 \u0026lt;/dependencies\u0026gt; 28\u0026lt;/project\u0026gt; 这里有一个 io.flutter.plugins.sharedpreferences 就是报错的元凶了\n思考解决方案 看到这里我感觉有如下的方案\n将所有文件打包到同一个 aar 库中, 然后再上传(也就是网上那个 fat-aar 的方案) 修改 flutter 打包脚本, 然后将中间的三方库产物(sp 插件)上传至私服 maven, flutter 项目使用 api 的方式依赖这些库, 完成 host=\u0026gt;flutter=\u0026gt;other plugin 的目的 不用 maven, 只用 aar 个人第一感觉, 觉得第一个实施起来可能会简单一些, 先尝试一下\nfat-aar 这个找到了两个项目:\n一个 gradle 文件的方式: 一个是 plugin 的方式: 但是都要用到一个类似embed这样的关键字来替换 compile(api/implementation), 无奈找遍 gradle 没找到修改的地方, 只能暂时放弃\nflutter 的插件库上传至 maven 这个初始来看很可行.. 但仔细一想, 因为那个版本号的作祟, 需要改动的地方不算很少\n每个插件包内的 gradle 文件都需要修改:\n修改 version 版本号,这个应该是可以通过 环境变量/gradle 命令 来指定为佳, 不能指定的话理论上和 pub 的版本号相同也可以, 如果是 git 依赖, 就用 ref, path 依赖就很比较难自动取了 上传脚本,这个要读取上面的版本号, 还要读取一个 为什么要修改版本号呢? flutter 依赖的插件的版本号会被带到 aar 对应的 maven 库中的 pom.xml 文件中\n这里要插一句: pom.xml 中依赖的版本号是定义在每个插件自己的 build.gradle 中的,如下面的连接那样\n如下所示: 我这里说需要修改的就是这个版本号,否则你上传 maven 的 flutter 库的版本号和插件的 maven 版本号没对上的话,依然会报错\n修改版本号并上传需要遵循如下的步骤:\n读取本地.flutter-plugins文件的内容,将其中的版本号字段取出来 找到插件文件夹,替换掉版本号字段的内容 将上传插件的脚本复制至对应文件夹,并将版本号,group 名与插件统一 启动上传脚本 将对原生文件的修改内容还原 为什么要做最后一步呢? 这种\u0026quot;从远端\u0026quot;镜像下来的东西,修改回去是一个好习惯, 因为修改了会破坏仓库本身版本的完整性\n解决方案-使用 aar 和 git 管理 这个就是我开篇说的解决方案, 不使用 maven, 只是打包出 aar, 集中起来, 置入 git 仓库,如果有必要就打 tag 后 push 到远端, 方便根据版本来引用\n然后作为 android 原生方, 在 project 的 gradle 中引入 aar 库即可, 当然如果你是大公司有自己的要求, 还是用上一种比较好\ngit 和 aar 引入也是很成熟的使用方案了, 无非就是如何拼接而已的问题, 何况这一步还可以通过 gradle 自动完成\n处理 flutter 端 这次使用 dart 来作为脚本, 毕竟 dart 语言对于 flutter 开发者来说会很熟悉, 当然这一步可以用任何你熟悉的方式,比如: shell/python 等等, 这一步的执行需要将 dart 放入环境变量中\nbuild_module.dart:\n1import \u0026#39;dart:io\u0026#39;; 2 3var outputDir = Directory(\u0026#34;../output\u0026#34;); 4var targetDir = Directory(\u0026#34;../../flutter-aar\u0026#34;); 5 6Future main() async { 7 List\u0026lt;AAR\u0026gt; list = []; 8 9 outputDir.deleteSync(recursive: true); 10 outputDir.createSync(recursive: true); 11 var file = File(\u0026#34;../.flutter-plugins\u0026#34;); 12 var plugins = file.readAsLinesSync(); 13 for (var value in plugins) { 14 if (value.trim().isEmpty) { 15 continue; 16 } 17 var splitArr = value.split(\u0026#34;=\u0026#34;); 18 var name = splitArr[0]; 19 var path = splitArr[1]; 20 21 var aar = handlePlugin(name, path); 22 list.add(aar); 23 } 24 25 var aar = await handleFlutter(); 26 list.add(aar); 27 28 handleAAR(list); 29} 30 31void handleAAR(List\u0026lt;AAR\u0026gt; list) { 32 targetDir.deleteSync(recursive: true); 33 targetDir.createSync(); 34 list.forEach((aar) { 35 var targetPath = \u0026#34;${targetDir.path}/${aar.aarName}\u0026#34;; 36 var targetFile = aar.file.copySync(targetPath); 37 print( 38 \u0026#39;\\ncopy \u0026#34;${aar.file.absolute.path}\u0026#34; to \u0026#34;${targetFile.absolute.path}\u0026#34;\u0026#39;); 39 }); 40} 41 42AAR handlePlugin(String name, String path) { 43 var result = Process.runSync(\u0026#34;./gradlew\u0026#34;, [\u0026#34;$name:assRel\u0026#34;], 44 workingDirectory: \u0026#34;../.android\u0026#34;); 45 print(result.stdout); 46 47 var aarFile = File(\u0026#34;$path/android/build/outputs/aar/$name-release.aar\u0026#34;); 48 var aarName = aarFile.path.split(\u0026#34;/\u0026#34;).last; 49 var pathName = \u0026#34;${outputDir.path}/$aarName\u0026#34;; 50 var targetFile = aarFile.copySync(pathName); 51 return AAR() 52 ..file = targetFile 53 ..aarName = aarName; 54} 55 56Future\u0026lt;AAR\u0026gt; handleFlutter() async { 57 var processResult = await Process.run( 58 \u0026#34;flutter\u0026#34;, 59 [\u0026#34;build\u0026#34;, \u0026#34;apk\u0026#34;], 60 workingDirectory: \u0026#34;..\u0026#34;, 61 runInShell: true, 62 ); 63 64 print(processResult.stdout); 65 66 var name = \u0026#34;flutter-release.aar\u0026#34;; 67 68 var file = File(\u0026#34;../.android/Flutter/build/outputs/aar/flutter-release.aar\u0026#34;); 69 var target = file.copySync(\u0026#34;${outputDir.path}/$name\u0026#34;); 70 71 return AAR() 72 ..file = target 73 ..aarName = name; 74} 75 76class AAR { 77 String aarName; 78 File file; 79 80 String get noExtensionAarName =\u0026gt; aarName.split(\u0026#34;.\u0026#34;).first; 81 82 @override 83 String toString() { 84 return \u0026#39;AAR{aarName: $aarName, file: $file, noExtensionAarName: $noExtensionAarName}\u0026#39;; 85 } 86} 大概解释下脚本的功能:\n处理.flutter-plugins文件,获取 android 所在目录 执行flutter/.android下的 gradle 命令来生成 aar 根据插件所在目录来获取 aar 文件 打包 flutter 本身的 aar, 这一步因为一些资源的原因, 直接使用 flutter build apk, 会完成所有的中间产物的生成 将 插件和 flutter 的 aar 文件复制到 output/flutter-aar 文件夹下 output 文件夹就是我们作为 git 依赖使用的文件夹, 这个文件夹\n命令: $ dart build_aar.dart\n新建一个目录用于存放 aar 因为 git submodule 的管理方式对于新手不友好, 所以使用更简单一点的方案管理\n新建一个目录,把所有的 aar 文件都放在一起 (我的示例代码是放在一个仓库里的, 不过是同级目录)\n当前的目录结构是这样的:\n1tree -L 2 2. 3├── README.md 4├── android-host 5│ ├── android-host.iml 6│ ├── app 7│ ├── build 8│ ├── build.gradle 9│ ├── gradle 10│ ├── gradle.properties 11│ ├── gradlew 12│ ├── gradlew.bat 13│ ├── local.properties 14│ └── settings.gradle 15├── flutter-aar 16│ ├── flutter-release.aar 17│ └── shared_preferences-release.aar 18└── flutter_module 19 ├── README.md 20 ├── build 21 ├── flutter_module.iml 22 ├── flutter_module_android.iml 23 ├── lib 24 ├── output 25 ├── pubspec.lock 26 ├── pubspec.yaml 27 ├── shell 28 ├── template 29 └── test 这样分级的好处是仓库权限的分级:\nandroid 组允许访问 android-host 和 flutter-aar\nflutter 组允许访问 flutter_module 和 flutter-aar\n我示例代码是一个仓库, 但实际上对于项目来说应该是 3 个仓库为佳\n修改 android 主工程 build.gradle:\n1 2def aarDir = \u0026#34;${rootProject.projectDir.path}/../flutter-aar\u0026#34; 3 4repositories { 5 flatDir { 6 dirs aarDir 7 } 8} 9 10dependencies { 11 implementation fileTree(dir: \u0026#39;libs\u0026#39;, include: [\u0026#39;*.jar\u0026#39;]) 12 implementation \u0026#39;androidx.appcompat:appcompat:1.0.2\u0026#39; 13 implementation \u0026#39;androidx.constraintlayout:constraintlayout:1.1.3\u0026#39; 14 testImplementation \u0026#39;junit:junit:4.12\u0026#39; 15 androidTestImplementation \u0026#39;androidx.test:runner:1.2.0\u0026#39; 16 androidTestImplementation \u0026#39;androidx.test.espresso:espresso-core:3.2.0\u0026#39; 17 18 def file = new File(aarDir) 19 file.listFiles(new FilenameFilter() { 20 @Override 21 boolean accept(File dir, String name) { 22 return name.endsWith(\u0026#34;aar\u0026#34;) 23 } 24 }).each { f -\u0026gt; 25 def aar = f.name.split(\u0026#34;\\\\.\u0026#34;).first() 26 println(\u0026#34;f.name = ${f.name} , aar = $aar\u0026#34;) 27 api(name: f.name.split(\u0026#34;\\\\.\u0026#34;).first(), ext: \u0026#39;aar\u0026#39;) 28 } 29} 这样的情况下这个目录就完成了对于所有 aar 文件的引用\n总结一下所有修改 dart 脚本 复制我提供的仓库下flutter_module/shell/build_module.dart到你的 flutter 下的 shell 目录 修改这个 dart 脚本中的 targetDir 目录到任何你想要的目录(无论是直接到原生还是到单独仓库内) 原生部分修改 修改 build.gradle 加入对于 aar 的引用\n这里使用仓库还是直接在原生工程里看你们项目管理的要求\n这一步可以从原生项目的 app/build.gradle 看到所有修改\n运行脚本 总结一下我的运行步骤:\n命令行在根目录下执行 cd flutter_module/shell \u0026amp;\u0026amp; dart build_module.dart 运行 android 项目 建议的步骤如下:\n对于 flutter 开发者来说:\ncd flutter_project/shell \u0026amp;\u0026amp; dart build_module.dart cd android-aar 操作 git 仓库,上传 aar 对于安卓原生来说:\n$ cd android-aar $ git pull 运行项目 后记 本篇详细介绍了我是如何解决 flutter 添加到已有工程的方案, 虽然字数多, 但是实际引入并不复杂\n可能有遗漏, 有不清楚的请在 下评论留言, csdn 仅作为文章的同步发布平台, 评论可能没有时间看\n嗯,仓库在这里: 以上\n","link":"https://kikt.top/posts/flutter/exists/android-as-aar-to-maven/","section":"posts","tags":["android","aar","gradle","maven","flutter","docker","已有项目"],"title":"把flutter项目作为aar添加到已有的Android工程上"},{"body":"上篇粗略的查看了一下 desktop 的基本使用, 本篇探索一下插件的使用\n环境变量的配置请查看上篇,本篇不再赘述\n更新 继上一篇文章过去了几天, 这个桌面引擎有了一点点的更改: 现在完全用 swift 了,不用 oc 了,无论是 example 还是 plugin 模板都是如此\n所以, 为了省事,我重新 clone 了一个仓库, 然后准备用 swift 来创建插件\n$ git clone https://github.com/google/flutter-desktop-embedding.git flutter-desktop-embedding-2\n然后分别打开工程和插件 $ code flutter-desktop-embedding-2/example/ and $ code flutter-desktop-embedding-2/plugins/example_plugin\n这个 example_plugin 是给的模板, 最好是复制一份出来\n复制插件目录 1cd flutter-desktop-embedding-2/plugins 2cp -r example_plugin math_desktop 3code math_desktop 查看一下目录结构\n1tree math_desktop 2 3math_desktop 4├── LICENSE 5├── lib 6│ └── example_plugin.dart 7├── linux 8│ ├── Makefile 9│ ├── example_plugin.cc 10│ └── example_plugin.h 11├── macos 12│ ├── Classes 13│ │ └── ExamplePlugin.swift 14│ └── example_plugin.podspec 15├── pubspec.yaml 16└── windows 17 ├── ExamplePlugin.vcxproj 18 ├── ExamplePlugin.vcxproj.filters 19 ├── example_plugin.cpp 20 ├── example_plugin.h 21 └── scripts 22 └── cache_flutter.bat 基本是约定式的,和移动版的很类似\npubspec.yaml 在根目录,lib 放 dart 文件,然后根据 Platform 的不同使用不同的文件\n依赖插件并打开插件 修改 example 文件,添加依赖\n1dependencies: 2 flutter: 3 sdk: flutter 4 5 cupertino_icons: ^0.1.0 6 math_desktop: # add it 7 path: ../plugins/math_desktop 然后在 example 目录下执行flutter pub get, 这个是flutter packages get的另一种写法, 比较简单点\n接着进入 macos 目录下,执行$ pod install\n等待完成后 执行 $ open Runner.xcworkspace, 这样正常情况下会用 xcode 打开这个工程\n接着出现的就和 iOS 的插件差不多一样了 是这个 SHI 样的: 需要简化目录结构的可以搜索我写的 appcode 索引那个文章, 有简化方式,我这里不管它了\n编写插件 dart 插件目录下的 lib 文件夹\n添加一个方法\n1 static Future\u0026lt;int\u0026gt; add(int a, int b) async { 2 return _channel.invokeMethod(\u0026#39;add\u0026#39;, [a, b]); 3 } swift 很显然,中间那段是我自己加的,没什么实际意义, 就为了演示而已\n1 public func handle(_ call: FlutterMethodCall, result: @escaping FlutterResult) { 2 if (call.method == \u0026#34;getPlatformVersion\u0026#34;) { 3 result(\u0026#34;macOS \u0026#34; + ProcessInfo.processInfo.operatingSystemVersionString) 4 } else if(call.method == \u0026#34;add\u0026#34;){ 5 let args = call.arguments as! [Any] 6 let a = args[0] as! Int 7 let b = args[1] as! Int 8 result(a + b) 9 } else { 10 result(FlutterMethodNotImplemented); 11 } 12 } 调用 在 example 中调用这个方法\n1FutureBuilder\u0026lt;int\u0026gt;( 2 future: ExamplePlugin.add(_counter, 5), 3 builder: (context, snapshot) { 4 if (snapshot.hasData) { 5 return Text(snapshot.data.toString()); 6 } else { 7 return Text(\u0026#39;计算中\u0026#39;); 8 } 9 }, 10) 目前完整的 example 部分的代码如下:\n1// Copyright 2018 Google LLC 2// 3// Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); 4// you may not use this file except in compliance with the License. 5// You may obtain a copy of the License at 6// 7// http://www.apache.org/licenses/LICENSE-2.0 8// 9// Unless required by applicable law or agreed to in writing, software 10// distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, 11// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 12// See the License for the specific language governing permissions and 13// limitations under the License. 14 15import \u0026#39;package:flutter/foundation.dart\u0026#39; 16 show debugDefaultTargetPlatformOverride; 17import \u0026#39;package:flutter/material.dart\u0026#39;; 18import \u0026#39;package:math_desktop/example_plugin.dart\u0026#39;; 19 20void main() { 21 // See https://github.com/flutter/flutter/wiki/Desktop-shells#target-platform-override 22 debugDefaultTargetPlatformOverride = TargetPlatform.fuchsia; 23 24 runApp(new MyApp()); 25} 26 27class MyApp extends StatelessWidget { 28 @override 29 Widget build(BuildContext context) { 30 return MaterialApp( 31 title: \u0026#39;Flutter Demo\u0026#39;, 32 theme: ThemeData( 33 primarySwatch: Colors.blue, 34 // See https://github.com/flutter/flutter/wiki/Desktop-shells#fonts 35 fontFamily: \u0026#39;Roboto\u0026#39;, 36 ), 37 home: MyHomePage(title: \u0026#39;Flutter Demo Home Page\u0026#39;), 38 ); 39 } 40} 41 42class MyHomePage extends StatefulWidget { 43 MyHomePage({Key key, this.title}) : super(key: key); 44 45 final String title; 46 47 @override 48 _MyHomePageState createState() =\u0026gt; _MyHomePageState(); 49} 50 51class _MyHomePageState extends State\u0026lt;MyHomePage\u0026gt; { 52 int _counter = 0; 53 54 void _incrementCounter() { 55 setState(() { 56 _counter++; 57 }); 58 } 59 60 @override 61 Widget build(BuildContext context) { 62 return Scaffold( 63 appBar: AppBar( 64 title: Text(widget.title), 65 ), 66 body: Center( 67 child: Column( 68 mainAxisAlignment: MainAxisAlignment.center, 69 children: \u0026lt;Widget\u0026gt;[ 70 Text( 71 \u0026#39;You have pushed the button this many times:\u0026#39;, 72 ), 73 Text( 74 \u0026#39;$_counter\u0026#39;, 75 style: Theme.of(context).textTheme.display1, 76 ), 77 FutureBuilder\u0026lt;int\u0026gt;( 78 future: ExamplePlugin.add(_counter, 5), 79 builder: (context, snapshot) { 80 if (snapshot.hasData) { 81 return Text(snapshot.data.toString()); 82 } else { 83 return Text(\u0026#39;计算中\u0026#39;); 84 } 85 }, 86 ), 87 ], 88 ), 89 ), 90 floatingActionButton: FloatingActionButton( 91 onPressed: _incrementCounter, 92 tooltip: \u0026#39;Increment\u0026#39;, 93 child: Icon(Icons.add), 94 ), 95 ); 96 } 97} 运行代码 这里会发现这种错误\n1[ERROR:flutter/lib/ui/ui_dart_state.cc(148)] Unhandled Exception: MissingPluginException(No implementation found for method add on channel example_plugin) 首先我在 MathDesktop 类的注册方法中加入了 NSLog 的日志, 发现并没有输出, 所以应该是插件没有注册的原因\n1public static func register(with registrar: FlutterPluginRegistrar) { 2 let channel = FlutterMethodChannel(name: \u0026#34;example_plugin\u0026#34;, binaryMessenger: registrar.messenger) 3 let instance = MathDesktop() 4 registrar.addMethodCallDelegate(instance, channel: channel) 5 NSLog(\u0026#34;初始插件 : example_plugin\u0026#34;) 6} 据我观察并测试后, 原因是: 虽然迁移到了 swift, 但是相应的脚本或者说 flutter 的工具链没有迁移, 所以还是用的 oc 文件来注入, 但 oc 文件未被纳入到 flutter 项目中, 所以暂时还没法通过 flutter packages get 来自动引入原生的 plugin\n所以需要手动修改example/macos/Flutter/GeneratedPluginRegistrant.swift文件,来注册插件\n1import Foundation 2import FlutterMacOS 3import math_desktop 4 5func RegisterGeneratedPlugins(registry: FlutterPluginRegistry) { 6 MathDesktop.register(with: registry.registrar(forPlugin: \u0026#34;math_desktop\u0026#34;)) 7} 这样再次运行,就不会再报错了\n可以得到正确的效果\n简单总结 通过插件的编写, 简单总结一下:\n插件的原生中引入的库不是 iOS 中的 Flutter, 而是 FlutterMacOS ViewController 的是 Cocoa 框架, 个人猜测不排除未来会变成 SwiftUI 的可能性 注册工具目前不太好用 dart 端几乎无差,但是不排除会有一些特殊的手势或事件(鼠标滑过,键盘监听) 后记 仓库地址: 目前私有库,后续修改完成后放在 github 上\n插件的简单使用就到这里\n以上\n","link":"https://kikt.top/posts/flutter/desktop/flutter-desktop-2/","section":"posts","tags":["flutter","desktop","macos"],"title":"Flutter Desktop Mac版(二) 插件初探"},{"body":"","link":"https://kikt.top/tags/macos/","section":"tags","tags":null,"title":"macos"},{"body":"随着时间的逐渐推移, Flutter 开始了扩张之路\nflutter 已经不满足于移动端了,桌面端也有着自己的野心\n但无论如何,目前 flutter desktop 还仅仅处于 demo 玩一玩的阶段, 如果谁敢生产项目来一套, 我佩服你是个勇士\n官方说明 目前完成度最高的是 macOS 的版本,可用度很高, 而且由于同样使用 cocoapod,所以相对来说官方制作 engine 难度应该是最低的\n创建项目 现在建议使用官方本身提供的脚手架, 自己创建的话比较麻烦\n这个库目前托管在 google 下,还没有转给 flutter,也就是说暂时还不能称之为 flutter sdk 的一部分\ngit clone 我根据文档创建了一个 sh 脚本,专门用于输出我如果想尝鲜 desktop 版需要的东西, 也就是环境变量了\n1export FLUTTER_ROOT=$PWD/flutter 2echo \u0026#34;使用前复制如下命令\\n\u0026#34; 3 4echo \u0026#34;export FLUTTER_ROOT=$FLUTTER_ROOT\u0026#34; 5echo \u0026#34;export FLUTTER_HOME=$FLUTTER_ROOT\u0026#34; 6echo \u0026#34;export PATH=$FLUTTER_ROOT/bin:$PATH\u0026#34; 7echo \u0026#34;export ENABLE_FLUTTER_DESKTOP=true\u0026#34; 8 9echo \u0026#34;\\n以上\u0026#34; 这里我单独的 clone 了一份 sdk, 跑在了 flutter 的 master 分支上\n然后把 flutter 设置环境变量到这个 flutter sdk 上\n然后通过如下的方案检查:\n1which flutter 2/Volumes/Evo512/code/flutter_desktop/flutter/bin/flutter 这里就说明我的 flutter 是用的这个 example\n当然这个是临时的环境变量,如果你想要真正来开发 flutter_desktop 的应用,则应该将这些环境变量设置在.bash_profile 中\n打开项目 $ code flutter-desktop-embedding/example \u0026amp;\u0026amp; cd flutter-desktop-embedding/example\n这里就和平时运行 flutter 不太一样了\n稍等片刻就能看到这个 内存占用并不高\n包 官方建议是本地依赖,但是我尝试了一下,如果是纯粹的 dart 库,是可以直接用的\n也就是说没有直接或间接使用过 iOS/android 代码的 pub 库都是可以用的, 比如我写的 oktoast 就可以用 😁 当然还有一些其他的库, 有没有用原生库请查看库的代码或文档\n控件测试 输入 可以输入 选中总体来说还好 不支持复制粘贴全选 也不支持快捷键 无限滚动 帧数也还好, 这个总体表现还算 ok\n图片 没测试 memory,但是其他方式的都使用了\nasset 的使用方式和移动版相同, 而不是 web 的那种约定式\n1import \u0026#39;dart:io\u0026#39;; 2 3import \u0026#39;package:flutter/material.dart\u0026#39;; 4 5import \u0026#39;const/resource.dart\u0026#39;; 6 7class ImagePage extends StatefulWidget { 8 @override 9 _ImagePageState createState() =\u0026gt; _ImagePageState(); 10} 11 12class _ImagePageState extends State\u0026lt;ImagePage\u0026gt; { 13 @override 14 Widget build(BuildContext context) { 15 return Scaffold( 16 appBar: AppBar(), 17 body: ListView( 18 children: \u0026lt;Widget\u0026gt;[ 19 Container( 20 color: Colors.red, 21 child: Image.network( 22 \u0026#39;https://raw.githubusercontent.com/kikt-blog/image/master/img/20190610151657.png\u0026#39;), 23 ), 24 Container( 25 color: Colors.blue, 26 child: Image.file(File(\u0026#39;/Users/cai/Desktop/apng_spinfox.png\u0026#39;)), 27 ), 28 Container( 29 color: Colors.red, 30 child: Image.asset(R.ASSETS_1_PNG), 31 ), 32 ], 33 ), 34 ); 35 } 36} 库的使用 以本地提供的 file_chooser 为例\n修改 yaml 1file_chooser: 2 path: ../plugins/file_chooser 修改代码 1import \u0026#39;dart:io\u0026#39;; 2 3import \u0026#39;package:file_chooser/file_chooser.dart\u0026#39;; 4 5import \u0026#39;package:flutter/material.dart\u0026#39;; 6 7class LocalFilePickerPage extends StatefulWidget { 8 @override 9 _LocalFilePickerPageState createState() =\u0026gt; _LocalFilePickerPageState(); 10} 11 12class _LocalFilePickerPageState extends State\u0026lt;LocalFilePickerPage\u0026gt; { 13 File file; 14 15 @override 16 Widget build(BuildContext context) { 17 return Scaffold( 18 appBar: AppBar( 19 title: Text(\u0026#39;测试使用文件选择器\u0026#39;), 20 ), 21 body: Container( 22 child: Text(\u0026#39;我选择的文件 : ${file?.path}\u0026#39;), 23 ), 24 floatingActionButton: FloatingActionButton( 25 child: Icon(Icons.attach_file), 26 onPressed: () async { 27 showOpenPanel((results, path) { 28 print(\u0026#39;results: $results, path = $path\u0026#39;); 29 }); 30 }, 31 ), 32 ); 33 } 34} 查看界面 使用的是原生的选择器\n结果是这样的\nresults 是是否成功\npath 是选择的文件, 这里之所以是数组是因为支持多选, 不过默认关闭而已\n粗略分析插件目录 目录结构:\n1tree 2. 3├── LICENSE 4├── analysis_options.yaml 5├── lib 6│ ├── file_chooser.dart 7│ └── src 8│ ├── callbacks.dart 9│ ├── channel_controller.dart 10│ └── utilities.dart 11├── linux 12│ ├── Makefile 13│ ├── file_chooser_plugin.cc 14│ └── file_chooser_plugin.h 15├── macos 16│ ├── Classes 17│ │ ├── FileChooserPlugin.h 18│ │ └── FileChooserPlugin.m 19│ ├── Flutter 20│ │ ├── GeneratedPluginRegistrant.h 21│ │ ├── GeneratedPluginRegistrant.m 22│ │ └── ephemeral 23│ │ └── Flutter-Generated.xcconfig 24│ └── file_chooser.podspec 25├── pubspec.lock 26└── pubspec.yaml 这里没有 window 的选择器,我们使用一个其他的文件夹来查看\n1tree ../example_plugin 2../example_plugin 3├── LICENSE 4├── lib 5│ └── example_plugin.dart 6├── linux 7│ ├── Makefile 8│ ├── example_plugin.cc 9│ └── example_plugin.h 10├── macos 11│ ├── Classes 12│ │ ├── ExamplePlugin.h 13│ │ └── ExamplePlugin.m 14│ └── example_plugin.podspec 15├── pubspec.yaml 16└── windows 17 ├── ExamplePlugin.vcxproj 18 ├── ExamplePlugin.vcxproj.filters 19 ├── example_plugin.cpp 20 ├── example_plugin.h 21 └── scripts 22 └── cache_flutter.bat 可以看到,如果要做 desktop 的插件,需要开发 linux,macOS 和 windows 的文件\nmac 使用.h 和.m, 使用 cocoapod 来组织库文件\nlinux 使用.h 和.cc, 使用 Make 来构建\nwindows 使用.h 和.cpp,还有 vsxproj 文件, 这个 vsXXX 似乎是 VS 的文件, 也就是使用 VS 来构建, 当然还有一个.bat 脚本不知道具体作用是什么\n当然,还有 lib 下的 dart 文件,作为 dart 的调用入口\n创建插件 根据官方说法, 因为目前不支持 flutter create -t 的方式来创建 desktop 插件, 所以请使用 example-plugin 作为起点\n查看 后记 因为还没有 release 版本释出,所以目前为止还没有完整的打包方案, 无法测试 release 版的文件大小,但是内存来看是比较优秀的\n补充一下, 之前 flutter web 无法使用的 Icons,在 desktop 中完全没问题\n因为我这里只有 mac,其他平台没测试, 可用程度, 暂时未知\n代码在这: 以上\n","link":"https://kikt.top/posts/flutter/desktop/flutter-desktop-1/","section":"posts","tags":["flutter","desktop"],"title":"Flutter Desktop Mac版(一) 初探"},{"body":"下午看见群里有人问 swift 插件导入 oc 项目报错的问题, 我之前解决过, 但是忘了解决过程是怎么样的了, 这里记录下方便以后备查\n没兴趣追踪原因的直接查看\n复现错误 创建一个主工程(oc) 1flutter create oc_project 创建一个插件工程(swift) 1cd oc_project 2flutter create -i swift -t plugin swift_plugin 关联工程 1 swift_plugin: 2 path: ./swift_plugin 3 ``` 运行 iOS 项目得到错误信息 1Launching lib/main.dart on iPhone XS Max in debug mode... 2 3CocoaPods\u0026#39; output: 4 5↳ 6 7 Preparing 8 9 Analyzing dependencies 10 11 Inspecting targets to integrate 12 13 Using `ARCHS` setting to build architectures of target `Pods-Runner`: (``) 14 15 Fetching external sources 16 17 -\u0026gt; Fetching podspec for `Flutter` from `.symlinks/flutter/ios` 18 19 -\u0026gt; Fetching podspec for `swift_plugin` from `.symlinks/plugins/swift_plugin/ios` 20 21 Resolving dependencies of `Podfile` 22 23 Comparing resolved specification to the sandbox manifest 24 25 A Flutter 26 27 A swift_plugin 28 29 Downloading dependencies 30 31 -\u0026gt; Installing Flutter (1.0.0) 32 33 -\u0026gt; Installing swift_plugin (0.0.1) 34 35 - Running pre install hooks 36 37 [!] Unable to determine Swift version for the following pods: 38 39 - `swift_plugin` does not specify a Swift version and none of the targets (`Runner`) integrating it have the `SWIFT_VERSION` attribute set. Please contact the author or set the `SWIFT_VERSION` attribute in at least one of the targets that integrate this pod. 40 41 /Library/Ruby/Gems/2.3.0/gems/cocoapods-1.6.1/lib/cocoapods/installer/xcode/target_validator.rb:115:in `verify_swift_pods_swift_version\u0026#39; 42 43 /Library/Ruby/Gems/2.3.0/gems/cocoapods-1.6.1/lib/cocoapods/installer/xcode/target_validator.rb:37:in `validate!\u0026#39; 44 45 /Library/Ruby/Gems/2.3.0/gems/cocoapods-1.6.1/lib/cocoapods/installer.rb:459:in `validate_targets\u0026#39; 46 47 /Library/Ruby/Gems/2.3.0/gems/cocoapods-1.6.1/lib/cocoapods/installer.rb:138:in `install!\u0026#39; 48 49 /Library/Ruby/Gems/2.3.0/gems/cocoapods-1.6.1/lib/cocoapods/command/install.rb:48:in `run\u0026#39; 50 51 /Library/Ruby/Gems/2.3.0/gems/claide-1.0.2/lib/claide/command.rb:334:in `run\u0026#39; 52 53 /Library/Ruby/Gems/2.3.0/gems/cocoapods-1.6.1/lib/cocoapods/command.rb:52:in `run\u0026#39; 54 55 /Library/Ruby/Gems/2.3.0/gems/cocoapods-1.6.1/bin/pod:55:in `\u0026lt;top (required)\u0026gt;\u0026#39; 56 57 /usr/local/bin/pod:22:in `load\u0026#39; 58 59 /usr/local/bin/pod:22:in `\u0026lt;main\u0026gt;\u0026#39; 60 61Error output from CocoaPods: 62 63↳ 64 65 [!] `\u0026lt;PBXGroup UUID=`97C146E51CF9000F007C117D`\u0026gt;` attempted to initialize an object with an unknown UUID. `CF3B75C9A7D2FA2A4C99F110` for attribute: `children`. This can be the result of a merge and the unknown UUID is being discarded. 66 67 [!] Automatically assigning platform `ios` with version `8.0` on target `Runner` because no platform was specified. Please specify a platform for this target in your Podfile. See `https://guides.cocoapods.org/syntax/podfile.html#platform`. 68 69Error running pod install 70 71Error launching application on iPhone XS Max. 72 73Exited (sigterm) 错误信息大概是这样的\n尝试解决 提示信息中让我们联系作者加入一个 SWIFT_VERSION 的鬼东西, 因为插件的作者是我们自己,所以直接改就行了\n打开 swift_plugin/ios/swift_plugin.podspec 文件\n接着查询下这个 podspec 的配置页面文档: 看新闻最新的是 5.0, 我们就指定 5.0 吧, 在后面添加一行s.swift_version = '5.0', 接着运行, 不出意外的又报错了\n果然没有这么顺利, 这次的报错信息是The “Swift Language Version” (SWIFT_VERSION) build setting must be set to a supported value for targets which use Swift. Supported values are: 3.0, 4.0, 4.2. This setting can be set in the build settings editor.\n也就是说只支持这三个版本, 看到这里我想到的是两个解决方案:\n升级 cocoapod 或查询文档看是否新版本支持 5.0+ 查询当前 swift 文件的真实版本号 思考了几秒钟排除了 1, 因为 swift 可不是什么稳定的语言, 4.2 的语法 5.0 未必认,反之亦然\n所以我们要查询当前 swift 的文件是用哪个版本编写的,以便于对号入座\n用 xcode 打开 swift_plugin/example/ios, 就像这样 如果打开后只有 Runner,那说明 pod 相关的文件夹没生成,如下图 先关闭 xcode\n然后我们需要在命令行这样做:\n1cd swift_plugin/example/ios;pod install 接着再 open in xcode 见到 Pods 就说明对了 接着查看 swift 语言\n往下翻,找到这个,我这里是 4 设置给刚刚那个 swift_version: s.swift_version = '4.0'\n接着运行项目, 嗯.. 继续报错\n这次的信息: The “Swift Language Version” (SWIFT_VERSION) build setting must be set to a supported value for targets which use Swift. Supported values are: 3.0, 4.0, 4.2. This setting can be set in the build settings editor.\n这次倒是没让我们联系作者, 猜测一下,估计是主项目可能也需要设置, 查询文档: 打开ios/Podfile文件\n1target \u0026#39;Runner\u0026#39; do 2supports_swift_versions \u0026#39;\u0026gt;=4.0\u0026#39;, \u0026#39;\u0026lt;5.0\u0026#39;` # add 接着运行项目 Invalid Podfile file: undefined method `supports_swift_versions'\n可能是我 cocoapod 版本太低\n我升级一下: sudo gem install cocoapods\n1pod --version 21.7.1 接着运行项目, 这次又有另一个新花招 fatal error: 'swift_plugin/swift_plugin-Swift.h' file not found\n告诉我, swift.h 没找到, 这个是 swift 在编译过程中自动生成的头文件\n如何修改呢, 还是刚刚主工程的 Podfile 文件\n在开头所有注释的后面加入一行: use_frameworks!\n这个是使用 framework 代替静态库, pod 的官方文档说明: 再运行, 终于成功了!\n然后删除掉supports_swift_versions,再运行,我这里没发现问题,所以这一步其实是可以忽略的\n总结下 联系作者添加 swift_version 的版本号(通常是 4.0), 如果是自己的项目可以查看 xcode 获得 别人的项目 如果作者添加,皆大欢喜 作者不添加 尝试 PR 自己 fork 或 download 后魔改,使用 git 依赖或者 path 依赖 升级 cocoapod 的版本(我这里是 1.7.1) 在项目 podspec 中加入use_frameworks! 后记 本篇解决了 oc 项目使用 swift 插件的问题, 分享出来方便你我他\nexample 项目地址: 以上\n","link":"https://kikt.top/posts/flutter/oc/add-swift-plugin/","section":"posts","tags":["flutter","swift","oc","插件"],"title":"flutter 在OC工程中添加swift库报错的问题"},{"body":"","link":"https://kikt.top/tags/oc/","section":"tags","tags":null,"title":"oc"},{"body":"","link":"https://kikt.top/tags/swift/","section":"tags","tags":null,"title":"swift"},{"body":"","link":"https://kikt.top/tags/%E6%8F%92%E4%BB%B6/","section":"tags","tags":null,"title":"插件"},{"body":"","link":"https://kikt.top/archives/","section":"","tags":null,"title":""},{"body":"","link":"https://kikt.top/tags/10/","section":"tags","tags":null,"title":"10"},{"body":"如下几个改动:\n相机 这个修改会影响所有的安装在 androidQ 上的应用, 不论你的 targetVersion 是多少\n从前,即使没有 Camera 的权限, 也可以访问相机设备的元数据, 现在不行了\nwifi 应用不能动 wifi 开关了, 现在只有通过设置来更改\nwifi 配置 现在必须有设备管理器的权限才能修改 wifi 配置\nACCESS_FINE_LOCATION 带来的影响 如果没有ACCESS_FINE_LOCATION这个权限, 则 wifi,蓝牙会有一堆不能访问的 api\n或者看下面\nTelephony\ngetCellLocation() getAllCellInfo() requestNetworkScan() requestCellInfoUpdate() getAvailableNetworks() getServiceStateForSubscriber getServiceState() requestNetworkScan() onResults() onCellLocationChanged() onCellInfoChanged() onServiceStateChanged() Wi-Fi\nstartScan() getScanResults() getConnectionInfo() getConfiguredNetworks() Bluetooth\nstartDiscovery() startLeScan() LeScanCallback() 后记 以上\n","link":"https://kikt.top/posts/android/android-q/privacy/android-q-privacy-5/","section":"posts","tags":["android","androidQ","隐私","10"],"title":"Android Q 隐私篇(5) - 相机/网络"},{"body":"","link":"https://kikt.top/tags/androidq/","section":"tags","tags":null,"title":"androidQ"},{"body":"","link":"https://kikt.top/tags/%E9%9A%90%E7%A7%81/","section":"tags","tags":null,"title":"隐私"},{"body":"第四篇,\n唯一识别码的前世 在开发中, 总有人会提出各种设备\u0026quot;唯一标识符\u0026quot;的概念,以便于定位用户的唯一性, 或对于用户行为进行分析\n很遗憾, 通过多年的探索, 目前没有任何一种特别准确, 一定能保证唯一的方案\n包括但不仅限于以下方案\n设备序列号 IMEI imsi mac 地址(wifi 模块)\n如以下代码:\n1package top.kikit.uniqueidprivacy 2 3import android.Manifest 4import android.annotation.SuppressLint 5import android.content.Context 6import android.os.Bundle 7import android.telephony.TelephonyManager 8import android.util.Log 9import androidx.appcompat.app.AppCompatActivity 10import com.tbruyelle.rxpermissions2.RxPermissions 11 12class MainActivity : AppCompatActivity() { 13 private val TAG = \u0026#34;MainActivity\u0026#34;; 14 15 private val rxPermissions = RxPermissions(this) 16 17 @SuppressLint(\u0026#34;CheckResult\u0026#34;) 18 override fun onCreate(savedInstanceState: Bundle?) { 19 super.onCreate(savedInstanceState) 20 setContentView(R.layout.activity_main) 21 22 23 val mTelephonyMgr = getSystemService(Context.TELEPHONY_SERVICE) as TelephonyManager 24 25 rxPermissions.request(Manifest.permission.READ_PHONE_STATE) 26 .subscribe { 27 if (it) { 28 val subscriberId = mTelephonyMgr.subscriberId // imsi 29 val imei = mTelephonyMgr.imei // imei 30 31 Log.i(TAG, \u0026#34;subscriberId : $subscriberId\u0026#34;) 32 Log.i(TAG, \u0026#34;imei : $imei\u0026#34;) 33 } 34 } 35 } 36} 唯一识别码的今生(androidQ 的更新) 唯一识别符 mac 地址 随机 mac 地址 现在默认传输随机 mac 地址\n使用方法获取, 而这个方法位于WifiConfiguration类中, 而这个类被标记为过时\n大概意思是: 以后会被 XXX 替代, 而且以后这个类只有系统可以访问\n所以这个被封死了\n获取真实 wifi 地址 使用来获取\n这个类位于 DevicePolicyManager 类中, 这是一个设备管理员专用的类\n所以这个也暂时别想了\nIMEI/序列号 官方原文: androidQ 以后只有拥有READ_PRIVILEGED_PHONE_STATE权限的应用才能访问唯一识别码\n如果 targetVersion 在 Q 以下, 可以使用, 但是会返回 null, targetVersion 为 Q 以上的, 直接抛出SecurityException异常\n广告识别码 官方给提供的广告识别码在一定程度上可以用于广告, 但是广告识别码是可以由用户自己重置的\n以下是介绍: 这这两段都是中文, 某些朋友如果无法科学上网, 默哀下\n不过这个广告 ID 似乎需要 google service 支持, 只能说再见\n官方建议 官方还有一个建议,就是自己创建, 这个也是我一直以来在使用的方案, 就是自己创建一个 UUID\nUUID.randomUUID().toString()\n然后创建一个文件,把这东西写入, 以前是保存在 sdcard 中, 现在的话, 不能简单的保存在 sdcard 中了,可能需要保存到 Media 中,否则卸载后文件就木有了\n当然这个防止不了三清手机\n更新 2019 年 9 月 16 日\n查看 2019 年 中国的开发者大会, 关于这部分有一个截图\n只要你是同一个签名, 获取的总是相同, 只有恢复出厂设置才会视为不同设备\n剪切板数据 现在,除非你是输入法, 或者具有焦点应用, 否则无法再读取剪切板数据了\n不会以后在淘宝复制一个口令,然后支付宝/淘宝全家桶都出来告诉你, 可能是我的口令了, 请点一下之类的东西了\n也不会有复制了一个 url, 然后 UC 浏览器说, 这个网页不错,我能打开, 点我点我\n另外也不用担心某个 app 后台运行着, 然后把你的剪切板数据都监听一下, 只要改了我就上报\n后记 androidQ 基本隔绝了唯一识别码的读取方式, 唯一的一个方案是你注册成为\u0026quot;设备管理器\u0026quot;, 然后读取 mac 地址\n以上\n","link":"https://kikt.top/posts/android/android-q/privacy/android-q-privacy-4/","section":"posts","tags":["android","androidQ","隐私","10"],"title":"Android Q 隐私篇(4) - 唯一标识符, 剪切板数据"},{"body":"官方链接: 后台开启界面 这个限制主要限制的是: 当你的应用没有 Activity 在前台时, 后台应用无法主动开启界面\n流氓应用是可以这么干的, 只是大部分应用还算有节操, 没有这么做而已\n我自己遇到的除了我写的 Demo 以外,只有微信发生过这样的情况,还有一些其他应用是代码疏漏造成的\n作用范围 只要你的 app 运行在 androidQ 的设备上, 就不行,哪怕你的 targetVersion 是 28 也一样\n微信 微信也仅仅是在你登录以前登录过的电脑端时, 在你点击电脑端的确认后,才会在手机端弹出手动确认的弹框, 这一步原则上来讲也是客户自己的行为, 所以没有太大问题, 当然以后理论上就做不到了\n代码疏漏 一些应用的启动页, 比如设定了一个 Handler 的倒计时, 在 3 秒后关闭启动页,然后开启主页面\n然后,用户在启动页点了 home 键/back 键,过 3 秒后主页面依然出来了\n很遗憾,以后不行了 😁\n迁移需要修改的代码 无\n一个简单的示例代码 1class MainActivity : AppCompatActivity() { 2 3 override fun onCreate(savedInstanceState: Bundle?) { 4 super.onCreate(savedInstanceState) 5 setContentView(R.layout.activity_main) 6 7 Handler().postDelayed({ 8 startActivity(Intent(this, this.javaClass)) 9 finish() 10 }, 3000) 11 } 12} 这就完成了一个\u0026quot;流氓\u0026quot;式启动\nSYSTEM_ALERT_WINDOW 如果在以前的版本获得过SYSTEM_ALERT_WINDOW权限的应用可以从后台启动 Activity\n通知用户 官方给出的建议: 在通知栏通知用户, 由用户决定是否开启界面, 而不是直接启动 Activity\n创建高优先级的通知 1val fullScreenIntent = Intent(this, CallActivity::class.java) 2val fullScreenPendingIntent = PendingIntent.getActivity(this, 0, 3 fullScreenIntent, PendingIntent.FLAG_UPDATE_CURRENT) 4 5val notificationBuilder = NotificationCompat.Builder(this, CHANNEL_ID) 6 .setSmallIcon(R.drawable.notification_icon) 7 .setContentTitle(\u0026#34;Incoming call\u0026#34;) 8 .setContentText(\u0026#34;(919) 555-1234\u0026#34;) 9 .setPriority(NotificationCompat.PRIORITY_HIGH) 10 .setCategory(NotificationCompat.CATEGORY_CALL) 11 12 // Use a full-screen intent only for the highest-priority alerts where you 13 // have an associated activity that you would like to launch after the user 14 // interacts with the notification. Also, if your app targets Android Q, you 15 // need to request the USE_FULL_SCREEN_INTENT permission in order for the 16 // platform to invoke this notification. 17 .setFullScreenIntent(fullScreenPendingIntent, true) 18 19val incomingCallNotification = notificationBuilder.build() 显示与前台服务关联的通知 1// Provide a unique integer for the \u0026#34;notificationId\u0026#34; of each notification. 2startForeground(notificationId, notification) 通知的好处 (这部分也是官方说的, 未校验)\n这个通知遵循用户的免打扰 锁屏时, 全屏意图会立刻启动 如何测试这个变更 开发者选项=\u0026gt;启动后台活动启动 输入 $ adb shell settings put global background_activity_starts_enabled 1 后记 本篇对于常规应用的开发者来说没有任何变化, 一般情况下可以忽视\n以上\n","link":"https://kikt.top/posts/android/android-q/privacy/android-q-privacy-3/","section":"posts","tags":["android","androidQ","隐私","10"],"title":"Android Q 隐私篇(3) - 限制后台活动"},{"body":"本篇是系列第二篇, 主要分析下 android Q 下的后台定位权限 , 有能力的朋友可以自己阅读,并不难\n定位权限 在从前的 android 中,定位权限不分前后台,只有两个\n1\u0026lt;uses-permission android:name=\u0026#34;android.permission.ACCESS_COARSE_LOCATION\u0026#34;/\u0026gt; 2\u0026lt;uses-permission android:name=\u0026#34;android.permission.ACCESS_FINE_LOCATION\u0026#34;/\u0026gt; 分别代表大致位置和精确位置, 一般来说在使用时定位权限都是一起要或者都不要的, 而且这两个作为同一个组,一般都是一起申请,一次授权\n一般来说大部分人都是使用高德/百度地图作为定位 sdk 使用, 很显然这两个货申请一般也是都一起申请的\nandroidQ 的权限 androidQ 中会添加一个新的权限\n1 \u0026lt;uses-permission android:name=\u0026#34;android.permission.ACCESS_BACKGROUND_LOCATION\u0026#34; /\u0026gt; 这个就是对应的后台权限, 和以前的分类方式不同,以前是精确度,这个是前后台\n按照官方说明:\ntargetVersion: androidQ 或以上 如果 targetVersion 是 androidQ+, 则这个权限不会自动添加, 使用者需要自己添加,有就是有,没有就没有 如果 targetVersion 是 api 28(android 9.0)以下 如果你有以前版本的定位权限,则系统会在安装时帮你添加后台的权限(升级 androidOS 版本时不明) 在动态权限申请时,如果你申请的权限有以前的定位权限之一, 则会自动帮你在申请的权限里加上这个后台的 请求后台权限 上来是一段废话... 简单解释, 你需要后台权限吗?\n不需要 需要 这个不是我们自己能定的, 以国内来看, 接 sdk (推送,定位,分享...)就要, 不接也要\n如果不需要 请参考\nService 中声明一个前台定位的 type 类型\n1\u0026lt;service 2 android:name=\u0026#34;MyNavigationService\u0026#34; 3 android:foregroundServiceType=\u0026#34;location\u0026#34; ... \u0026gt; 4 ... 5\u0026lt;/service\u0026gt; 如果需要 需要的情况下, 如果是在 service 里面做请求定位的逻辑, 请保证每一次都要运行时权限检查, 因为用户随时可以关闭应用的后台权限\n如果用户仅允许你前台访问定位权限, 但你的应用没有后台定位权限会影响应用的运行,则应该友好的提示用户给予权限(自定义对话框), 当 TA 允许时再请求后台权限\n官方给的示例如下\n1val permissionAccessCoarseLocationApproved = ActivityCompat 2 .checkSelfPermission(this, permission.ACCESS_COARSE_LOCATION) == 3 PackageManager.PERMISSION_GRANTED 4 5if (permissionAccessCoarseLocationApproved) { 6 val backgroundLocationPermissionApproved = ActivityCompat 7 .checkSelfPermission(this, permission.ACCESS_BACKGROUND_LOCATION) == 8 PackageManager.PERMISSION_GRANTED 9 10 if (backgroundLocationPermissionApproved) { 11 // App can access location both in the foreground and in the background. 12 // Start your service that doesn\u0026#39;t have a foreground service type 13 // defined. 14 } else { 15 // App can only access location in the foreground. Display a dialog 16 // warning the user that your app must have all-the-time access to 17 // location in order to function properly. Then, request background 18 // location. 19 ActivityCompat.requestPermissions(this, 20 arrayOf(Manifest.permission.ACCESS_BACKGROUND_LOCATION), 21 your-permission-request-code 22 ) 23 } 24} else { 25 // App doesn\u0026#39;t have access to the device\u0026#39;s location at all. Make full request 26 // for permission. 27 ActivityCompat.requestPermissions(this, 28 arrayOf(Manifest.permission.ACCESS_COARSE_LOCATION, 29 Manifest.permission.ACCESS_BACKGROUND_LOCATION), 30 your-permission-request-code 31 ) 32} 设备升级时的迁移方案 如果你需要后台权限, 则\n在 Manifest 中加上权限 并在代码的动态权限申请中加入后台权限的相关代码 如果不需要,则代码不需要做任何变动\n需要注意的几个点 如果用到了位置权限,则需要特殊处理的:\n您的应用程序无权访问位置信息。 您的应用程序无权访问位置在后台运行时的信息。 不处理可能会崩溃或者用户体验不好\n后记 本篇没什么代码, 所以示例代码仓库中没有做任何修改\n以上\n","link":"https://kikt.top/posts/android/android-q/privacy/android-q-privacy-2/","section":"posts","tags":["android","androidQ","隐私","10"],"title":"Android Q 隐私篇(2) - 后台定位权限"},{"body":"一年一度的 googleIO 开完以后,不出意外的 Android10.0 系统(AndroidQ)出来了\n隐私配置又㕛叒叕更新了..\n连接地址: 这个地址可能在来年就变成 android 11 的了, 所以仅保证在2019 年 05 月 20 日以及之后的一段时间内有效\n主要包含以下五大项目\n对于大部分应用来说,储存方式的更新会有所影响, 其他的可能都是 SDK 要做的事情,和普通开发者关系不大\n在适配新的系统前就和从前一样,暂时不升级 targetVersion,把 targetVersion 设置为 28 以下就不会影响旧程序了,就如同以前运行时权限真的是坑到爆炸,但是暂时不适配也是可以的\n但是未来无论如何都需要适配新系统,所以先来看看\n本篇只说储存的方式和权限问题,其他暂时略过不表\n检查迁移情况 有一个表格提供了如何检查和迁移的方案\n开发环境 说一下开发环境\nMacOS\nAndroid Studio 3.4.0\nandroid 9.0 设备一台\nandroidQ 虚拟机一台(官方的 Emulator)\n更新 sdk 更新 sdk, 下载 androidQ 相关的 sdk/sdktools/模拟器\nandroidQ build.gradle 当前想尝试 androidQ 的话, 编译版本和目标版本号需要按如下方式设置, 今后的话可能是 29/30 之类的数字\n1targetSdkVersion = \u0026#39;Q\u0026#39; 2compileSdkVersion = \u0026#39;android-Q\u0026#39; 外部储存 androidQ 下读写文件 权限和以前一样\n1 \u0026lt;uses-permission android:name=\u0026#34;android.permission.READ_EXTERNAL_STORAGE\u0026#34;/\u0026gt; 2 \u0026lt;uses-permission android:name=\u0026#34;android.permission.WRITE_EXTERNAL_STORAGE\u0026#34;/\u0026gt; Activity 文件\n1package top.kikt.camerax.scopedstorage 2 3import android.os.Bundle 4import android.util.Log 5import androidx.appcompat.app.AppCompatActivity 6import java.io.File 7 8class MainActivity : AppCompatActivity() { 9 10 companion object { 11 private const val TAG = \u0026#34;MainActivity\u0026#34; 12 } 13 14 override fun onCreate(savedInstanceState: Bundle?) { 15 super.onCreate(savedInstanceState) 16 setContentView(R.layout.activity_main) 17 18 val path = externalCacheDir?.absoluteFile?.path 19 20 Log.d(TAG, \u0026#34;cache dir = $path\u0026#34;) 21 22 val file = File(path, \u0026#34;abc.txt\u0026#34;) 23 24 file.writeText(\u0026#34;我要往里写数据\u0026#34;) 25 26 val text = file.readText() 27 28 Log.d(TAG, \u0026#34;数据是: $text\u0026#34;) 29 } 30} 12019-05-20 11:41:28.938 7435-7435/top.kikt.camerax.scopedstorage D/MainActivity: cache dir = /storage/emulated/0/Android/data/top.kikt.camerax.scopedstorage/cache 22019-05-20 11:41:28.957 7435-7435/top.kikt.camerax.scopedstorage D/MainActivity: 数据是: 我要往里写数据 这里可以看出, 在正常情况下, 将文件存入外部储存比从前方便了, 不再需要动态权限申请\n并且,我这里的小米手机没有弹出敏感权限的那个对话框\n外部储存的\u0026quot;沙箱\u0026quot; 从前只要用户允许 app 访问外置储存后, 就可以通过 MediaStore 的 api 拿到图片和相册的完整数据\n而 androidQ 中对于这部分权限进行了重新处理\n按照文档的说法, 目前外部储存中是沙箱的模式, 除非你的目标文件属于以下三类, 否则其他应用将无法看到你的图片\n1Photos, which are stored in MediaStore.Images. 2Videos, which are stored in MediaStore.Video. 3Music files, which are stored in MediaStore.Audio. 想要访问非自己 app 的特定的文件夹, 比如 downloads, 你需要使用, 这是一个 android 4.4 加入的 api, 官方有中文说明, 网上应该也有很多示例代码, 这里不展开了\n有一点需要注意: 当 app 被卸载后, 位于外部储存中的 app 数据会被清除, 如果你需要保留数据, 必须保存到 MediaStore 中\n因为是按顺序浏览文档说明, 我看到了如下的说明:\n访问自己 app 位于外部储存中的内容不需要访问权限, 所以这里我注释掉清单文件中的权限, 发现表现和之前一样, 可以写入和读取文件, 这也就解释了为什么不会弹出敏感权限申请, 因为在 androidQ 中, 访问自己 app 的文件不再是敏感权限\n相册图片 完整的代码如下, 使用了 RxJava+RxPermission 做权限的申请\n1package top.kikt.camerax.scopedstorage 2 3import android.Manifest 4import android.database.Cursor 5import android.graphics.Bitmap 6import android.net.Uri 7import android.os.Build 8import android.os.Bundle 9import android.provider.MediaStore 10import android.util.Log 11import android.util.Size 12import androidx.appcompat.app.AppCompatActivity 13import androidx.core.database.getIntOrNull 14import com.tbruyelle.rxpermissions2.RxPermissions 15import kotlinx.android.synthetic.main.activity_media_scan.* 16 17class MediaScanActivity : AppCompatActivity() { 18 19 private val rxPermissions = RxPermissions(this) 20 21 private val TAG = \u0026#34;MediaScanActivity\u0026#34; 22 23 private val storeImageKeys = arrayOf( 24 MediaStore.Images.Media.DISPLAY_NAME, // 显示的名字 25 MediaStore.Images.Media.DATA, // 数据 26 MediaStore.Images.Media.LONGITUDE, // 经度 27 MediaStore.Images.Media._ID, // id 28 MediaStore.Images.Media.MINI_THUMB_MAGIC, // id 29 MediaStore.Images.Media.TITLE, // id 30 MediaStore.Images.Media.BUCKET_ID, // dir id 目录 31 MediaStore.Images.Media.BUCKET_DISPLAY_NAME, // dir name 目录名字 32// MediaStore.Images.Media.EXTERNAL_CONTENT_URI, // dir name 目录名字 33 MediaStore.Images.Media.WIDTH, // 宽 34 MediaStore.Images.Media.HEIGHT, // 高 35 MediaStore.Images.Media.DATE_TAKEN //日期 36 ) 37 38 override fun onCreate(savedInstanceState: Bundle?) { 39 super.onCreate(savedInstanceState) 40 setContentView(R.layout.activity_media_scan) 41 42 bt_scan.setOnClickListener { 43 Log.d(TAG, \u0026#34;准备申请权限\u0026#34;) 44 rxPermissions.request( 45 Manifest.permission.WRITE_EXTERNAL_STORAGE, 46 Manifest.permission.READ_EXTERNAL_STORAGE 47 ) 48 .subscribe { 49 if (it) { 50 Log.d(TAG, \u0026#34;申请权限成功\u0026#34;) 51 scan() 52 } else { 53 Log.d(TAG, \u0026#34;申请失败\u0026#34;) 54 } 55 } 56 } 57 } 58 59 private fun scan() { 60 val cursor = contentResolver.query( 61 MediaStore.Images.Media.EXTERNAL_CONTENT_URI, 62 storeImageKeys, 63 null, 64 null, 65 MediaStore.Images.Media.DATE_TAKEN 66 ) 67 68 cursor?.apply { 69 val count = this.count 70 Log.d(TAG, \u0026#34;scan count is $count\u0026#34;) 71 while (this.moveToNext()) { 72 val date = this.getString(MediaStore.Images.Media.DATA) 73 Log.d(TAG, \u0026#34;path : $date\u0026#34;) 74// contentResolver.loadThumbnail() 75 val width = this.getInteger(MediaStore.Images.Media.WIDTH) ?: 1024 76 val height = this.getInteger(MediaStore.Images.Media.HEIGHT) ?: 1024 77 Log.d(TAG, \u0026#34;width : $width\u0026#34;) 78 Log.d(TAG, \u0026#34;height : $height\u0026#34;) 79 80 var photoUri = Uri.withAppendedPath( 81 MediaStore.Images.Media.EXTERNAL_CONTENT_URI, 82 cursor.getString(MediaStore.Images.Media._ID) 83 ) 84 85 Log.d(TAG, \u0026#34;version int = ${Build.VERSION.SDK_INT}\u0026#34;) 86 87// if (Build.VERSION.SDK_INT \u0026gt;= Build.VERSION_CODES.Q) { 88 photoUri = MediaStore.setRequireOriginal(photoUri) 89// val stream = contentResolver.openInputStream(photoUri) 90 val bitmap = contentResolver.loadThumbnail(photoUri, Size(width, height), null) 91 iv_preview.setImageBitmap(bitmap) 92// } 93 } 94 } 95 96 cursor?.close() 97 } 98 99 private fun Cursor.getString(columnName: String): String? { 100 val columnIndex = getColumnIndex(columnName) 101 if (columnIndex == -1) { 102 return null 103 } 104 return this.getString(columnIndex) 105 } 106 107 private fun Cursor.getInteger(columnName: String): Int? { 108 val columnIndex = getColumnIndex(columnName) 109 if (columnIndex == -1) { 110 return null 111 } 112 return this.getIntOrNull(columnIndex) 113 } 114 115 data class ImageEntity(val width: Int, val height: Int, val bitmap: Bitmap) { 116 fun dispose() { 117 bitmap.recycle() 118 } 119 } 120} 布局在这里\n1\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; 2\u0026lt;androidx.constraintlayout.widget.ConstraintLayout 3 xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; 4 xmlns:tools=\u0026#34;http://schemas.android.com/tools\u0026#34; 5 xmlns:app=\u0026#34;http://schemas.android.com/apk/res-auto\u0026#34; 6 android:layout_width=\u0026#34;match_parent\u0026#34; 7 android:layout_height=\u0026#34;match_parent\u0026#34; 8 tools:context=\u0026#34;.MediaScanActivity\u0026#34;\u0026gt; 9 10 \u0026lt;Button 11 android:text=\u0026#34;扫描\u0026#34; 12 android:layout_width=\u0026#34;wrap_content\u0026#34; 13 android:layout_height=\u0026#34;wrap_content\u0026#34; tools:layout_editor_absoluteY=\u0026#34;16dp\u0026#34; 14 tools:layout_editor_absoluteX=\u0026#34;16dp\u0026#34; android:id=\u0026#34;@+id/bt_scan\u0026#34;/\u0026gt; 15 \u0026lt;ImageView 16 android:layout_width=\u0026#34;0dp\u0026#34; 17 android:layout_height=\u0026#34;0dp\u0026#34; 18 android:id=\u0026#34;@+id/iv_preview\u0026#34; app:layout_constraintEnd_toEndOf=\u0026#34;parent\u0026#34; 19 app:layout_constraintStart_toStartOf=\u0026#34;parent\u0026#34; android:layout_marginStart=\u0026#34;8dp\u0026#34; 20 app:layout_constraintBottom_toBottomOf=\u0026#34;parent\u0026#34; android:layout_marginTop=\u0026#34;8dp\u0026#34; 21 app:layout_constraintTop_toBottomOf=\u0026#34;@+id/bt_scan\u0026#34; android:layout_marginEnd=\u0026#34;8dp\u0026#34; 22 android:layout_marginBottom=\u0026#34;8dp\u0026#34;/\u0026gt; 23\u0026lt;/androidx.constraintlayout.widget.ConstraintLayout\u0026gt; 点击扫描后能看见这个图片 相册里只有这一张图\n核心代码如下:\n1 val cursor = contentResolver.query( 2 MediaStore.Images.Media.EXTERNAL_CONTENT_URI, 3 storeImageKeys, 4 null, 5 null, 6 MediaStore.Images.Media.DATE_TAKEN 7 ) 8 9 cursor?.apply { 10 val count = this.count 11 Log.d(TAG, \u0026#34;scan count is $count\u0026#34;) 12 while (this.moveToNext()) { 13 val date = this.getString(MediaStore.Images.Media.DATA) 14 Log.d(TAG, \u0026#34;path : $date\u0026#34;) 15// contentResolver.loadThumbnail() 16 val width = this.getInteger(MediaStore.Images.Media.WIDTH) ?: 1024 17 val height = this.getInteger(MediaStore.Images.Media.HEIGHT) ?: 1024 18 Log.d(TAG, \u0026#34;width : $width\u0026#34;) 19 Log.d(TAG, \u0026#34;height : $height\u0026#34;) 20 21 var photoUri = Uri.withAppendedPath( 22 MediaStore.Images.Media.EXTERNAL_CONTENT_URI, 23 cursor.getString(MediaStore.Images.Media._ID) 24 ) 25 26 Log.d(TAG, \u0026#34;version int = ${Build.VERSION.SDK_INT}\u0026#34;) 27 28// if (Build.VERSION.SDK_INT \u0026gt;= Build.VERSION_CODES.Q) { // 这里注释的原因是因为模拟器中获取的是28, 而SDK中定义是10000, 这样写这个代码跑不起来 29 photoUri = MediaStore.setRequireOriginal(photoUri) 30// val stream = contentResolver.openInputStream(photoUri) 31 val bitmap = contentResolver.loadThumbnail(photoUri, Size(width, height), null) 32 iv_preview.setImageBitmap(bitmap) 33// } 34 } 35 } 36 37 cursor?.close() 以前版本直接用 Data 就可以拿到图片对应的 File path\n而 android-Q 以后,不能再这样做了,需要通过 id 来\u0026quot;组装\u0026quot;出一个 Uri, 然后通过 contentResolver.loadThumbnail()来获取缩略图\n1 var photoUri = Uri.withAppendedPath( 2 MediaStore.Images.Media.EXTERNAL_CONTENT_URI, 3 cursor.getString(MediaStore.Images.Media._ID) 4 ) 5 6 Log.d(TAG, \u0026#34;version int = ${Build.VERSION.SDK_INT}\u0026#34;) 7 8// if (Build.VERSION.SDK_INT \u0026gt;= Build.VERSION_CODES.Q) { 9 photoUri = MediaStore.setRequireOriginal(photoUri) 10// val stream = contentResolver.openInputStream(photoUri) 11 val bitmap = contentResolver.loadThumbnail(photoUri, Size(width, height), null) 12 iv_preview.setImageBitmap(bitmap) 需要用 jni 处理图片 有的时候,你需要使用 ndk/jni 来处理文件,这个时候,可以用 openFileDescriptor 来完成这个事情\n1val fileOpenMode = \u0026#34;r\u0026#34; 2val parcelFd = resolver.openFileDescriptor(photoUri, fileOpenMode) 3val fd = parcelFd?.detachFd() 修改其他项目创建的文件 需要捕获RecoverableSecurityException异常,并请求用户允许修改\n官方原文如下:\nUpdate other apps' media files Note: Expect the following behavior to take effect in a future beta release of Android Q. To modify a given media file that another app originally saved to an external storage device, catch the RecoverableSecurityException that the platform throws. You can then request that the user grant your app write access to that specific item.\n照片的位置信息 一些照片在 Exif 中包含位置的敏感信息, 以前的话可以直接通过 MediaStore 的 query 方法从数据库中查到, 现在就不再可以了\n如果需要这些元数据,需要请求用户同意, 需要ACCESS_MEDIA_LOCATION权限, 这个是一个 android-Q 的新权限\n并调用setRequireOriginal()方法来获取对应的 Uri\n官方给的示例如下:\n1// Get location data from the ExifInterface class. 2val photoUri = MediaStore.setRequireOriginal(photoUri) 3contentResolver.openInputStream(photoUri).use { stream -\u0026gt; 4 ExifInterface(stream).run { 5 // If lat/long is null, fall back to the coordinates (0, 0). 6 val latLong = ?: doubleArrayOf(0.0, 0.0) 7 } 8} 可是我这里有报错的地方,我修改如下:\n1contentResolver.openInputStream(photoUri).use { stream -\u0026gt; 2 ExifInterface(stream).run { 3 val floatArrayOf = floatArrayOf(0f, 0f) 4 val latLongResult = this.getLatLong(floatArrayOf) 5 Log.d(TAG, \u0026#34;latLng request $latLongResult latlng = ${floatArrayOf.toList()}\u0026#34;) 6 } 7} 在加入权限的请求后我能够得到一个日志, 告诉我照片的经纬度\n12019-05-20 17:02:01.436 19236-19236/top.kikt.camerax.scopedstorage D/MediaScanActivity: latLng request true latlng = [39.841603, 116.317417], sdcard 目录结构 系统自带的 files 无法完整的看到目录结构, 我考虑使用 adb shell 命令来查看\n1generic_x86:/sdcard $ ls 2Alarms DCIM Movies Notifications Podcasts 3Android Download Music Pictures Ringtones 1generic_x86:/sdcard $ cd DCIM 2generic_x86:/sdcard/DCIM $ ls 3Camera 4generic_x86:/sdcard/DCIM $ ls Camera/ 5IMG_20190518_232111.jpg IMG_20190520_140142.jpg 6generic_x86:/sdcard/DCIM $ 1cd /sdcard/Android # 这一步应该是常规的数据 2ls data/ 3com.android.calllogbackup com.android.phone com.android.service.ims.presence com.google.android.packageinstaller 4com.android.camera2 com.android.printspooler com.android.smspush com.google.android.partnersetup 5com.android.carrierconfig com.android.providers.blockednumber com.android.stk com.google.android.sdksetup 6com.android.cellbroadcastreceiver com.android.providers.calendar com.android.vending com.google.android.setupwizard 7com.android.chrome com.android.providers.contacts com.google.android.apps.docs com.google.android.storagemanager 8com.android.managedprovisioning com.android.providers.telephony com.google.android.apps.maps com.google.android.videos 9com.android.mms.service com.android.providers.userdictionary com.google.android.gms com.google.android.webview 10com.android.nfc com.android.se com.google.android.gsf com.google.android.youtube 11com.android.ons com.android.service.ims com.google.android.onetimeinitializer top.kikt.camerax.scopedstorage 1130|generic_x86:/sdcard/Android $ ls /sdcard/Android/data/top.kikt.camerax.scopedstorage/ 2cache 3generic_x86:/sdcard/Android $ ls /sdcard/Android/data/top.kikt.camerax.scopedstorage/cache/ 4abc.txt # 这个是代码第一步创建的那个文件 1generic_x86:/sdcard/Android $ ls /sdcard/Android/media 2com.android.calllogbackup com.android.phone com.android.service.ims com.google.android.onetimeinitializer 3com.android.carrierconfig com.android.printspooler com.android.service.ims.presence com.google.android.packageinstaller 4com.android.cellbroadcastreceiver com.android.providers.blockednumber com.android.smspush com.google.android.partnersetup 5com.android.chrome com.android.providers.calendar com.android.stk com.google.android.sdksetup 6com.android.managedprovisioning com.android.providers.contacts com.android.vending com.google.android.setupwizard 7com.android.mms.service com.android.providers.telephony com.google.android.apps.maps com.google.android.storagemanager 8com.android.nfc com.android.providers.userdictionary com.google.android.gms com.google.android.webview 9com.android.ons com.android.se com.google.android.gsf top.kikt.camerax.scopedstorage 这一步的话,应该是创建可以在卸载 app 后依然会保留的 media 部分\n基本和前面说的沙箱,本应用的 media, 系统相册等进行了一一对应\n后记 以上\n","link":"https://kikt.top/posts/android/android-q/privacy/android-q-privacy-1/","section":"posts","tags":["android","androidQ","隐私","10"],"title":"Android Q 隐私篇(1) - 外部储存"},{"body":"","link":"https://kikt.top/tags/camera/","section":"tags","tags":null,"title":"camera"},{"body":"","link":"https://kikt.top/tags/camerax/","section":"tags","tags":null,"title":"cameraX"},{"body":"我在 googleIO 前查看演讲主题,看到了有一篇标题是关于 cameraX ,当时在 android 官网没有搜索到教程\n在 flutter web 基本体验完毕后, 再去搜索果然从官网查看到了 cameraX 的相关介绍\n介绍 CameraX 是 Jetpack 的一部分, 旨在帮助更好更简单的使用照相机\n最低支持的 API 等级是 API 21(5.0)\n开发环境 我当前的开发环境是\nMacOS 10.13.6\nAndroid Studio 3.4 小米 8 MIUI 10.3 稳定版 10.3.2.0(android 9.0)\n最低支持 官方说明为 AndroidStudio 3.3 API 21+的设备\n编码准备 新建项目 修改这两项\n最低 21, 使用 androidX\n添加依赖 在 app 级别的 build.gradle 中添加如下依赖\n这个版本当前还是 alpha 版本,后续可能会升级为正式版, 可以查看\n1dependencies { 2 def camerax_version = \u0026#34;1.0.0-alpha01\u0026#34; 3 implementation \u0026#34;androidx.camera:camera-core:${camerax_version}\u0026#34; 4 implementation \u0026#34;androidx.camera:camera-camera2:${camerax_version}\u0026#34; 5} 尝试运行项目 运行项目,我这里可以成功跑起来,说明依赖添加是成功的\n编码 修改 xml 文件 1\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; 2\u0026lt;androidx.constraintlayout.widget.ConstraintLayout 3 xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; 4 xmlns:tools=\u0026#34;http://schemas.android.com/tools\u0026#34; 5 xmlns:app=\u0026#34;http://schemas.android.com/apk/res-auto\u0026#34; 6 android:layout_width=\u0026#34;match_parent\u0026#34; 7 android:layout_height=\u0026#34;match_parent\u0026#34; 8 tools:context=\u0026#34;.MainActivity\u0026#34;\u0026gt; 9 10 \u0026lt;TextureView 11 android:id=\u0026#34;@+id/view_finder\u0026#34; 12 android:layout_width=\u0026#34;640px\u0026#34; 13 android:layout_height=\u0026#34;640px\u0026#34; 14 app:layout_constraintTop_toTopOf=\u0026#34;parent\u0026#34; 15 app:layout_constraintBottom_toBottomOf=\u0026#34;parent\u0026#34; 16 app:layout_constraintStart_toStartOf=\u0026#34;parent\u0026#34; 17 app:layout_constraintEnd_toEndOf=\u0026#34;parent\u0026#34; /\u0026gt; 18 19\u0026lt;/androidx.constraintlayout.widget.ConstraintLayout\u0026gt; 使用TextureView作为显示的 View\n申请权限 添加到 manifest\n1\u0026lt;uses-permission android:name=\u0026#34;android.permission.CAMERA\u0026#34; /\u0026gt; 申请动态访问权限,这一步可以借助第三方插件,也可以自己写\n截至目前为止,代码如下\n1package top.kikt.camerax.usage 2 3import android.Manifest 4import android.content.pm.PackageManager 5import android.os.Bundle 6import android.view.TextureView 7import android.widget.Toast 8import androidx.appcompat.app.AppCompatActivity 9import androidx.core.app.ActivityCompat 10import androidx.core.content.ContextCompat 11import kotlinx.android.synthetic.main.activity_main.* 12 13private const val REQUEST_CODE_PERMISSIONS = 10 14private val REQUIRED_PERMISSIONS = arrayOf(Manifest.permission.CAMERA) 15 16class MainActivity : AppCompatActivity(), LifecycleOwner { 17 18 private lateinit var viewFinder: TextureView 19 20 override fun onCreate(savedInstanceState: Bundle?) { 21 super.onCreate(savedInstanceState) 22 setContentView(R.layout.activity_main) 23 viewFinder = view_finder 24 25 // Request camera permissions 26 if (allPermissionsGranted()) { 27 viewFinder.post { startCamera() } 28 } else { 29 ActivityCompat.requestPermissions( 30 this, REQUIRED_PERMISSIONS, REQUEST_CODE_PERMISSIONS 31 ) 32 } 33 34 // Every time the provided texture view changes, recompute layout 35 viewFinder.addOnLayoutChangeListener { _, _, _, _, _, _, _, _, _ -\u0026gt; 36 updateTransform() 37 } 38 } 39 40 41 private fun startCamera() { 42 43 } 44 45 private fun updateTransform() {} 46 47 /** 48 * Process result from permission request dialog box, has the request 49 * been granted? If yes, start Camera. Otherwise display a toast 50 */ 51 override fun onRequestPermissionsResult( 52 requestCode: Int, permissions: Array\u0026lt;String\u0026gt;, grantResults: IntArray 53 ) { 54 if (requestCode == REQUEST_CODE_PERMISSIONS) { 55 if (allPermissionsGranted()) { 56 viewFinder.post { startCamera() } 57 } else { 58 Toast.makeText( 59 this, 60 \u0026#34;Permissions not granted by the user.\u0026#34;, 61 Toast.LENGTH_SHORT 62 ).show() 63 finish() 64 } 65 } 66 } 67 68 /** 69 * Check if all permission specified in the manifest have been granted 70 */ 71 private fun allPermissionsGranted(): Boolean { 72 for (permission in REQUIRED_PERMISSIONS) { 73 if (ContextCompat.checkSelfPermission( 74 this, permission 75 ) != PackageManager.PERMISSION_GRANTED 76 ) { 77 return false 78 } 79 } 80 return true 81 } 82} 实现照相的功能 实现 startCamera 的逻辑\n1 private fun startCamera() { 2 3 // Create configuration object for the viewfinder use case 4 val previewConfig = PreviewConfig.Builder().apply { 5 setTargetAspectRatio(Rational(1, 1)) 6 setTargetResolution(Size(640, 640)) 7 }.build() 8 9 // Build the viewfinder use case 10 val preview = Preview(previewConfig) 11 12 // Every time the viewfinder is updated, recompute layout 13 preview.setOnPreviewOutputUpdateListener { 14 15 // To update the SurfaceTexture, we have to remove it and re-add it 16 val parent = viewFinder.parent as ViewGroup 17 parent.removeView(viewFinder) 18 parent.addView(viewFinder, 0) 19 20 viewFinder.surfaceTexture = it.surfaceTexture 21 updateTransform() 22 } 23 24 // Bind use cases to lifecycle 25 // If Android Studio complains about \u0026#34;this\u0026#34; being not a LifecycleOwner 26 // try rebuilding the project or updating the appcompat dependency to 27 // version 1.1.0 or higher. 28 CameraX.bindToLifecycle(this, preview) 29 } 30 31 private fun updateTransform() { 32 val matrix = Matrix() 33 34 // 计算中心 35 val centerX = viewFinder.width / 2f 36 val centerY = viewFinder.height / 2f 37 38 // 纠正屏幕方向的错误 39 val rotationDegrees = when (viewFinder.display.rotation) { 40 Surface.ROTATION_0 -\u0026gt; 0 41 Surface.ROTATION_90 -\u0026gt; 90 42 Surface.ROTATION_180 -\u0026gt; 180 43 Surface.ROTATION_270 -\u0026gt; 270 44 else -\u0026gt; return 45 } 46 matrix.postRotate(-rotationDegrees.toFloat(), centerX, centerY) 47 48 // 把纠正错误后的矩阵传给viewFinder 49 viewFinder.setTransform(matrix) 50 } 可能遇到的错误:\n1java.lang.NoSuchMethodError: No super method getLifecycle()Landroidx/lifecycle/Lifecycle; in class Landroidx/core/app/ComponentActivity; or its super classes (declaration of \u0026#39;androidx.core.app.ComponentActivity\u0026#39; appears in ........ 在上找到了一个解释\n简单来说, 修改一下依赖\n1// implementation \u0026#39;androidx.appcompat:appcompat:1.0.2\u0026#39; 2 implementation \u0026#39;androidx.appcompat:appcompat:1.1.0-alpha05\u0026#39; 因为 1.0.2 版本中还没有实现 LifecycleOwner 的接口, 然后就可以删掉 Activity 声明上的 LifecycleOwner 了\n1.1.0-alpha05 版本的继承关系图如下:\n然后目前的预览是这样的:\n预览这一步就完成了,相对于以前的 api 来说, 真实的编码量很小\n拍照 接着就是获取当前的画面了\n先添加一个按钮\n1\u0026lt;ImageButton 2 android:id=\u0026#34;@+id/capture_button\u0026#34; 3 android:layout_width=\u0026#34;72dp\u0026#34; 4 android:layout_height=\u0026#34;72dp\u0026#34; 5 android:layout_margin=\u0026#34;24dp\u0026#34; 6 app:srcCompat=\u0026#34;@android:drawable/ic_menu_camera\u0026#34; 7 app:layout_constraintBottom_toBottomOf=\u0026#34;parent\u0026#34; 8 app:layout_constraintEnd_toEndOf=\u0026#34;parent\u0026#34; 9 app:layout_constraintStart_toStartOf=\u0026#34;parent\u0026#34; /\u0026gt; 修改 startCamera 方法\n添加一段代码\n1 // 添加拍照的代码, 这里和预览的相同 2 val imageCaptureConfig = ImageCaptureConfig.Builder() 3 .apply { 4 setTargetAspectRatio(Rational(1, 1)) 5 // setTargetResolution(Size(640, 640)) // 设置这个,但实际获取则会根据这个有所不同,根据注释说明, 会是与目标更接近的一个分辨率, 但是可能会因为设备的不同而造成可能崩溃的问题, 不确定就不设置 6 setCaptureMode(ImageCapture.CaptureMode.MIN_LATENCY) 7 }.build() 8 9 val imageCapture = ImageCapture(imageCaptureConfig) 10 // 设置一个点击事件 11 capture_button.setOnClickListener { 12 val file = File( 13 externalMediaDirs.first(), 14 \u0026#34;${System.currentTimeMillis()}.jpg\u0026#34; 15 ) 16 17 // 捕捉图片 18 imageCapture.takePicture(file, object : ImageCapture.OnImageSavedListener { 19 override fun onError( 20 error: ImageCapture.UseCaseError, 21 message: String, exc: Throwable? 22 ) { 23 val msg = \u0026#34;Photo capture failed: $message\u0026#34; 24 Toast.makeText(baseContext, msg, Toast.LENGTH_SHORT).show() 25 Log.e(\u0026#34;CameraXApp\u0026#34;, msg) 26 exc?.printStackTrace() 27 } 28 29 override fun onImageSaved(file: File) { 30 val msg = \u0026#34;Photo capture succeeded: ${file.absolutePath}\u0026#34; 31 Toast.makeText(baseContext, msg, Toast.LENGTH_SHORT).show() 32 Log.d(\u0026#34;CameraXApp\u0026#34;, msg) 33 } 34 }) 35 } 别忘了修改这里\n1CameraX.bindToLifecycle(this, preview, imageCapture) 然后点击拍照按钮\n12019-05-14 15:20:50.839 13521-13521/top.kikt.camerax.usage D/CameraXApp: Photo capture succeeded: /storage/emulated/0/Android/media/top.kikt.camerax.usage/1557818450473.jpg 可以看到我们成功的拍了一张照片\n使用 adb 命令导出这个图片, 没有配置的话建议你去配置一下\n1adb pull /storage/emulated/0/Android/media/top.kikt.camerax.usage/1557818450473.jpg 2open 1557818450473.jpg 分析器 新建一个分析器类,需要继承 ImageAnalysis.Analyzer\n备注: 这个代码来自于官方示例(开篇那个连接)\n目的是记录平均亮度\n1 2import android.util.Log 3import androidx.camera.core.ImageAnalysis 4import androidx.camera.core.ImageProxy 5import java.nio.ByteBuffer 6import java.util.concurrent.TimeUnit 7 8/// create 2019-05-14 by cai 9class LuminosityAnalyzer : ImageAnalysis.Analyzer { 10 private var lastAnalyzedTimestamp = 0L 11 12 /** 13 * Helper extension function used to extract a byte array from an 14 * image plane buffer 15 */ 16 private fun ByteBuffer.toByteArray(): ByteArray { 17 rewind() // Rewind the buffer to zero 18 val data = ByteArray(remaining()) 19 get(data) // Copy the buffer into a byte array 20 return data // Return the byte array 21 } 22 23 override fun analyze(image: ImageProxy, rotationDegrees: Int) { 24 val currentTimestamp = System.currentTimeMillis() 25 // Calculate the average luma no more often than every second 26 if (currentTimestamp - lastAnalyzedTimestamp \u0026gt;= 27 TimeUnit.SECONDS.toMillis(1) 28 ) { 29 // Since format in ImageAnalysis is YUV, image.planes[0] 30 // contains the Y (luminance) plane 31 val buffer = image.planes[0].buffer 32 // Extract image data from callback object 33 val data = buffer.toByteArray() 34 // Convert the data into an array of pixel values 35 val pixels = data.map { it.toInt() and 0xFF } 36 // Compute average luminance for the image 37 val luma = pixels.average() 38 // Log the new luma value 39 Log.d(\u0026#34;CameraXApp\u0026#34;, \u0026#34;Average luminosity: $luma\u0026#34;) 40 // Update timestamp of last analyzed frame 41 lastAnalyzedTimestamp = currentTimestamp 42 } 43 } 44} 还是回到startCamera方法\n1 2 /// 统计配置 3 val analyzerConfig = ImageAnalysisConfig.Builder().apply { 4 // Use a worker thread for image analysis to prevent glitches 5 val analyzerThread = HandlerThread( 6 \u0026#34;LuminosityAnalysis\u0026#34; 7 ).apply { start() } 8 setCallbackHandler(Handler(analyzerThread.looper)) 9 // In our analysis, we care more about the latest image than 10 // analyzing *every* image 11 setImageReaderMode(ImageAnalysis.ImageReaderMode.ACQUIRE_LATEST_IMAGE) 12 }.build() 13 14 // 设置 15 val analyzerUseCase = ImageAnalysis(analyzerConfig).apply { 16 analyzer = LuminosityAnalyzer() 17 } 别忘了绑定生命周期\n1 // 绑定生命周期和CameraX , 这里第二步修改的时候别忘了把imageCapture 也一起绑定上 2 // 同理,第三步的时候需要绑上分析器 3 CameraX.bindToLifecycle(this, preview, imageCapture, analyzerUseCase) 接着重新运行代码,随着预览的图像不同会呈现一个平均亮度\n12019-05-14 15:37:32.883 14412-14435/top.kikt.camerax.usage D/CameraXApp: Average luminosity: 136.85490234375 22019-05-14 15:37:33.889 14412-14435/top.kikt.camerax.usage D/CameraXApp: Average luminosity: 118.26471354166667 32019-05-14 15:37:34.883 14412-14435/top.kikt.camerax.usage D/CameraXApp: Average luminosity: 137.15953450520834 42019-05-14 15:37:35.934 14412-14435/top.kikt.camerax.usage D/CameraXApp: Average luminosity: 136.98435221354165 52019-05-14 15:37:36.929 14412-14435/top.kikt.camerax.usage D/CameraXApp: Average luminosity: 137.244296875 62019-05-14 15:37:37.964 14412-14435/top.kikt.camerax.usage D/CameraXApp: Average luminosity: 136.60428059895833 72019-05-14 15:37:38.984 14412-14435/top.kikt.camerax.usage D/CameraXApp: Average luminosity: 136.93064127604165 82019-05-14 15:37:39.967 14412-14435/top.kikt.camerax.usage D/CameraXApp: Average luminosity: 125.22169921875 92019-05-14 15:37:41.001 14412-14435/top.kikt.camerax.usage D/CameraXApp: Average luminosity: 115.343046875 102019-05-14 15:37:42.045 14412-14435/top.kikt.camerax.usage D/CameraXApp: Average luminosity: 107.64242838541666 112019-05-14 15:37:43.061 14412-14435/top.kikt.camerax.usage D/CameraXApp: Average luminosity: 76.732939453125 122019-05-14 15:37:44.082 14412-14435/top.kikt.camerax.usage D/CameraXApp: Average luminosity: 112.82620442708334 132019-05-14 15:37:45.105 14412-14435/top.kikt.camerax.usage D/CameraXApp: Average luminosity: 116.12317057291666 142019-05-14 15:37:46.086 14412-14435/top.kikt.camerax.usage D/CameraXApp: Average luminosity: 115.94841796875 152019-05-14 15:37:47.142 14412-14435/top.kikt.camerax.usage D/CameraXApp: Average luminosity: 117.0526171875 162019-05-14 15:37:48.165 14412-14435/top.kikt.camerax.usage D/CameraXApp: Average luminosity: 114.96781901041666 编码结束 到这一步为止, 编码的过程就结束了\n进阶探索 通常来说,相机现在会结合很多其他的用途\n摄像 直播视频上传(视频通话) 图像识别 增强现实 其他... 别看我说的很热闹,但是让我结合这几个方向来写的话,篇幅不允许是一点, 而且这些东西每一行都是能写一整个系列文章的...(我才不会说是我不会做呢, 哼 😒)\n还记得 ImageAnalysis.Analyzer 这个类吗, 这个类的analyze方法会回调一些信息\n简单来说, 会回调一些 image 的信息和角度\nImageProxy 中包含很多的信息\n常用的有:\ngetFormat: 视频格式 ,具体查看 一般来说都应该是YUV_420_888\ngetWidth: 宽度\ngetHeight: 高度\ngetTimeStamp: 据说是纳秒单位, 和设备的时间基有关, 我是没看懂什么意思 😁\ngetPlanes: 视频数据, 类型是PlaneProxy[] kotlin 对应:Array\u0026lt;PlaneProxy\u0026gt;, 这东西的 size 是根据 getFormat 的格式决定的\n关于 YUV_420_888 这部分可以查看 和 然后通过解析数据封装成需要的格式就可以了\n后记 简单来说, CameraX 的 api 比 Camera2 和 Camera 看起来都要好很多\n项目地址: 以上\n","link":"https://kikt.top/posts/android/camera/camerax-usage/","section":"posts","tags":["android","camera","cameraX"],"title":"CameraX的使用"},{"body":"","link":"https://kikt.top/tags/flutter-web/","section":"tags","tags":null,"title":"flutter web"},{"body":"本篇只是的补充\n介绍一些当前的 flutter_web 版和 flutter 的移动版的差别\ndart:io 包无法使用造成的影响 dart:io是一个在 flutter 中常用的包,但是在 web 版中是使用不了的\ndio 不能用 dio包用不了,因为 dio 包是依托于 dart:io 包中的 HttpClient 进行的封装\n并且因为国内很多初学者朋友人云亦云的选择了 dio 作为 http 的请求框架,所以今后如果有打算想要做 flutter_web 版的朋友可能现在就要考虑一下 dio 的使用问题了\n当然 dio 包今后也可以迁移底层访问库为,再进行二次封装形成 dio_with_http 那就是另一个故事了\n另外 web 中的 http 请求可以使用 使用库的访问如下:\n1import \u0026#39;package:http/http.dart\u0026#39; as http; 2Widget fromHttp() { 3 return FutureBuilder\u0026lt;http.Response\u0026gt;( 4 future: http.get(\u0026#34;https://api.github.com/\u0026#34;), 5 builder: (BuildContext context, snapshot) { 6 if (!snapshot.hasData) { 7 return Container(); 8 } 9 var body = snapshot.data.body; 10 return Text(body); 11 }, 12 ); 13 } 以上的代码反馈回来是这样的 使用 HttpRequest:\n1import \u0026#39;dart:html\u0026#39; as html; 2 3Widget buildWithHttpRequest() { 4 var req = html.HttpRequest.getString(\u0026#34;https://api.github.com/\u0026#34;); 5 return FutureBuilder\u0026lt;String\u0026gt;( 6 future: req, 7 builder: (BuildContext context, snapshot) { 8 if (!snapshot.hasData) { 9 return Container(); 10 } 11 var body = snapshot.data; 12 return Column( 13 children: \u0026lt;Widget\u0026gt;[ 14 Text(\u0026#34;使用 HttpRequest 访问的 api\u0026#34;), 15 Text(body), 16 ], 17 ); 18 }, 19 ); 20 } 截图是这样的\n在 flutter_web 浏览器中需要注意的一点是, 无论你使用什么访问框架来访问 http,都会遇到跨域的问题, 跨域问题是一个经典的web前端开发问题, 搜索引擎中的解决方案和完善的说明有很多, 请自行理解\nFile 相关的 api 无法使用 在 flutter 移动版中,经常会遇到需要使用 File 来操作文件的情况,下载/读取文件都需要 File 的支持\nSocket/WebSocket 前面说了 HttpClient 不能用,io 包中还包含 Socket/Websocket, 它们都是 dart:io 的类, 所以都无法使用\ndart:html 包的使用 虽然不建议使用,但是这东西在 flutter_web 中是可用的\n比如,我修改 web/index.html, 添加一个h1标签\n1\u0026lt;!DOCTYPE html\u0026gt; 2\u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; 3 \u0026lt;head\u0026gt; 4 \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; 5 \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; 6 \u0026lt;script defer src=\u0026#34;main.dart.js\u0026#34; type=\u0026#34;application/javascript\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 7 \u0026lt;/head\u0026gt; 8 \u0026lt;body\u0026gt; 9 \u0026lt;h1 id=\u0026#34;tmpId\u0026#34; style=\u0026#34;float: left;position: fixed;z-index: 100;\u0026#34;\u0026gt;你好\u0026lt;/h1\u0026gt; 10 \u0026lt;/body\u0026gt; 11\u0026lt;/html\u0026gt; 然后重新运行代码,得到的是这样的\n接着修改 dart 文件, 引入 html 包\n1import \u0026#39;dart:html\u0026#39; as html; 2 3 _buildHtmlFunWidget() { 4 return FlatButton( 5 child: Text(\u0026#34;操作html元素\u0026#34;), 6 onPressed: () { 7 var e = html.window.document.getElementById(\u0026#34;tmpId\u0026#34;); 8 e.text = this.counter.toString(); 9 }, 10 ); 11 } 这样就可以像传统的 js 一样操作 dom 元素, 然后将数字设置为当前的数字 关于这个包的具体使用请查看 html 包的注释/文档\n这里是一个简单的使用说明 js 包的使用 lib.js 文件:\n1function addNumbers(a, b) { 2 return a + b; 3} 4 5function getFromJS() { 6 return \u0026#39;我是从js来的字符串\u0026#39;; 7} 引入 js 文件\n1\u0026lt;!DOCTYPE html\u0026gt; 2\u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; 3 \u0026lt;head\u0026gt; 4 \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; 5 \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; 6 \u0026lt;script src=\u0026#34;assets/lib.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 7 \u0026lt;script defer src=\u0026#34;main.dart.js\u0026#34; type=\u0026#34;application/javascript\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 8 \u0026lt;/head\u0026gt; 9 \u0026lt;body\u0026gt; 10 \u0026lt;h1 id=\u0026#34;tmpId\u0026#34; style=\u0026#34;float: left;position: fixed;z-index: 100;\u0026#34;\u0026gt;你好\u0026lt;/h1\u0026gt; 11 \u0026lt;/body\u0026gt; 12\u0026lt;/html\u0026gt; dart 文件\n1@JS() 2library lib; 3 4import \u0026#39;package:js/js.dart\u0026#39;; 5 6@JS() 7external String getFromJS(); 8 9@JS() 10external num addNumbers(num a, num b); 11 12void add1And2() { 13 print(addNumbers(1, 2)); 14} 15 16String getJS() { 17 return getFromJS(); 18} dart 文件需要注意一点, 外部直接调用getFromJS方法,addNumbers方法会报错, 需要封装一层 dart 方法\ndart 的 widget\n1 _callJSMethodWidget() { 2 return FlatButton( 3 child: Text(\u0026#34;点击\u0026#34;), 4 onPressed: () { 5 add1And2(); 6 // print(getFromJS()); 7 print(getJS()); 8 }, 9 ); 10 } 这样点击这个按钮后可以看到\n结尾 本篇粗略介绍了一些上篇没有介绍完整的东西\n仓库和上一篇相同: 查看 以上\n","link":"https://kikt.top/posts/flutter/flutter-web/flutter-web2/","section":"posts","tags":["flutter","flutter web"],"title":"Flutter Web 评测第二篇"},{"body":"","link":"https://kikt.top/tags/2.3/","section":"tags","tags":null,"title":"2.3"},{"body":"在最近两天 dart 更新到了 2.3 的稳定版\n增加了一些语法糖,对于开发 flutter 来说会更加的友好\n可以查看 当然,本篇不是翻译,只是对于新语法做一个简单的尝试\n...语法 这个语法很眼熟,在 js 中有类似的语法,其他语言可能也有\n什么意思呢\n看下面的代码\n1main(List\u0026lt;String\u0026gt; arguments) { 2 list3Point(); 3} 4 5void list3Point() { 6 var list1 = \u0026lt;int\u0026gt;[1, 2, 3, 4]; 7 8 var list2 = \u0026lt;int\u0026gt;[ 9 0, 10 ...list1, 11 6, 12 ]; 13 14 print(list2); // [0, 1, 2, 3, 4, 6] 15} 这里可能会提示需要更新 sdk 约束,可能这个特性是 2.2.2 加入的,更新约束后 yaml 文件被修改\n1environment: 2 sdk: \u0026#39;\u0026gt;=2.2.2 \u0026lt;3.0.0\u0026#39; 旧版本的实现需要以下几个步骤\n1void list3PointOld() { 2 var list1 = \u0026lt;int\u0026gt;[1, 2, 3, 4]; 3 var list2 = \u0026lt;int\u0026gt;[0]; 4 list2.addAll(list1); 5 list2.add(6); 6} 个人觉得代码量不是关键,而是更加直观的看到 list 的顺序\n在 flutter 则是这样的:\n1Widget build(BuildContext context) { 2 return Column( 3 children: [ 4 Header(), 5 ...buildMainElements(), 6 Footer(), 7 ], 8 ); 9} if 语法糖 在 flutter 中可能会这样的情况: 如果条件是假,则不显示某个 Widget\n从前在实现的时候,会有各种五花八门的实现\n比如:\n1 2class _HomePageState extends State\u0026lt;HomePage\u0026gt; { 3 String text; 4 5 @override 6 Widget build(BuildContext context) { 7 // return buildColumn(); 8 return Column( 9 children: \u0026lt;Widget\u0026gt;[ 10 text != null ? Text(text) : Container(), 11 ], 12 ); 13 } 14 15 Widget buildColumn(){ 16 var widgets = \u0026lt;Widget\u0026gt;[]; 17 if(text != null) { 18 widgets.add(Text(text)); 19 } 20 return Column( 21 children: widgets, 22 ); 23 } 24} 但是今后最佳实现应该是这样的\n1 2class _HomePageState extends State\u0026lt;HomePage\u0026gt; { 3 String text; 4 5 @override 6 Widget build(BuildContext context) { 7 return Column( 8 children: \u0026lt;Widget\u0026gt;[ 9 if (text != null) Text(text) else Text(\u0026#34;空的\u0026#34;), 10 if (text != null) Text(text), 11 ], 12 ); 13 } 14} 这里有一点要注意, if 条件后不能包含{}, 也就是说,这种语法糖只支持单行, 同时也支持 else 语法\nelse if 的问题:\n1 Widget build(BuildContext context) { 2 return Column( 3 children: \u0026lt;Widget\u0026gt;[ 4 if (text != null) Text(text) else if(text == \u0026#34;\u0026#34;) Text(\u0026#34;空字符串\u0026#34;) else if(text==\u0026#34;1\u0026#34;) Text(\u0026#34;我是1\u0026#34;) else Text(\u0026#34;空的\u0026#34;), 5 ], 6 ); 7 } 尝试上面的方法时,会被格式化为下面这样\n1@override 2 Widget build(BuildContext context) { 3 return Column( 4 children: \u0026lt;Widget\u0026gt;[ 5 if (text != null) 6 Text(text) 7 else 8 if (text == \u0026#34;\u0026#34;) 9 Text(\u0026#34;空字符串\u0026#34;) 10 else 11 if (text == \u0026#34;1\u0026#34;) Text(\u0026#34;我是1\u0026#34;) else Text(\u0026#34;空的\u0026#34;), 12 ], 13 ); 14 } 所以, 这样的情况下 else 会被单独解析,然后把 if 作为下一个 if 语句去解析\n虽然结果应该是相同的,但是尽量避免吧\nfor 语法糖 1 Widget forTest() { 2 return Column( 3 children: \u0026lt;Widget\u0026gt;[ 4 for (var i = 0; i \u0026lt; 10; i++) todoText(i.toString()), 5 ], 6 ); 7 } for 也是只支持单行,不支持{}包裹\n插件 不是语言特性,但是 dart 的 3.0 插件也同步更新了\n支持未导的库直接使用,自动导包\n简单举例:\n以前解析 json 时,需要先导入 dart:convert 包,或输入 json 后,点击提示键使用 import library 'dart:convert' 来导入包, 而且这一步要求你输入全名才能导入,短的好,有的类名/变量名很长, 一次性输入对的难度较大,只要输入错一个字符就不会提示 而现在的操作是会提示 json\n从码代码的角度友好了太多\n另: 有一个这个截图, 我这里 vscode 没有看出变化, 可能 android studio 中会有变化吧\n结尾 flutter 使用的是 flutter sdk 中带的 dart sdk 版本,可以使用 flutter doctor -v 查看, 也可以使用 flutter --version 查看\n要确保你的 flutter sdk 支持\n如果是写插件,建议短时间内不要使用语法糖,以免兼容问题\n以上\n","link":"https://kikt.top/posts/flutter/dart/2-3-new/","section":"posts","tags":["dart","2.3","flutter"],"title":"dart 2.3的新东西"},{"body":"最近 2019 的 google io 大会开始了,之前的\u0026quot;蜂鸟\u0026quot;引擎也在 flutter 官网中出现了, 不过这次改了个名字叫 具体的使用步骤参考项目 readme 中的方式来使用\n构建项目 建议: 配置dart,pub,~/.pub-cache/bin到环境变量\n配置 webdev\n1git clone https://github.com/flutter/flutter_web.git 2cd flutter_web/examples/hello_world/ 3flutter packages upgrade 4flutter packages pub global activate webdev 运行项目 简单运行 运行\n1webdev serve 提示我们,在本地 8080 端口, 在浏览器打开 http://localhost:8080\n默认的 main.dart 比较简单,只有一个 Text 控件\n我这里修改一下 main.dart 文件,达到接近 flutter 移动项目 main.dart 的样子\n1// Copyright 2018 The Chromium Authors. All rights reserved. 2// Use of this source code is governed by a BSD-style license that can be 3// found in the LICENSE file. 4 5import \u0026#39;package:flutter_web/material.dart\u0026#39;; 6 7void main() { 8 runApp(MyApp()); 9} 10 11class MyApp extends StatelessWidget { 12 // This widget is the root of your application. 13 @override 14 Widget build(BuildContext context) { 15 return MaterialApp( 16 title: \u0026#39;Flutter Demo\u0026#39;, 17 theme: ThemeData( 18 primarySwatch: Colors.blue, 19 ), 20 home: MyHomePage(title: \u0026#39;Flutter Demo Home Page\u0026#39;), 21 ); 22 } 23} 24 25class MyHomePage extends StatefulWidget { 26 MyHomePage({Key key, this.title}) : super(key: key); 27 28 final String title; 29 30 @override 31 _MyHomePageState createState() =\u0026gt; _MyHomePageState(); 32} 33 34class _MyHomePageState extends State\u0026lt;MyHomePage\u0026gt; { 35 int counter = 0; 36 TextEditingController controller = TextEditingController(); 37 38 void add() { 39 counter++; 40 setState(() {}); 41 } 42 43 @override 44 Widget build(BuildContext context) { 45 return Scaffold( 46 appBar: AppBar( 47 title: Text(widget.title), 48 ), 49 body: Container( 50 child: Column( 51 children: \u0026lt;Widget\u0026gt;[ 52 // TextField( 53 // controller: controller, 54 // ), 55 Text(counter.toString()), 56 ], 57 ), 58 ), 59 floatingActionButton: FloatingActionButton( 60 onPressed: add, 61 tooltip: \u0026#39;push\u0026#39;, 62 child: Icon(Icons.add), 63 ), 64 ); 65 } 66 67 @override 68 void initState() { 69 super.initState(); 70 print(\u0026#34;${this.runtimeType} initState\u0026#34;); 71 } 72 73 @override 74 void dispose() { 75 print(\u0026#34;${this.runtimeType} dispose\u0026#34;); 76 super.dispose(); 77 } 78} 这里看到了第一个问题, 图标没有显示\n测试交互 然后简单试一下页面的交互\n遇到了第二个问题 文字无法选中, 这个可以理解,因为是自绘引擎, 和网页不一样,文字无法选中是正常的\n文本输入 试一下文本输入\n修改文件的 state 部分\n1 2class MyHomePage extends StatefulWidget { 3 MyHomePage({Key key, this.title}) : super(key: key); 4 5 final String title; 6 7 @override 8 _MyHomePageState createState() =\u0026gt; _MyHomePageState(); 9} 10 11class _MyHomePageState extends State\u0026lt;MyHomePage\u0026gt; { 12 int counter = 0; 13 TextEditingController controller = TextEditingController(); 14 var key = GlobalKey(); 15 void add() { 16 counter++; 17 setState(() {}); 18 ScaffoldState state = key.currentState; 19 state.showSnackBar( 20 SnackBar( 21 content: Text(controller.text), 22 ), 23 ); 24 } 25 26 @override 27 Widget build(BuildContext context) { 28 return Scaffold( 29 key: key, 30 appBar: AppBar( 31 title: Text(widget.title), 32 ), 33 body: Container( 34 child: Column( 35 children: \u0026lt;Widget\u0026gt;[ 36 TextField( 37 controller: controller, 38 ), 39 Text(counter.toString()), 40 ], 41 ), 42 ), 43 floatingActionButton: FloatingActionButton( 44 onPressed: add, 45 tooltip: \u0026#39;push\u0026#39;, 46 child: Icon(Icons.add), 47 ), 48 ); 49 } 50 51 @override 52 void initState() { 53 super.initState(); 54 print(\u0026#34;${this.runtimeType} initState\u0026#34;); 55 } 56 57 @override 58 void dispose() { 59 print(\u0026#34;${this.runtimeType} dispose\u0026#34;); 60 super.dispose(); 61 } 62} 加入了一个 TextField 控件,然后输入文本,接着将文本显示到 snackbar 中,接着点击按钮得到以下的样式\n文本的输入等功能基本能实现\n嗯,中文输入可用,直接用的是系统的输入法,不过输入框没有跟随\n长按输入框位置无效, 双击可以看到 tooltip 的提示 拖动可以部分选择,但部分选择时的弹框没有出现 在 tooltip 显示的情况下拖动可以选择部分文本\n另外测试了一下按钮的功能 copy paste 都无效,暂时没有和 macOS 系统的剪切板关联,其他系统的没测试,未知\n使用系统的复制粘贴全选快捷键(cmd+c, cmd+v, cma+a)是可用的\n图片 网络图片 简单截取一个图片,准备用于项目中,嗯,就是 google io 的演讲视频\n可以看到图片,能够正常显示\n目前为止的代码如下\n1// Copyright 2018 The Chromium Authors. All rights reserved. 2// Use of this source code is governed by a BSD-style license that can be 3// found in the LICENSE file. 4 5import \u0026#39;package:flutter_web/material.dart\u0026#39;; 6 7void main() { 8 runApp(MyApp()); 9} 10 11class MyApp extends StatelessWidget { 12 // This widget is the root of your application. 13 @override 14 Widget build(BuildContext context) { 15 return MaterialApp( 16 title: \u0026#39;Flutter Demo\u0026#39;, 17 theme: ThemeData( 18 primarySwatch: Colors.blue, 19 ), 20 home: MyHomePage(title: \u0026#39;Flutter Demo Home Page\u0026#39;), 21 ); 22 } 23} 24 25class MyHomePage extends StatefulWidget { 26 MyHomePage({Key key, this.title}) : super(key: key); 27 28 final String title; 29 30 @override 31 _MyHomePageState createState() =\u0026gt; _MyHomePageState(); 32} 33 34class _MyHomePageState extends State\u0026lt;MyHomePage\u0026gt; { 35 int counter = 0; 36 TextEditingController controller = TextEditingController(); 37 var key = GlobalKey(); 38 void add() { 39 counter++; 40 setState(() {}); 41 ScaffoldState state = key.currentState; 42 state.showSnackBar( 43 SnackBar( 44 content: Text(controller.text), 45 ), 46 ); 47 } 48 49 @override 50 Widget build(BuildContext context) { 51 return Scaffold( 52 key: key, 53 appBar: AppBar( 54 title: Text(widget.title), 55 ), 56 body: Container( 57 child: Column( 58 children: \u0026lt;Widget\u0026gt;[ 59 TextField( 60 controller: controller, 61 ), 62 Text( 63 counter.toString(), 64 ), 65 Image.network( 66 \u0026#34;https://raw.githubusercontent.com/kikt-blog/image/master/img/20190508104658.png\u0026#34;), 67 ], 68 ), 69 ), 70 floatingActionButton: FloatingActionButton( 71 onPressed: add, 72 tooltip: \u0026#39;push\u0026#39;, 73 child: Icon(Icons.add), 74 ), 75 ); 76 } 77 78 @override 79 void initState() { 80 super.initState(); 81 print(\u0026#34;${this.runtimeType} initState\u0026#34;); 82 } 83 84 @override 85 void dispose() { 86 print(\u0026#34;${this.runtimeType} dispose\u0026#34;); 87 super.dispose(); 88 } 89} 本地资源文件 结论: 使用 Image.asset 失败了,没有图片显示 经群中大佬解说,可以显示\n目前使用约定式目录结构, 和桌面引擎的方式一致\n必须放入web/assets目录下,不用在 pubspec 中声明\n目录结构如下:\n1web 2├── assets 3│ └── images 4│ └── 20190508104658.png 5├── index.html 6└── main.dart 插入控件\n1 Image.asset(R.IMG_20190508104658_PNG), 1/// generate by resouce_generator library, shouldn\u0026#39;t edit. 2class R { 3 /// ![preview](file:///private/tmp/flutter_web/examples/hello_world/web/assets/images/20190508104658.png) 4 static const String IMG_20190508104658_PNG = \u0026#34;images/20190508104658.png\u0026#34;; 5} 内存图片 还是刚刚的图片, 这次经过 base64 编码后直接储存至 dart 文件中\n然后通过如下的方式获取到项目中\n1import \u0026#39;dart:convert\u0026#39;; 2 3import \u0026#39;dart:typed_data\u0026#39;; 4 5Uint8List getImageList(String imageBase64) { 6 return base64.decode(imageBase64); 7} 1// Copyright 2018 The Chromium Authors. All rights reserved. 2// Use of this source code is governed by a BSD-style license that can be 3// found in the LICENSE file. 4 5import \u0026#39;package:flutter_web/material.dart\u0026#39;; 6 7import \u0026#39;const/resource.dart\u0026#39;; 8import \u0026#39;img.dart\u0026#39;; 9 10void main() { 11 runApp(MyApp()); 12} 13 14class MyApp extends StatelessWidget { 15 // This widget is the root of your application. 16 @override 17 Widget build(BuildContext context) { 18 return MaterialApp( 19 title: \u0026#39;Flutter Demo\u0026#39;, 20 theme: ThemeData( 21 primarySwatch: Colors.blue, 22 ), 23 home: MyHomePage(title: \u0026#39;Flutter Demo Home Page\u0026#39;), 24 ); 25 } 26} 27 28class MyHomePage extends StatefulWidget { 29 MyHomePage({Key key, this.title}) : super(key: key); 30 31 final String title; 32 33 @override 34 _MyHomePageState createState() =\u0026gt; _MyHomePageState(); 35} 36 37class _MyHomePageState extends State\u0026lt;MyHomePage\u0026gt; { 38 int counter = 0; 39 TextEditingController controller = TextEditingController(); 40 var key = GlobalKey(); 41 void add() { 42 counter++; 43 setState(() {}); 44 ScaffoldState state = key.currentState; 45 state.showSnackBar( 46 SnackBar( 47 content: Text(controller.text), 48 ), 49 ); 50 } 51 52 static var divider = Container( 53 padding: const EdgeInsets.symmetric(vertical: 10), 54 child: Text(\u0026#34;我是分割线\u0026#34;), 55 decoration: BoxDecoration( 56 border: Border.all( 57 color: Colors.blue, 58 width: 5, 59 ), 60 ), 61 ); 62 63 @override 64 Widget build(BuildContext context) { 65 return Scaffold( 66 key: key, 67 appBar: AppBar( 68 title: Text(widget.title), 69 ), 70 body: Container( 71 child: Column( 72 children: \u0026lt;Widget\u0026gt;[ 73 TextField( 74 controller: controller, 75 ), 76 Text( 77 counter.toString(), 78 ), 79 Image.network( 80 \u0026#34;https://raw.githubusercontent.com/kikt-blog/image/master/img/20190508104658.png\u0026#34;), 81 divider, 82 Image.asset(R.IMG_20190508104658_PNG), 83 divider, 84 Image.memory(getImageList(imageBase64)), 85 ], 86 ), 87 ), 88 floatingActionButton: FloatingActionButton( 89 onPressed: add, 90 tooltip: \u0026#39;push\u0026#39;, 91 child: Icon(Icons.add), 92 ), 93 ); 94 } 95 96 @override 97 void initState() { 98 super.initState(); 99 print(\u0026#34;${this.runtimeType} initState\u0026#34;); 100 } 101 102 @override 103 void dispose() { 104 print(\u0026#34;${this.runtimeType} dispose\u0026#34;); 105 super.dispose(); 106 } 107} 滚动控件 将 Column 替换为 ListView\n支持滚动\n这里有一点要提,如果是刚进这个页面,鼠标的滚轮是无效的,也就是说,你需要在页面中随意点击一下才可以使用滚动滚动这个页面,似乎是为了让控件获得焦点\n我将 ListView 设置为横向滚动,发生了错误,我将 TextField 注释掉以后,恢复了显示\n并且可以正常横向滚动,在 mac 中也支持 shift+滚动的左右滚动\n日志 使用 print 方法在 dart 文件中输出日志\n可以在 chrome 的开发者工具的 console 中看到, 目前表现基本与浏览器中的 console.log 方法输出一致\n几个问题需要注意 数字的类型 1 print(\u0026#34;1 is int : ${1 is int}\u0026#34;); // true 2 print(\u0026#34;1 is double : ${1 is double}\u0026#34;); // true 3 print(\u0026#34;1.0 is int : ${1.0 is int}\u0026#34;); // true 4 print(\u0026#34;1.0 is double : ${1.0 is double}\u0026#34;); // true 5 6 print(1.runtimeType); // int 7 print(1.0.runtimeType); // int 这一点和 flutter, dartVM 中表现不一样,和 js 表现一致\n而 runtimeType 中 1 和 1.0 都是 int 类型\ndart:io 的问题 目前在编译过程中,如果发现了使用 dart:io 包的情况,就会自动忽略这个文件的编译\n日志如下:\n1[WARNING] build_web_compilers:entrypoint on web/main.dart: Skipping compiling flutter_web.examples.hello_world|web/main.dart with ddc because some of its 2transitive libraries have sdk dependencies that not supported on this platform: 3 4flutter_web.examples.hello_world|lib/main.dart 5 6https://github.com/dart-lang/build/blob/master/docs/faq.md#how-can-i-resolve-skipped-compiling-warnings 插件的使用 目前没有成熟的插件系统,也没有完成与纯 flutter 插件的对接\n据说可以调用 js 的库来获取一些结果,\n打包 使用 webdev 打包 $ webdev build\n1webdev build 2[INFO] build_web_compilers:entrypoint on web/main.dart: Running dart2js with --minify --packages=.package-eb297017792c41ff65511a11729f572e -oweb/main.dart.js web/main.dart 3[INFO] build_web_compilers:entrypoint on web/main.dart: Dart2Js finished with: 4 5Compiled 20,702,176 characters Dart to 4,249,785 characters JavaScript in 13.8 seconds 6Dart file (web/main.dart) compiled to JavaScript: web/main.dart.js 7[INFO] Running build completed, took 16.1s 8[INFO] Caching finalized dependency graph completed, took 178ms 9[INFO] Reading manifest at build/.build.manifest completed, took 13ms 10[INFO] Deleting previous outputs in `build` completed, took 93ms 11[INFO] Creating merged output dir `build` completed, took 780ms 12[INFO] Writing asset manifest completed, took 2ms 13[INFO] Succeeded after 17.2s with 9 outputs (2073 actions) 17 秒左右\n在当前 build 文件夹下生成了一些文件\n这些文件直接本地打开 index.html 是跑不起来的\n我这里借助了一个轻量的 web 服务器来做这个事\nserve build\n打开后和运行一样\n看一下 build 文件夹的大小, 这里我要惊叹一声!!! 我... 56m !!!\n其中主要大小集中在packages/$sdk中,有 51m, main.dart.js有 1.2m ,这里因为我放入了那个 base64 的图片字符串充当图片来源, 这个 base64 的字符串在 txt 文件中是 3.2m,所以 main.dart.js 的大小我还算可以接受\nassets 目录是 copy 过来的\n使用 gz 格式压缩完有 11.4mb\n所以这个称之为\u0026quot;开发者预览\u0026quot;是有道理的,后续看怎么优化大小吧,简单来说,这个大小即使在压缩完后也是不能接受的...\n查看一下 html 结构 这里使用 web 开发者工具看看\n整体是一个控件,看来是和 iOS android 一样,直接绘制的\n右边看到有一个 input 控件,然后 tanslate 了很长的距离, 应该是用于和内部输入框做双向绑定,以实现复制粘贴,光标等操作的双向绑定关系\n后记 简单来说,有一些 bug 和不足\nIcons 的图标不显示 文本不能选中 输入框的交互太移动端了 不支持插件 打包太大了 仓库在这, 查看 总结: 可用程度?暂时不可用\n以上\n","link":"https://kikt.top/posts/flutter/flutter-web/flutter-web1/","section":"posts","tags":["flutter","flutter web"],"title":"Flutter Web 评测第一篇"},{"body":"OKToast 是一款 在 flutter 上 使用的 toast 插件\n使用简单, 可定制性强, 纯 flutter, 调用不用 context\n安装 查看文档: 在 pubspec 引入\n1dependencies: 2 oktoast: ^2.2.0 # 这一步请查询pub的最新版本 获取包: $ flutter packages get\n引入: import 'package:oktoast/oktoast.dart';\n使用 在代码中定义 OKToast 组件 包裹你的 MaterialApp,不是包裹你的 Scaffold\n包裹你的 MaterialApp,不是包裹你的 Scaffold\n包裹你的 MaterialApp,不是包裹你的 Scaffold\n1class MyApp extends StatelessWidget { 2 @override 3 Widget build(BuildContext context) { 4 return OKToast( // 这一步 5 child: new MaterialApp( 6 title: \u0026#39;Flutter Demo\u0026#39;, 7 theme: new ThemeData( 8 primarySwatch: Colors.blue, 9 ), 10 home: new MyHomePage(), 11 ), 12 ); 13 } 14} 这一步解释一下,因为一般情况下,一个 flutter 应用应该只有一个 MaterialApp(或是 WidgetsApp/CupertinoApp), 这里包裹后,可以缓存 Context 到 内存中,后续在调用显示时,不用传入 BuildContext\n这样能满足一部分用户在无 context 的情况下调用 showToast 方法\n调用 文本 toast 1showToast(\u0026#34;hello world\u0026#34;); // 可选属性看自己需求 自定义 widget 1Widget widget = Center( 2 child:Container( 3 color:Colors.white, 4 child:Icon(Icons.add), 5 ), 6); 7showToastWidget(widget); 使用如下代码的效果\n1 2 void _showCustomWidgetToast() { 3 var w = Center( 4 child: Container( 5 padding: const EdgeInsets.all(5), 6 color: Colors.black.withOpacity(0.7), 7 child: Row( 8 children: \u0026lt;Widget\u0026gt;[ 9 Icon( 10 Icons.add, 11 color: Colors.white, 12 ), 13 Text( 14 \u0026#39;添加成功\u0026#39;, 15 style: TextStyle(color: Colors.white), 16 ), 17 ], 18 mainAxisSize: MainAxisSize.min, 19 ), 20 ), 21 ); 22 showToastWidget(w); 23 } 简单的 toast 实现 其实简单的方案,直接使用 Overlay 就可以了,不需要插件只需要一个简单的工具类,而且代码量并不大\n1class ToastHelper { 2 static void showToast(BuildContext context, String text) { 3 const style = TextStyle(color: Colors.white, fontSize: 14.0); 4 5 Widget widget = Center( 6 child: Container( 7 color: Colors.black.withOpacity(0.5), 8 padding: const EdgeInsets.symmetric(vertical: 5.0, horizontal: 10.0), 9 child: Text( 10 text, 11 style: style, 12 ), 13 ), 14 ); 15 var entry = OverlayEntry( 16 builder: (_) =\u0026gt; widget, 17 ); 18 19 Overlay.of(context).insert(entry); 20 21 Timer(const Duration(seconds: 2), () { 22 entry?.remove(); 23 }); 24 } 25} 那么为什么要用 OKToast 呢?\n不用 context,方便一些在网络层的提示 比较方便的自定义,支持自建 widget 有一些小特性,比如软键盘弹出时自动移动位置防遮挡 支持手动隐藏 toast 进阶使用 隐藏已出现的 toast 有如下的方式可以隐藏\n隐藏所有的 toast 手动隐藏:调用这个方法就可以关闭所有的 toast 了\n1dismissAllToast(); 在显示 toast 时隐藏之前显示的所有 toast,其实是根据这个参数在方法内调用dismissAllToast\n1showToast(\u0026#34;msg\u0026#34;, dismissOtherToast: true); 全局设置隐藏之前的属性,这里设置后,每次当你显示新的 toast 时,旧的就会被关闭\n1OKToast( 2 dismissOtherOnShow: true, 3 ... 4) 隐藏单独的 toast 每一个 showToast/showToastWidget 方法会有一个返回值,类型是 ToastFuture\n1var future = showToast(\u0026#34;msg\u0026#34;); 2future.dismiss(); // 隐藏指定的toast 自定义属性 OKToast 组件有丰富的自定义属性\nbackgroundColor: 背景颜色\nduration: 延迟隐藏时间\nonDismiss: 隐藏时的回调\nposition: toast 的位置\nradius: 圆角的尺寸\ntextAlign: 文字在内部的对齐方式\ntextDirection: ltr 或 rtl\ntextPadding: 文本距离边框的 padding\ntextStyle: 文本的样式\n本文完整的 main.dart 1import \u0026#39;dart:async\u0026#39;; 2 3import \u0026#39;package:flutter/material.dart\u0026#39;; 4import \u0026#39;package:oktoast/oktoast.dart\u0026#39;; 5 6void main() =\u0026gt; runApp(new MyApp()); 7 8class MyApp extends StatelessWidget { 9 // This widget is the root of your application. 10 @override 11 Widget build(BuildContext context) { 12 return OKToast( 13 dismissOtherOnShow: true, 14 child: new MaterialApp( 15 title: \u0026#39;Flutter Demo\u0026#39;, 16 theme: new ThemeData( 17 // This is the theme of your application. 18 // 19 // Try running your application with \u0026#34;flutter run\u0026#34;. You\u0026#39;ll see the 20 // application has a blue toolbar. Then, without quitting the app, try 21 // changing the primarySwatch below to Colors.green and then invoke 22 // \u0026#34;hot reload\u0026#34; (press \u0026#34;r\u0026#34; in the console where you ran \u0026#34;flutter run\u0026#34;, 23 // or press Run \u0026gt; Flutter Hot Reload in IntelliJ). Notice that the 24 // counter didn\u0026#39;t reset back to zero; the application is not restarted. 25 primarySwatch: Colors.blue, 26 ), 27 home: new MyHomePage(title: \u0026#39;Flutter Demo Home Page\u0026#39;), 28 ), 29 ); 30 } 31} 32 33class MyHomePage extends StatefulWidget { 34 MyHomePage({Key key, this.title}) : super(key: key); 35 36 // This widget is the home page of your application. It is stateful, meaning 37 // that it has a State object (defined below) that contains fields that affect 38 // how it looks. 39 40 // This class is the configuration for the state. It holds the values (in this 41 // case the title) provided by the parent (in this case the App widget) and 42 // used by the build method of the State. Fields in a Widget subclass are 43 // always marked \u0026#34;final\u0026#34;. 44 45 final String title; 46 47 @override 48 _MyHomePageState createState() =\u0026gt; new _MyHomePageState(); 49} 50 51class _MyHomePageState extends State\u0026lt;MyHomePage\u0026gt; { 52 int _counter = 0; 53 54 void _showToast() { 55 showToast(\u0026#34;msg\u0026#34;); 56 } 57 58 @override 59 Widget build(BuildContext context) { 60 return Scaffold( 61 appBar: AppBar( 62 title: Text(\u0026#34;OKToast示例\u0026#34;), 63 ), 64 body: ListView( 65 children: \u0026lt;Widget\u0026gt;[ 66 RaisedButton( 67 child: Text(\u0026#39;文字toast\u0026#39;), 68 onPressed: _showToast, 69 ), 70 RaisedButton( 71 child: Text(\u0026#39;自定义Widget Toast\u0026#39;), 72 onPressed: _showCustomWidgetToast, 73 ), 74 RaisedButton( 75 child: Text(\u0026#39;ToastHelper \u0026#39;), 76 onPressed: () =\u0026gt; ToastHelper.showToast(context, \u0026#34;toast helper\u0026#34;), 77 ), 78 ], 79 ), 80 ); 81 } 82 83 void _showCustomWidgetToast() { 84 var w = Center( 85 child: Container( 86 padding: const EdgeInsets.all(5), 87 color: Colors.black.withOpacity(0.7), 88 child: Row( 89 children: \u0026lt;Widget\u0026gt;[ 90 Icon( 91 Icons.add, 92 color: Colors.white, 93 ), 94 Text( 95 \u0026#39;添加成功\u0026#39;, 96 style: TextStyle(color: Colors.white), 97 ), 98 ], 99 mainAxisSize: MainAxisSize.min, 100 ), 101 ), 102 ); 103 showToastWidget(w); 104 } 105} 106 107class ToastHelper { 108 static void showToast(BuildContext context, String text) { 109 const style = TextStyle(color: Colors.white, fontSize: 14.0); 110 111 Widget widget = Center( 112 child: Material( 113 child: Container( 114 color: Colors.black.withOpacity(0.5), 115 padding: const EdgeInsets.symmetric(vertical: 5.0, horizontal: 10.0), 116 child: Text( 117 text, 118 style: style, 119 ), 120 ), 121 ), 122 ); 123 var entry = OverlayEntry( 124 builder: (_) =\u0026gt; widget, 125 ); 126 127 Overlay.of(context).insert(entry); 128 129 Timer(const Duration(seconds: 2), () { 130 entry?.remove(); 131 }); 132 } 133} 和 fluttertoast 的对比 为什么不使用 fluttertoast 呢, 我曾经也给 fluttertoast 提交过 PR\n但是这个插件本身是依赖于原生的,android 端不可避免在默认样式上会受到 rom 的影响,并且各种属性会有兼容问题\n我信奉的原则是,UI 层级的问题,直接在 flutter 端解决\n后记 代码使用并不复杂, 如果对你有帮助解决了问题, 可以给我赞赏 ,请我喝咖啡(下方二维码)\n","link":"https://kikt.top/posts/flutter/toast/oktoast/","section":"posts","tags":["flutter","toast"],"title":"flutter toast插件 OKToast的介绍"},{"body":"","link":"https://kikt.top/tags/toast/","section":"tags","tags":null,"title":"toast"},{"body":" 分支 与很多项目不同, flutter 使用 master 作为开发分支而不是发布分支\nflutter 有几个主要的 branch:\nmaster: 主分支,开发分支\ndev: 发布第二快的分支, 每次的版本更新会优先发布到这个频道来, 主要给 flutter 尝鲜开发者使用\nbeta: 测试分支, 这个分支更新相对缓慢\nstable: 可以在生产环境使用的, 相对问题最少,发布次数最少\n对比 flutter 更新速度很快,几乎每天都有 commit, 间隔几天就会有一个新版本释出\nflutter 以 v 开头,数字部分使用标准的三段版本号 vx.x.x\n那么如果我目前是 v1.4.10 但是我想看看新版本相对我使用中的版本都更新了什么东西怎么办?\n现在 dev 分支最新版是 v1.4.14,那么我可以通过\n可以通过 类似下面的连接把版本号替换为你需要对比的即可,前小后大,然后在浏览器中打开即可\n这其中有 53 次提交,后面有对应的提交记录日志,这个顺序是由早到晚\n源码的话,则点击 Files Changes,就可以看到修改内容\n点击下路蓝框的位置可以切换视图模式,列表还是详情 然后左边绿色是添加的内容,红色是删除的内容,白色是不变的内容,蓝色是折叠起来的不变内容\nrss 订阅 github 的 release 支持 rss 订阅\n我使用了这个 来订阅 flutter sdk 的更新\n另外本站也支持 rss 订阅 后记 简单的说了下如何查看 flutter 更新,当然这个小技巧也适用于其他的 github 仓库\n以上\n","link":"https://kikt.top/posts/flutter/compare/version-compare/","section":"posts","tags":["flutter","github"],"title":"Flutter 版本更新内容查看"},{"body":"所有的分析基于当前的 1.4.7 版本,flutter sdk 的版本更新可能会修改这个文件\n1Flutter 1.4.7 • channel dev • https://github.com/flutter/flutter.git 2Framework • revision 1bfa2f2311 (3 days ago) • 2019-03-29 10:05:18 -0700 3Engine • revision c4d14a0071 4Tools • Dart 2.2.1 (build 2.2.1-dev.2.0 None) 这个文件是 sdk 中的 android 部分的配置文件文件,简单分析一下流程,以便于魔改或在项目中可以配置项目\ngradle 使用的是 groovy 的语法,是一个 jvm 语言,在语法层级上兼容 Java 语法\n换句话说 System.out.println(\u0026quot;hello world\u0026quot;); 这样的方法是可用的\n分析 flutter 项目 项目 android/app/build.gradle 文件中都有定义\n1def localProperties = new Properties() 2def localPropertiesFile = rootProject.file(\u0026#39;local.properties\u0026#39;) 3if (localPropertiesFile.exists()) { 4 localPropertiesFile.withReader(\u0026#39;UTF-8\u0026#39;) { reader -\u0026gt; 5 localProperties.load(reader) 6 } 7} 8 9def flutterRoot = localProperties.getProperty(\u0026#39;flutter.sdk\u0026#39;) 10if (flutterRoot == null) { 11 throw new GradleException(\u0026#34;Flutter SDK not found. Define location with flutter.sdk in the local.properties file.\u0026#34;) 12} 13 14def flutterVersionCode = localProperties.getProperty(\u0026#39;flutter.versionCode\u0026#39;) 15if (flutterVersionCode == null) { 16 flutterVersionCode = \u0026#39;1\u0026#39; 17} 18 19def flutterVersionName = localProperties.getProperty(\u0026#39;flutter.versionName\u0026#39;) 20if (flutterVersionName == null) { 21 flutterVersionName = \u0026#39;1.0\u0026#39; 22} 23 24apply plugin: \u0026#39;com.android.application\u0026#39; 25apply from: \u0026#34;$flutterRoot/packages/flutter_tools/gradle/flutter.gradle\u0026#34; // 这句代表了引入flutter.gradle到项目中,路径是 build.gradle 是 gradle 项目的主文件,关于 gradle 和相关说明可以自行搜索,这个体系很庞大,展开介绍不太现实\n前面的基本都是 groovy 语法\ndef 是 groovy 中的关键字,可以简单理解为和 dart 中的 var 同义\n读取 local.properties,然后在 properties 中查找 flutter 的 sdk 目录,如果没有就报错退出\n然后是读取 properties 中定义的 versionCode 和 versionName\n后面就是\u0026quot;引用\u0026quot; flutter.gradle 到项目中,通过这样的过程,flutter.gradle 的内容就被引入项目中了\nflutter.gradle 的路径需要在 flutter sdk 目录下搜索 packages/flutter_tools/gradle/flutter.gradle\n分析 flutter.gradle 开始是一些导包之类的相关代码\n最后一行是一句关键的代码,引入插件FlutterPlugin,这个是告诉 gradle,我需要引入这个插件\n这个插件就定义在这个文件内\n查看主要的方法也就是 apply 方法,可以简单的理解为回调方法,处理整个项目\n1 @Override 2 void apply(Project project) { 3 // Add custom build types 4 // 定义一些buildType 5 project.android.buildTypes { 6 profile { 7 initWith debug //初始化参数来自于debug 8 if (it.hasProperty(\u0026#39;matchingFallbacks\u0026#39;)) { 9 matchingFallbacks = [\u0026#39;debug\u0026#39;, \u0026#39;release\u0026#39;] 10 } 11 } 12 dynamicProfile { 13 initWith debug 14 if (it.hasProperty(\u0026#39;matchingFallbacks\u0026#39;)) { 15 matchingFallbacks = [\u0026#39;debug\u0026#39;, \u0026#39;release\u0026#39;] 16 } 17 } 18 dynamicRelease { 19 initWith debug 20 if (it.hasProperty(\u0026#39;matchingFallbacks\u0026#39;)) { 21 matchingFallbacks = [\u0026#39;debug\u0026#39;, \u0026#39;release\u0026#39;] 22 } 23 } 24 } 25 26 String flutterRootPath = resolveProperty(project, \u0026#34;flutter.sdk\u0026#34;, System.env.FLUTTER_ROOT) 27 // 查询flutter sdk的地址,如果没有定义,就查看FLUTTER_ROOT的环境变量,都没有就报错 28 if (flutterRootPath == null) { 29 throw new GradleException(\u0026#34;Flutter SDK not found. Define location with flutter.sdk in the local.properties file or with a FLUTTER_ROOT environment variable.\u0026#34;) 30 } 31 flutterRoot = project.file(flutterRootPath) 32 if (!flutterRoot.isDirectory()) { //不是文件夹说明sdk地址不对,也报错 33 throw new GradleException(\u0026#34;flutter.sdk must point to the Flutter SDK directory\u0026#34;) 34 } 35 36 // flutter的执行文件,windows执行bat,其他的执行flutter 37 String flutterExecutableName = Os.isFamily(Os.FAMILY_WINDOWS) ? \u0026#34;flutter.bat\u0026#34; : \u0026#34;flutter\u0026#34; 38 flutterExecutable = Paths.get(flutterRoot.absolutePath, \u0026#34;bin\u0026#34;, flutterExecutableName).toFile(); 39 40 41 if (project.hasProperty(\u0026#39;localEngineOut\u0026#39;)) { // 这里可以理解为自定义engine,应该是用于engine开发或深度定制engine的情况, 普通的flutter使用者直接看else 42 String engineOutPath = project.property(\u0026#39;localEngineOut\u0026#39;) 43 File engineOut = project.file(engineOutPath) 44 if (!engineOut.isDirectory()) { 45 throw new GradleException(\u0026#39;localEngineOut must point to a local engine build\u0026#39;) 46 } 47 flutterJar = Paths.get(engineOut.absolutePath, \u0026#34;flutter.jar\u0026#34;).toFile() 48 if (!flutterJar.isFile()) { 49 throw new GradleException(\u0026#39;Local engine build does not contain flutter.jar\u0026#39;) 50 } 51 52 localEngine = engineOut.name 53 localEngineSrcPath = engineOut.parentFile.parent 54 55 project.dependencies { 56 if (project.getConfigurations().findByName(\u0026#34;api\u0026#34;)) { 57 api project.files(flutterJar) 58 } else { 59 compile project.files(flutterJar) 60 } 61 } 62 } else { //普通使用者 63 Path baseEnginePath = Paths.get(flutterRoot.absolutePath, \u0026#34;bin\u0026#34;, \u0026#34;cache\u0026#34;, \u0026#34;artifacts\u0026#34;, \u0026#34;engine\u0026#34;) 64 String targetArch = \u0026#39;arm\u0026#39; 65 if (project.hasProperty(\u0026#39;target-platform\u0026#39;) \u0026amp;\u0026amp; 66 project.property(\u0026#39;target-platform\u0026#39;) == \u0026#39;android-arm64\u0026#39;) { 67 // 这里是判断类型,如果有target-platform属性,且属性是arm64,则认为目标类型是arm64,否则默认是arm 68 targetArch = \u0026#39;arm64\u0026#39; 69 } 70 debugFlutterJar = baseEnginePath.resolve(\u0026#34;android-${targetArch}\u0026#34;).resolve(\u0026#34;flutter.jar\u0026#34;).toFile() 71 profileFlutterJar = baseEnginePath.resolve(\u0026#34;android-${targetArch}-profile\u0026#34;).resolve(\u0026#34;flutter.jar\u0026#34;).toFile() 72 releaseFlutterJar = baseEnginePath.resolve(\u0026#34;android-${targetArch}-release\u0026#34;).resolve(\u0026#34;flutter.jar\u0026#34;).toFile() 73 dynamicProfileFlutterJar = baseEnginePath.resolve(\u0026#34;android-${targetArch}-dynamic-profile\u0026#34;).resolve(\u0026#34;flutter.jar\u0026#34;).toFile() 74 dynamicReleaseFlutterJar = baseEnginePath.resolve(\u0026#34;android-${targetArch}-dynamic-release\u0026#34;).resolve(\u0026#34;flutter.jar\u0026#34;).toFile() 75 76 // 这些就是指定flutter.jar的类型 77 78 if (!debugFlutterJar.isFile()) { 79 project.exec { 80 executable flutterExecutable.absolutePath 81 args \u0026#34;--suppress-analytics\u0026#34; 82 args \u0026#34;precache\u0026#34; 83 } 84 if (!debugFlutterJar.isFile()) { //类型不对就报错 85 throw new GradleException(\u0026#34;Unable to find flutter.jar in SDK: ${debugFlutterJar}\u0026#34;) 86 } 87 } 88 89 // Add x86/x86_64 native library. Debug mode only, for now. 90 // 如果是debug的情况下,添加一个task用于copy x86/x86_64的so库到apk内 91 flutterX86Jar = project.file(\u0026#34;${project.buildDir}/${AndroidProject.FD_INTERMEDIATES}/flutter/flutter-x86.jar\u0026#34;) 92 Task flutterX86JarTask = project.tasks.create(\u0026#34;${flutterBuildPrefix}X86Jar\u0026#34;, Jar) { 93 destinationDir flutterX86Jar.parentFile 94 archiveName flutterX86Jar.name 95 from(\u0026#34;${flutterRoot}/bin/cache/artifacts/engine/android-x86/libflutter.so\u0026#34;) { 96 into \u0026#34;lib/x86\u0026#34; 97 } 98 from(\u0026#34;${flutterRoot}/bin/cache/artifacts/engine/android-x64/libflutter.so\u0026#34;) { 99 into \u0026#34;lib/x86_64\u0026#34; 100 } 101 } 102 // Add flutter.jar dependencies to all \u0026lt;buildType\u0026gt;Api configurations, including custom ones 103 // added after applying the Flutter plugin. 104 project.android.buildTypes.each { addFlutterJarApiDependency(project, it, flutterX86JarTask) } 105 project.android.buildTypes.whenObjectAdded { addFlutterJarApiDependency(project, it, flutterX86JarTask) } 106 } 107 108 project.extensions.create(\u0026#34;flutter\u0026#34;, FlutterExtension) 109 project.afterEvaluate this.\u0026amp;addFlutterTask 110 111 // 这里是处理flutter插件, .flutter-plugins这个文件由flutter维护,来源于flutter项目中的pubspec.yaml 112 File pluginsFile = new File(project.projectDir.parentFile.parentFile, \u0026#39;.flutter-plugins\u0026#39;) 113 Properties plugins = readPropertiesIfExist(pluginsFile) 114 115 plugins.each { name, _ -\u0026gt; 116 def pluginProject = project.rootProject.findProject(\u0026#34;:$name\u0026#34;) 117 if (pluginProject != null) { 118 // 这里两个循环就是将依赖需要的库引入当前项目内 119 project.dependencies { 120 if (project.getConfigurations().findByName(\u0026#34;implementation\u0026#34;)) { 121 implementation pluginProject 122 } else { 123 compile pluginProject 124 } 125 } 126 pluginProject.afterEvaluate { 127 pluginProject.android.buildTypes { 128 profile { 129 initWith debug 130 } 131 } 132 } 133 pluginProject.afterEvaluate this.\u0026amp;addFlutterJarCompileOnlyDependency 134 } else { 135 project.logger.error(\u0026#34;Plugin project :$name not found. Please update settings.gradle.\u0026#34;) 136 } 137 } 138 } 我简单对于 apply 方法进行了分析加了一些注释\n后记 很多东西需要对于 groovy 语法和 gradle 构建体系有所了解才能看懂,当然我也是萌新一枚,有错误或需要讨论可以留言\n以上\n","link":"https://kikt.top/posts/flutter/android/flutter.gradle/","section":"posts","tags":["gradle","flutter"],"title":"Flutter flutter.gradle分析"},{"body":"","link":"https://kikt.top/tags/dialog/","section":"tags","tags":null,"title":"dialog"},{"body":"说了 showDialog 方法的使用\n但是这个方法有很多东西是固定的\n比如背景颜色,转换的时长和样式等等,很多东西你很难去自定义\n本篇我使用另一个方法showGeneralDialog来做一些自定义\n准备工作 同上一章一样,定义一个通用方法\n1Widget buildButton( 2 String text, 3 Function onPressed, { 4 Color color = Colors.white, 5}) { 6 return FlatButton( 7 color: color, 8 child: Text(text), 9 onPressed: onPressed, 10 ); 11} 简单使用 这里有几个参数,虽然方法签名上只有 2 个@required注解的参数\n但事实上,在我当前的版本环境下,如下代码中所有的参数都是必填项,不填会报错 我的运行环境是这样的\n1flutter --version 2Flutter 1.3.14 • channel dev • https://github.com/flutter/flutter.git 3Framework • revision 8e7e435706 (6 days ago) • 2019-03-21 15:31:46 -0700 4Engine • revision d4d4883216 5Tools • Dart 2.2.1 (build 2.2.1-dev.2.0 None) 代码在这里\n1showGeneralDialog( 2 context: context, 3 barrierLabel: \u0026#34;你好\u0026#34;, 4 barrierDismissible: true, 5 transitionDuration: Duration(milliseconds: 300), 6 pageBuilder: (BuildContext context, Animation animation, 7 Animation secondaryAnimation) { 8 return Center( 9 child: Material( 10 child: Container( 11 color: Colors.black.withOpacity(animation.value), 12 child: Text(\u0026#34;我是一个可变的\u0026#34;), 13 ), 14 ), 15 ); 16 }, 17 ); 18}; 这里就是弹出的 dialog 了\n这里有一个背景色的选项\n1showGeneralDialog( 2 context: context, 3 barrierLabel: \u0026#34;你好\u0026#34;, 4 barrierDismissible: true, 5 transitionDuration: Duration(milliseconds: 1000), //这个是时间 6 barrierColor: Colors.black.withOpacity(0.5), // 添加这个属性是颜色 7 pageBuilder: (BuildContext context, Animation animation, 8 Animation secondaryAnimation) { 9 return Center( 10 child: Material( 11 child: Container( 12 color: Colors.black.withOpacity(animation.value), 13 child: Text(\u0026#34;我是一个可变的\u0026#34;), 14 ), 15 ), 16 ); 17 }, 18); 分析一下属性的作用 context 这个不方便展开解释,可以自己查找 context 的相关文章\nbarrierLabel 分析一下这个东西的用处 这里有一个 override,说明虽然属性是私有的,但是父类中可以获取到这个属性\n最终到达父类的 ModalRoute 看注释的说法,这个是用于语义化的\nbarrierDismissible 是否可以点击背景关闭\ntransitionDuration 这个是从开始到完全显示的时间\nbarrierColor 背景颜色\npageBuilder 这个参数是一个方法,入参是 context,animation,secondaryAnimation,返回一个 Widget\n这个 Widget 就是显示在页面上的 dialog\ntransitionBuilder 路由显示和隐藏的过程,这里入参是 animation,secondaryAnimation 和 child, 其中 child 是 是 pageBuilder 构建的 widget\n从其他位置进入 代码\n1buildButton(\u0026#34;从左进入\u0026#34;, () =\u0026gt; showDialogWithOffset(handle: fromLeft)), 2buildButton(\u0026#34;从右进入\u0026#34;, () =\u0026gt; showDialogWithOffset(handle: fromRight)), 3buildButton(\u0026#34;从上进入\u0026#34;, () =\u0026gt; showDialogWithOffset(handle: fromTop)), 4buildButton(\u0026#34;从下进入\u0026#34;, () =\u0026gt; showDialogWithOffset(handle: fromBottom)), 5buildButton(\u0026#34;从左上进入\u0026#34;, () =\u0026gt; showDialogWithOffset(handle: fromTopLeft)), 1typedef Offset OffsetHandle(Animation animation); 1showDialogWithOffset({OffsetHandle handle = fromLeft}) { 2 showGeneralDialog( 3 context: context, 4 barrierColor: Colors.black.withOpacity(0.5), 5 barrierLabel: \u0026#34;\u0026#34;, 6 barrierDismissible: true, 7 transitionDuration: const Duration(milliseconds: 1000), 8 pageBuilder: ( 9 BuildContext context, 10 Animation animation, 11 Animation secondaryAnimation, 12 ) { 13 return Center( 14 child: Material( 15 child: Container( 16 child: Text(\u0026#34;我是dialog\u0026#34;), 17 ), 18 ), 19 ); 20 }, 21 transitionBuilder: (ctx, animation, _, child) { 22 return FractionalTranslation( 23 translation: handle(animation), 24 child: child, 25 ); 26 }, 27 ); 28} 1Offset fromLeft(Animation animation) { 2 return Offset(animation.value - 1, 0); 3} 4 5Offset fromRight(Animation animation) { 6 return Offset(1 - animation.value, 0); 7} 8 9Offset fromTop(Animation animation) { 10 return Offset(0, animation.value - 1); 11} 12 13Offset fromBottom(Animation animation) { 14 return Offset(0, 1 - animation.value); 15} 16 17Offset fromTopLeft(Animation anim) { 18 return fromLeft(anim) + fromTop(anim); 19} 这里使用了一个 Widget 叫 FractionalTranslation\n接收一个 Offset 作为参数,来移动 child 的 widget\n里面的单位是相对,而不是绝对\n也就是 Offset 的 x=0 时在原地,-1 为左偏移一屏,1 位右偏移一屏\n缩放效果 1showGeneralDialog( 2 context: context, 3 barrierLabel: \u0026#34;\u0026#34;, 4 barrierColor: Colors.black.withOpacity(0.5), 5 transitionDuration: const Duration(milliseconds: 500), 6 barrierDismissible: true, 7 pageBuilder: (BuildContext context, Animation animation, 8 Animation secondaryAnimation) { 9 return Center( 10 child: Image.asset(\u0026#34;assets/demo.png\u0026#34;), 11 ); 12 }, 13 transitionBuilder: (_, anim, __, child) { 14 return ScaleTransition( 15 scale: anim, 16 child: child, 17 ); 18 }, 19); 利用了 Scaletransition 类,里面需要一个Animation\u0026lt;double\u0026gt; 我这里直接把入参的 anim 传过去就可以了\n还支持 alignment 参数,也就是从哪里缩放过来\n简单修改一下能达到如下效果\n1showGeneralDialog( 2 context: context, 3 barrierLabel: \u0026#34;\u0026#34;, 4 barrierColor: Colors.black.withOpacity(0.5), 5 transitionDuration: const Duration(milliseconds: 500), 6 barrierDismissible: true, 7 pageBuilder: (BuildContext context, Animation animation, 8 Animation secondaryAnimation) { 9 return Center( 10 child: Image.asset(\u0026#34;assets/demo.png\u0026#34;), 11 ); 12 }, 13 transitionBuilder: (_, anim, __, child) { 14 return ScaleTransition( 15 alignment: Alignment.bottomCenter, // 添加这个 16 scale: anim, 17 child: child, 18 ); 19 }, 20); 后记 组合利用 showGeneralDialog 的参数可以达成各种酷炫的效果,比如可以结合Transform和Matrix4达到各种效果\n完整代码查看\n以上\n","link":"https://kikt.top/posts/flutter/dialog/dialog-2/","section":"posts","tags":["flutter","dialog"],"title":"Flutter dialog (2) - showGeneralDialog的使用"},{"body":"在应用开发中,或多或少都会遇到需要弹框的问题, 比如:需要用户确认,需要输入一些信息等等的问题,这就要用到 dialog 相关的概念了\n而在 flutter 中,所有可以看见的都是 Widget,dialog 也不例外\n不过和 android 或 iOS 中不同的一点是,Flutter 中 dialog 不是一个单独的类,而是一个可以由你自定义的 Widget\n写在前面 首先为了方便,我定义了一个简单的方法用于构建按钮\n1 Widget buildButton( 2 String text, 3 Function onPressed, { 4 Color color = Colors.white, 5 }) { 6 return FlatButton( 7 color: color, 8 child: Text(text), 9 onPressed: onPressed, 10 ); 11 } showDialog dialog 的方法签名是这样的\n其中 context 和 builder 是必传项\nbuilder 需要返回一个 Widget,这个 Widget 会被作为 dialog 展示在页面上\n比如我简单的写了一个这个方法\n1 showDialog( 2 context: context, 3 builder: (ctx) { 4 return Center( 5 child: Column( 6 mainAxisSize: MainAxisSize.min, 7 children: \u0026lt;Widget\u0026gt;[ 8 buildButton(\u0026#34;返回1\u0026#34;, () {}), 9 buildButton(\u0026#34;返回2\u0026#34;, () {}), 10 ], 11 ), 12 ); 13 }, 14 ); 当我调用这个方法时,会得到这样的样式 这个就是最简单的方法,然后点击外部,dialog 会消失\n添加关闭时的返回值 接着我给按钮添加具体的事件\n修改代码为以下的样子\n1_showDialog() async { 2 var result = await showDialog( 3 context: context, 4 builder: (ctx) { 5 return Center( 6 child: Column( 7 mainAxisSize: MainAxisSize.min, 8 children: \u0026lt;Widget\u0026gt;[ 9 buildButton(\u0026#34;返回1\u0026#34;, () =\u0026gt; Navigator.of(context).pop(1)), 10 buildButton(\u0026#34;返回2\u0026#34;, () =\u0026gt; Navigator.pop(context, 2)), 11 ], 12 ), 13 ); 14 }, 15 ); 16 17 print(\u0026#34;result = $result\u0026#34;); 18 } 然后分别点击 1 2 和外部让 dialog 消失 会得到以下的结果\n不过这个只能让 dialog 显示固定的内容,如果你的 dialog 有内容变化,则使用这个方式就不行了,哪怕是调用 setState 也不会发生变化,这个是因为外部 State 的状态变化不会影响到 dialog 的内容,因为 dialog 是附着至 app 根部的,而不是附着于页面\n结合 StatefulWidget 使用 所以我们 dialog 中也可以使用 StatefulWidget,如同一个页面一样,只是这个页面可能不是全屏的\n我定义了一个简单的 CounterWidget\n1 2class CounterWidget extends StatefulWidget { 3 @override 4 _CounterWidgetState createState() =\u0026gt; _CounterWidgetState(); 5} 6 7class _CounterWidgetState extends State\u0026lt;CounterWidget\u0026gt; { 8 var _counter = 0; 9 10 @override 11 Widget build(BuildContext context) { 12 return Center( 13 child: Column( 14 mainAxisSize: MainAxisSize.min, 15 children: \u0026lt;Widget\u0026gt;[ 16 Material( 17 child: Container( 18 width: 100, 19 height: 100, 20 child: Text( 21 _counter.toString(), 22 style: TextStyle(fontSize: 40), 23 ), 24 alignment: Alignment.center, 25 ), 26 color: Colors.white, 27 ), 28 buildButton(\u0026#34;+1\u0026#34;, () =\u0026gt; setState(() =\u0026gt; _counter++)), 29 buildButton(\u0026#34;-1\u0026#34;, () =\u0026gt; setState(() =\u0026gt; _counter--)), 30 ], 31 ), 32 ); 33 } 34} 并且调用\n1showDialog(context: context, builder: (ctx) =\u0026gt; CounterWidget()); 这里可以看到,一个带状态的控件也是可以被展示在 dialog 中的\n结合 StatefulBuilder 在 flutter 中有一个类,叫 StatefulBuilder\n这个类的 builder 构造中会给一个 state,这个 state 是一个方法,返回 void,传入参数是一个方法,听起来很绕\n大概是这样用\n1var statefulBuilder = StatefulBuilder( 2 builder: (ctx, state) { 3 state(() {}); 4 return Container(); 5 }, 6); 看起来和 setState 很像\n这里我模拟一个 progress 的变化,不过这个进度是由外部传入的\n1_showDialogWithStatefulBuilder() { 2 var progress = 0.0; 3 StateSetter ss; 4 Timer.periodic(Duration(milliseconds: 300), (timer) { 5 progress += 0.1; 6 if (ss != null) { 7 ss(() {}); 8 } 9 if (progress \u0026gt;= 1) { 10 timer.cancel(); 11 ss = null; 12 } 13 }); 14 var sb = StatefulBuilder( 15 builder: (ctx, state) { 16 ss = state; 17 return Center( 18 child: Container( 19 height: 40, 20 child: LinearProgressIndicator( 21 backgroundColor: Colors.white, 22 value: progress, 23 ), 24 ), 25 ); 26 }, 27 ); 28 showDialog(context: context, builder: (ctx) =\u0026gt; sb); 29 } 这里只是简单的演示一个用法,实际应用中,进度条应该是可以多处复用的,应该使用 StatefulWidget 进行复用,而不是简易的使用 StatefulBuilder 来做这件事情,并且,应该在构建时传入 stream 并且监听 stream 为宜,而不应该使用这种 Timer 的形式\nStatefulBuilder 应该用于弹出布局很特殊不太可能复用于其他地方的情况\n使用 iOS 风格 有的同学可能要问了,你这演示都是 MD 风格的,我需要的是苹果风格的, 怎么办?\n在 flutter 中,如果你需要 iOS 风格的,只需要使用 Cupertino 组件即可\n1void showCupertinoDialog() { 2 var dialog = CupertinoAlertDialog( 3 content: Text( 4 \u0026#34;你好,我是你苹果爸爸的界面\u0026#34;, 5 style: TextStyle(fontSize: 20), 6 ), 7 actions: \u0026lt;Widget\u0026gt;[ 8 CupertinoButton( 9 child: Text(\u0026#34;取消\u0026#34;), 10 onPressed: () { 11 Navigator.pop(context); 12 }, 13 ), 14 CupertinoButton( 15 child: Text(\u0026#34;确定\u0026#34;), 16 onPressed: () { 17 Navigator.pop(context); 18 }, 19 ), 20 ], 21 ); 22 23 showDialog(context: context, builder: (_) =\u0026gt; dialog); 24 } 带输入框的 dialog 1 showHasInputDialog() { 2 var widget = Center( 3 child: Container( 4 height: 40, 5 width: double.infinity, 6 child: Material( 7 child: TextField(), 8 ), 9 ), 10 ); 11 showDialog(context: context, builder: (_) =\u0026gt; widget); 12 } 根据软键盘自动变化位置 之前的输入框有一些问题,如果你的弹窗在底部,则弹出的输入框可能会被挡住\n这里需要另一个方法来实现\n1import \u0026#39;package:flutter/material.dart\u0026#39;; 2import \u0026#39;dart:ui\u0026#39; as ui; 3 4class InputDialog extends StatefulWidget { 5 @override 6 _InputDialogState createState() =\u0026gt; _InputDialogState(); 7} 8 9class _InputDialogState extends State\u0026lt;InputDialog\u0026gt; with WidgetsBindingObserver { 10 @override 11 void initState() { 12 super.initState(); 13 WidgetsBinding.instance.addObserver(this); 14 } 15 16 @override 17 void dispose() { 18 WidgetsBinding.instance.removeObserver(this); 19 super.dispose(); 20 } 21 22 @override 23 void didChangeMetrics() { 24 super.didChangeMetrics(); 25 if (this.mounted) setState(() {}); 26 } 27 28 @override 29 Widget build(BuildContext context) { 30 var mediaQueryData = MediaQueryData.fromWindow(ui.window); 31 return AnimatedContainer( 32 color: Colors.transparent, 33 duration: const Duration(milliseconds: 300), 34 padding: EdgeInsets.only(bottom: mediaQueryData.viewInsets.bottom), 35 child: Material(child: TextField()), 36 alignment: Alignment.center, 37 ); 38 } 39} 定义一个 dialog 类,然后监听窗口的变化\n然后在变化的时候动态的修改 padding,以达到输入框永远在界面中心的目的\n后记 完整代码 第一篇主要讲了 showDialog 方法的一些使用方法和建议,以上\n","link":"https://kikt.top/posts/flutter/dialog/dialog-1/","section":"posts","tags":["flutter","dialog"],"title":"Flutter dialog (1) - showDialog的讲解"},{"body":"如果接触过原生开发的朋友可能知道\n最初几年官方推荐使用 sp 作为字体大小的单位，但是事实上经过长时间实践的情况下，大家都开始逐渐使用 dp 作为单位\n这样使用者调整系统字体大小，app 中的文字大小就不会受到影响，出现错误等情况\nflutter 中修改 iOS 中叫动态字体大小,对应辅助功能中的字体大小\nandroid 中叫字体大小\n当你开发完成，又遇到用户修改系统字体大小导致某些地方错位，甚至按钮被挤出屏幕看不见了就是个问题了\n而 flutter 中没有单位的概念，我们应该如何实现这个功能呢\n在 flutter 中，是由 MediaQuery 来实现对应功能的\n1var data = MediaQuery.of(context); 2data.textScaleFactor; //这个就是对应的动态字体大小，我们只需要『修改』这个值就可以了 修改自然是不可能的，这东西都是 final 的，我们要做的就是 flutter 中的通用做法\n1class NoScaleTextWidget extends StatelessWidget { 2 final Widget child; 3 4 const NoScaleTextWidget({ 5 Key key, 6 @required this.child, 7 }) : super(key: key); 8 9 @override 10 Widget build(BuildContext context) { 11 return MaxScaleTextWidget( 12 max: 1.0, 13 child: child, 14 ); 15 } 16} 17 18class MaxScaleTextWidget extends StatelessWidget { 19 final double max; 20 final Widget child; 21 22 const MaxScaleTextWidget({ 23 Key key, 24 this.max = 1.2, 25 @required this.child, 26 }) : super(key: key); 27 28 @override 29 Widget build(BuildContext context) { 30 var data = MediaQuery.of(context); 31 var scale = math.min(max, data.textScaleFactor); 32 return MediaQuery( 33 data: data.copyWith(textScaleFactor: scale), 34 child: child, 35 ); 36 } 37} 我这里的做法就是这样,创建一个组件，在内部修改这个值，然后把你的控件『包』起来\n这里可以是你的 Scaffold，Text 等等的 widget\n不过这样要修改的地方太多，而且后面不好改\n我们可以用一个小技巧，使用 MaterialApp 的 builder 属性\n1class MyApp extends StatefulWidget { 2 @override 3 _MyAppState createState() =\u0026gt; _MyAppState(); 4} 5 6class _MyAppState extends State\u0026lt;MyApp\u0026gt; { 7 @override 8 Widget build(BuildContext context) { 9 return MaterialApp( 10 .... 11 builder: (ctx, w) { 12 return MaxScaleTextWidget( 13 max: 1.0, 14 child: w, 15 ); 16 }, 17 ); 18 } 19} 在这个 builder 中这么写，就可以修改你 app 中的所有控件不受动态字体大小的影响了\n我在 github 有一个 也可查看到代码，需要自备梯子\n后记 动态字体的事情就是这样了\n","link":"https://kikt.top/posts/flutter/layout/dynamic-text/","section":"posts","tags":["动态","flutter"],"title":"flutter取消动态字体大小"},{"body":"","link":"https://kikt.top/tags/%E5%8A%A8%E6%80%81/","section":"tags","tags":null,"title":"动态"},{"body":"","link":"https://kikt.top/tags/androidx/","section":"tags","tags":null,"title":"androidX"},{"body":"","link":"https://kikt.top/tags/migrate/","section":"tags","tags":null,"title":"Migrate"},{"body":"无论在 android 开发中 还是 flutter 开发中,都会面临迁移 AndroidX 的问题\n官方有一个说明,可以\n下面是我总结的修改方式\n迁移到 androidX 修改 andorid 目录下的 app/build.gradle 1android{ 2 compileSdkVersion 28 3} 使用了 gradle wrapper 如果 andorid 根目录下有这个文件夹/文件,则需要修改\n根据官网说明,最好修改到 4.10.1 以上\ngradle-wrapper.properties 文件\n修改版本号位置,我使用的是当前的最新版 5.2.1,你可以根据你的情况修改\n1distributionUrl=https\\://services.gradle.org/distributions/gradle-5.2.1-all.zip 如果没有用这个,那么你需要修改的环境变量中的 gradle 版本,这个请自行百度/Google\n修改 android 目录下的 build.gradle 根目录下的 build.gradle ,这个是目前的最新版\n这个不是 gradle 的版本,你可以理解为与插件匹配,一般等于你的 android studio 的版本\n1buildscript{ 2 dependencies { 3 classpath \u0026#39;com.android.tools.build:gradle:3.3.1\u0026#39; 4 } 5} 修改 android 目录下的 gradle.properties 如果没有,就添加这两行\n1android.enableJetifier=true 2android.useAndroidX=true 最后 做完上面的应该就可以了,运行下项目,如果有别的问题欢迎留言\n","link":"https://kikt.top/posts/flutter/migrate-android-x/","section":"posts","tags":["flutter","androidX","Migrate"],"title":"Migrating to AndroidX"},{"body":"最近闲来无事,撸了一个日志插件,功能很简单\n在开发机上开启一个服务端\n然后客户端(不仅是 flutter,而是只要可以使用dart:io就可以)开启远程连接,然后就可以发送日志到服务端了\n好处 这样的好处是,开发机可以实时接收到日志,并且保存到文件中\n因为我们很多时候会发生日志超出一个长度(好像是 1000 个),然后在 console 中不能完整显示的问题,比如网络网文请求,如果响应的报文不完整就不能复制出完整的 json,有的错误不太好定位\n使用这个插件后,就可以在开发机简单的通过命令保存日志,方便后续定位\n只要你的客户端可以访问到服务端,这就能实现\n开发过程 使用WebSocket连接,这个类在 dart 中依托于dart:io包,所以如果你是dart web,可能就用不了这个了,flutter和dart vm中是没问题的\n这个库支持使用 pub global, 配置 dart 和 pub 到环境变量后可以直接通过log4d在命令行中开启\n安装 1. 安装 参考上的 install 标签\npub global activate log4d\n这一步完成后可以通过log4d,log4d_client 来使用插件\n2.客户端安装 作为一个库来使用, 首先在 pubspec.yaml 中加入依赖\n1dependencies: 2 log4d: ^1.0.3 # 这一步参考最新版 3.获取库 pub get 或 flutter packages get\n4. 导入 import 'package:log4d/log4d.dart';\n使用 简单的使用方式就是服务端在命令行中开启\n1. 开启服务端 log4d -o build/test.log 这样就成功开启了,并且会在接受到日志后将日志保存到指定的目录下\n2. 在 flutter 中使用 封装一个简单的帮助类\n1import \u0026#39;dart:async\u0026#39;; 2 3import \u0026#39;package:log4d/log4d.dart\u0026#39;; 4 5class LogHelper { 6 Log4dClient _client; 7 8 bool isLog = true; 9 10 bool isRemote = true; 11 12 LogHelper._() { 13 _client = Log4dClient(); 14 } 15 16 Future connectRemote() async { 17 await _client.connect(); 18 } 19 20 static LogHelper _instance; 21 22 factory LogHelper() { 23 _instance ??= LogHelper._(); 24 return _instance; 25 } 26 27 void info(String msg) { 28 if (isLog) print(msg); 29 30 if (isLog \u0026amp;\u0026amp; isRemote) { 31 _client.sendEntity( 32 LogEntity() 33 ..level = Level.info 34 ..msg = msg, 35 ); 36 } 37 } 38} 3. 在 main 方法中初始化帮助类 1var log = LogHelper(); 2void main() async { 3 await log.connectRemote(); 4 5 log.info(\u0026#34;你好\u0026#34;); 6 runApp(MyApp()); 7} 后续只需要调用log.info('msg');就可以将日志发送到开发端\n控制台会有日志显示,还会实时写入文件\n关于插件 本身只是为了临时调试开发的插件,所以不支持太多的定制化选项,时间也只记录时分秒,不包含日期\n如果真的有别的需求,欢迎在项目的 issue 中提交 不保证开发 😉\n后记 本篇主要使用了 pub global 的功能作为命令行,如果有什么命令行的小脚本,又对于 python/shell/node 不太熟悉,完全可以使用 dart 进行开发\n","link":"https://kikt.top/posts/flutter/log/log4d-1/","section":"posts","tags":["flutter","log"],"title":"flutter log4d 日志包的使用"},{"body":"","link":"https://kikt.top/tags/log/","section":"tags","tags":null,"title":"log"},{"body":"","link":"https://kikt.top/tags/pub/","section":"tags","tags":null,"title":"pub"},{"body":"前言 如果你接触过npm/yarn 应该知道,有一些包可以全局使用,就是安装后可以直接用,比如vue-cli这样的应用,应该是用node开发的\n在dart中也可以实现类似的功能, 使用就可以了,在连接中有完整的说明 也有这样的应用程序可以直接使用\n我在这里简单的实战一下,实现一个简单的cli应用程序\n这个程序没什么多余的功能,就简单的实现输入敲击unix获取时间戳\n建立工程前的准备 将dart,pub加入PATH环境变量 需要在环境变量中添加几个东西,添加环境变量的方式自己搜索一下\n一个是dart/bin的目录,你需要在命令行中让dart命令可用\n1➜ ~ dart --version 2Dart VM version: 2.1.0 (Tue Nov 13 18:22:02 2018 +0100) on \u0026#34;macos_x64\u0026#34; 相对应的dart/bin目录下还会有其他的一些工具,包含了pub,这个工具也是会用到的\n1➜ bin pub --version 2Pub 2.1.0 安装dart工程脚手架 $ pub global activate stagehand\n将pub-cache/bin目录加入PATH环境变量 这个目录通常是~/.pub-cache/bin目录\n验证stagehand可用 1➜ bin stagehand 2Stagehand will generate the given application type into the current directory. 3 4usage: stagehand \u0026lt;generator-name\u0026gt; 5 --[no-]analytics Opt out of anonymous usage and crash reporting. 6-h, --help Help! 7 --version Display the version for stagehand. 8 --author The author name to use for file headers. 9 (defaults to \u0026#34;\u0026lt;your name\u0026gt;\u0026#34;) 10 11Available generators: 12 console-full - A command-line application sample. 13 package-simple - A starting point for Dart libraries or applications. 14 server-shelf - A web server built using the shelf package. 15 web-angular - A web app with material design components. 16 web-simple - A web app that uses only core Dart libraries. 17 web-stagexl - A starting point for 2D animation and games. 建立工程 这一步默认你所有的环境变量都配置完毕,dart pub stagehand 都可用\n1mkdir -p /tmp/dart/unix 2cd /tmp/dart/unix 3stagehand console-full 4pub get 5code . 我这里使用vscode打开\n文件夹结构是这样的\n修改两个unix文件\nbin/unix.dart\n1import \u0026#39;package:unix/unix.dart\u0026#39; as unix; 2 3main(List\u0026lt;String\u0026gt; arguments) { 4 print(unix.getUnixTimeString()); 5} lib/unix.dart\n1String getUnixTimeString() { 2 return DateTime.now().millisecondsSinceEpoch.toString(); 3} 执行\n1dart bin/unix.dart 1➜ unix dart bin/unix.dart 21551074662254 这样一个简单的应用程序就开发完了\n本地安装 参考\n1pub global activate --source path /tmp/dart/unix 1➜ unix pub global activate --source path /tmp/dart/unix 2Resolving dependencies... 3Got dependencies! 4Activated unix 0.0.0 at path \u0026#34;/private/tmp/dart/unix\u0026#34;. 运行脚本 1➜ .pub-cache pub global run unix 21551076677872 这样就可以运行名为unix的脚本\n生成应用程序 修改pubspec.yaml 在结尾处添加如下代码\n1executables: 2 unix: 然后在命令行输入\n1➜ unix pub global activate --source path /tmp/dart/unix 2Resolving dependencies... 3Got dependencies! 4Package unix is currently active at path \u0026#34;/private/tmp/dart/unix\u0026#34;. 5Installed executable unix. 6Activated unix 0.0.0 at path \u0026#34;/private/tmp/dart/unix\u0026#34;. 出现 Installed executable unix. 字样,说明可执行文件ok了\n再次输入unix\n1➜ unix 21551077074760 这样unix这个程序就可以直接运行了\n上传应用包 开发完了这个简单的应用包,我们既可以上传到pub了 我们直接使用命令上传应用包,这一步需要保证终端可以科学上网\n1pub publish --server https://pub.dartlang.org 使用 1➜ pub global activate unix 2Package unix is currently active at path \u0026#34;/private/tmp/dart/unix\u0026#34;. 3Resolving dependencies... (3.5s) 4+ unix 1.0.0 5Downloading unix 1.0.0... 6Precompiling executables... 7Precompiled unix:unix. 8Installed executable unix. 9Activated unix 1.0.0. 这样就代表我从官网获取到了unix这个应用程序\n1➜ unix 21551078268562 可以用,说明成功了\n后记 对于flutter开发者来说,这个方案可以创建一些自己的应用包,然后可以使用dart语言来做一些快捷的脚本,毕竟dart语言会比较熟悉\n","link":"https://kikt.top/posts/flutter/dart/bin/pub-global/","section":"posts","tags":["dart","pub"],"title":"Pub Global 创建命令行应用程序"},{"body":"开这篇文章是因为看到这个库被托管在google的仓库下,而且说明是被设计出来替代ScopedModel的,而且更加灵活\n支持Builder模式和StreamBuilder模式,全局,局部都可以\n内部应该是结合InheritedWidget Notification体系实现的\n传统的bloc需要在每一个Repository中创建StreamController和Stream,甚至有的文章中,一个监听的修改需要修改5处,维护起来比较麻烦\n相比较而言Provide维护起来会稍微省事一些\n添加依赖 查看\n1dependencies: 2 provide: ^1.0.1 # 这里的版本查看官方 1flutter packages get 1import \u0026#39;package:provide/provide.dart\u0026#39;; 使用方法 这里以简单的Counter为例 也就是在flutter的hello world工程的基础上来修改\n1. 定义一个Model 这个model需要继承ChangeNotifier\n1 2class Counter with ChangeNotifier { 3 int _value; 4 5 int get value =\u0026gt; _value; 6 7 Counter(this._value); 8 9 void inc() { 10 _value++; 11 notifyListeners(); //父类的方法,发出通知 12 } 13} 2. 定义一个全局的Provide 这里虽然定义在全局,但事实上也可以定义在页面级\n1void main() { 2 var providers = Providers()..provide(Provider.function((ctx) =\u0026gt; Counter(0))); 3 4 runApp( 5 ProviderNode( 6 child: MyApp(), 7 providers: providers, 8 ), 9 ); 10} ProviderNode表示的是提供者\n3. 界面/监听 修改_MyHomePageState\n添加一个方法,用于获取Counter实例\n1Counter get _counter =\u0026gt; Provide.value\u0026lt;Counter\u0026gt;(context); 将原来的Text(_counter)修改一下\n这里的Provide会在Counter发生变化的时候,触发builder回调来更新界面\n1Provide\u0026lt;Counter\u0026gt;( 2 builder: (BuildContext context, Widget child, Counter counter) { 3 return Text( 4 \u0026#39;${counter.value}\u0026#39;, 5 style: Theme.of(context).textTheme.display1, 6 ); 7 }, 8), 4. 发出通知 接着就是发出通知了\n修改floatingActionButton的点击事件\n1floatingActionButton: FloatingActionButton( 2 onPressed: () =\u0026gt; _counter.inc(), 3 tooltip: \u0026#39;Increment\u0026#39;, 4 child: Icon(Icons.add), 5), 这里调用第三步获取的那个Counter,然后调用inc方法\n看到这里,如果之前用过ScopedModel的朋友会问了,这个不是和以前一样吗,我为啥要改呢\n继续修改\n5. Stream模式 这个就很类似于bloc了,只不过model不太一样\n添加一个StreamBuilder\n1StreamBuilder\u0026lt;Counter\u0026gt;( 2 initialData: _counter, 3 stream: Provide.stream\u0026lt;Counter\u0026gt;(context), 4 builder: (BuildContext context, AsyncSnapshot\u0026lt;Counter\u0026gt; snapshot) { 5 return Text( 6 \u0026#39;${snapshot.data.value}\u0026#39;, 7 style: Theme.of(context).textTheme.display1, 8 ); 9 }, 10), 这里initialData是第三步创建的那个,stream是使用Provide.stream\u0026lt;Counter\u0026gt;(context)获取的\nscope 在provide中有一个概念叫scope,类的完整类名叫ProviderScope\n1class ProviderScope { 2 final String _name; 3 4 /// Constructor 5 const ProviderScope(this._name); 6 7 @override 8 String toString() { 9 return \u0026#34;Scope (\u0026#39;$_name\u0026#39;)\u0026#34;; 10 } 11} 这个类的作用就是标识Provider的区域,或者可以理解为给Provider/Provide定义一个作用区域\n只有scope相同的才可以识别\n将state的代码修改一下\n1class _MyHomePageState extends State\u0026lt;MyHomePage\u0026gt; { 2 Counter get _counter =\u0026gt; Provide.value\u0026lt;Counter\u0026gt;(context); 3 4 PageCounter pageCounter = PageCounter(0); 5 PageCounter pageCounter2 = PageCounter(0); 6 var scope1 = ProviderScope(\u0026#34;1\u0026#34;); 7 var scope2 = ProviderScope(\u0026#34;2\u0026#34;); 8 @override 9 Widget build(BuildContext context) { 10 return ProviderNode( 11 providers: Providers() 12 ..provide(Provider.value(pageCounter), scope: scope1) 13 ..provide(Provider.value(pageCounter2), scope: scope2), 14 child: Scaffold( 15 appBar: AppBar( 16 title: Text(widget.title), 17 ), 18 body: Center( 19 child: Column( 20 mainAxisAlignment: MainAxisAlignment.center, 21 children: \u0026lt;Widget\u0026gt;[ 22 Text( 23 \u0026#39;You have pushed the button this many times:\u0026#39;, 24 ), 25 Provide\u0026lt;PageCounter\u0026gt;( 26 scope: scope1, 27 builder: 28 (BuildContext context, Widget child, PageCounter counter) { 29 return Text( 30 \u0026#39;${counter.value}\u0026#39;, 31 style: Theme.of(context).textTheme.display1, 32 ); 33 }, 34 ), 35 Provide\u0026lt;PageCounter\u0026gt;( 36 scope: scope2, 37 builder: 38 (BuildContext context, Widget child, PageCounter counter) { 39 return Text( 40 \u0026#39;${counter.value}\u0026#39;, 41 style: Theme.of(context).textTheme.display1, 42 ); 43 }, 44 ), 45 StreamBuilder\u0026lt;Counter\u0026gt;( 46 initialData: _counter, 47 stream: Provide.stream\u0026lt;Counter\u0026gt;(context), 48 builder: 49 (BuildContext context, AsyncSnapshot\u0026lt;Counter\u0026gt; snapshot) { 50 return Text( 51 \u0026#39;${snapshot.data.value}\u0026#39;, 52 style: Theme.of(context).textTheme.display1, 53 ); 54 }, 55 ), 56 FlatButton( 57 child: Text(\u0026#34;nextPage\u0026#34;), 58 onPressed: () { 59 Navigator.push(context, 60 MaterialPageRoute(builder: (BuildContext context) { 61 return MyHomePage( 62 title: \u0026#34;new page\u0026#34;, 63 ); 64 })); 65 }, 66 ), 67 ], 68 ), 69 ), 70 floatingActionButton: FloatingActionButton( 71 onPressed: () { 72 _counter.inc(); 73 pageCounter.inc(); 74 pageCounter2.rec(); 75 }, 76 tooltip: \u0026#39;Increment\u0026#39;, 77 child: Icon(Icons.add), 78 ), 79 ), 80 ); 81 } 82} 这里定义了两个scope,并在Provide时进行了指定\n1Provide\u0026lt;PageCounter\u0026gt;( 2 scope: scope1, 3 builder: 4 (BuildContext context, Widget child, PageCounter counter) { 5 return Text( 6 \u0026#39;${counter.value}\u0026#39;, 7 style: Theme.of(context).textTheme.display1, 8 ); 9 }, 10), 这样只有当对应scope1的counter发出通知时,这里才会回调,这样就满足了一个页面/一个应用中有两个相同对象的识别问题\n后记 这个插件托管在google仓库下,个人觉得应该是官方很推荐的一种状态管理模式\n欢迎大家入手\n","link":"https://kikt.top/posts/flutter/state/provide-1/","section":"posts","tags":["状态管理","flutter"],"title":"flutter 新状态管理方案 Provide 使用"},{"body":"","link":"https://kikt.top/tags/%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/","section":"tags","tags":null,"title":"状态管理"},{"body":"","link":"https://kikt.top/tags/appcode/","section":"tags","tags":null,"title":"appcode"},{"body":"ios 插件开发可以查看 本篇就不详细介绍了\n众所周知 xcode 这编辑器除了漂亮,其实开发效率来说和 appcode 无法相提并论..\n本篇与插件开发本身无关,目的只是为了加快 appcode 的索引速度,解决方案拉到后面查看\n使用 appcode 开发插件本身很简单,打开插件下的example/ios就可以了,不过这里有一个坑,因为 flutter 使用 link 的方式,可能有数级的../..之类的连接来指向插件文件夹\n这个在 xcode 中可能没问题,但是appcode中有一个索引的概念,这一步会遍历当前关联的所有同级文件,\n而这一步由于相对的关系甚至关联到了~这一级,也就是说会遍历当前用户全部的文件,这一步的速度太慢了,我们必须着手解决\n解决 打开example/ios/Podfile文件\n这个文件是cocoapod的配置文件,使用的是Ruby语言,\n这个文件一般是自动生成的,我们开发过程中正常情况下不需要关注这个文件\n我们需要修改这个文件,查看\n我们不使用 symlinks 的方案,而是采用另一种方案,直接用 path 的方式\n将这个 Podfile 文件改为这样 1 plugin_pods.map { |p| 2 name = p[:name] 3 path = p[:path] 4 specPath = \u0026#34;#{path}/ios/#{name}.podspec\u0026#34; 5 pod p[:name],:path=\u0026gt;specPath 6 } 然后在命令行运行\n1cd example/ios 2pod install 修改完成后是用 app 打开是这样的\n1.12.x 版本 [2020-01-17 更新] 某个版本后, 会提示我们原来的 pod 版本过时了\n这时候, 我们需要移除 example/ios 下的 Podfile 和 Podfile.lock 文件\n然后使用 flutter pub get 创建个新的\n然后用新版本的 Podfile 中修改, 位置和以前差不多\n1 plugin_pods.each do |name, path| 2 specPath = \u0026#34;#{path}/ios/#{name}.podspec\u0026#34; 3 pod name,:path=\u0026gt;specPath 4 end 结语 以上\n","link":"https://kikt.top/posts/flutter/channel/flutter-ios-spec-edit/","section":"posts","tags":["flutter","appcode","index"],"title":"Flutter ios 插件开发 appcode 加快索引速度"},{"body":"","link":"https://kikt.top/tags/index/","section":"tags","tags":null,"title":"index"},{"body":"2019 年春节前最后一更了\n在 dart 中有生成器函数的语法,在很多其他的语言中也有,比如 js c#\n这个语法看上去和 async await 语法很像\n使用的关键字是 async* sync* yield yield*\n官方对于这个语法的说明可以参考这个连接\n其实async await也是一种生成器语法\n生成器语法就是你返回的类型通常情况下和 return 的类型可能不一致\n比如你return 1,但是返回值上却需要写Future\u0026lt;int\u0026gt;\nsync* 在 dart 中可以使用这个便利的生成一个迭代器\n如下所示\n这两种写法是一样的,但是第一个写法会简洁很多\n1main(List\u0026lt;String\u0026gt; arguments) { 2 print(genList()); 3 print(genList2()); 4} 5 6Iterable\u0026lt;int\u0026gt; genList({int max = 10}) sync* { 7 var i = 0; 8 while (i \u0026lt; max) { 9 yield i; 10 i++; 11 } 12} 13 14Iterable\u0026lt;int\u0026gt; genList2({int max = 10}) { 15 var list = \u0026lt;int\u0026gt;[]; 16 var i = 0; 17 while (i \u0026lt; max) { 18 list.add(i); 19 i++; 20 } 21 return list.map((i) =\u0026gt; i); 22} async* 这个返回值是一个 Stream\n1main(List\u0026lt;String\u0026gt; arguments) { 2 print(genList()); 3 print(genList2()); 4 5 genStream().listen((data) { 6 print(\u0026#34;stream1 : $data\u0026#34;); 7 }); 8 9 genStream2().listen((data) { 10 print(\u0026#34;stream2 : $data\u0026#34;); 11 }); 12} 13 14 15Stream\u0026lt;int\u0026gt; genStream({int max = 10}) async* { 16 int i = 0; 17 while (i \u0026lt; max) { 18 yield i; 19 await Future.delayed(Duration(milliseconds: 300)); 20 i++; 21 } 22} 23 24Stream\u0026lt;int\u0026gt; genStream2({int max = 10}) { 25 StreamController\u0026lt;int\u0026gt; controller = StreamController(); 26 27 Future\u0026lt;void\u0026gt;.delayed(Duration.zero).then((_) async { 28 int i = 0; 29 while (i \u0026lt; max) { 30 controller.add(i); 31 await Future.delayed(Duration(milliseconds: 300)); 32 i++; 33 } 34 controller.close(); 35 }); 36 37 return controller.stream; 38} 两种写法达到了一样的效果,但是生成器函数代码会更加简洁一些\n执行结果如下 yield* 在生成器函数中还有一个关键字 yield*\n这个关键字是结合递归使用的,可以配合sync* 也可以配合async*\n结合 sync* 1main(List\u0026lt;String\u0026gt; arguments) { 2 var r = naturalsDownFrom(10); 3 print(r); //(10, 9, 8, 7, 6, 5, 4, 3, 2, 1) 4 5 r = naturalsDownWithNormal(10); 6 print(r); //(10, 9, 8, 7, 6, 5, 4, 3, 2, 1) 7} 8 9Iterable\u0026lt;int\u0026gt; naturalsDownFrom(int n) sync* { 10 if (n \u0026gt; 0) { 11 yield n; 12 yield* naturalsDownFrom(n - 1); 13 } 14} 15 16Iterable\u0026lt;int\u0026gt; naturalsDownWithNormal(int n) { 17 var list = \u0026lt;int\u0026gt;[]; 18 if (n \u0026gt; 0) { 19 list.add(n); 20 var r = naturalsDownWithNormal(n - 1); 21 list.addAll(r); 22 } 23 return list.map((v) =\u0026gt; v); 24} 结合 async* 1 2main(List\u0026lt;String\u0026gt; arguments){ 3 naturalsStreamDownFrom(10).listen((data) { 4 print(\u0026#34;data = $data\u0026#34;); 5 }); 6 7} 8 9Stream\u0026lt;int\u0026gt; naturalsStreamDownFrom(int n) async* { 10 if (n \u0026gt; 0) { 11 yield n; 12 yield* naturalsStreamDownFrom(n - 1); 13 } 14} 输出结果\n1data = 10 2data = 9 3data = 8 4data = 7 5data = 6 6data = 5 7data = 4 8data = 3 9data = 2 10data = 1 常规写法分开写\n1main(List\u0026lt;String\u0026gt; arguments) { 2 naturalsStreamDownWithNormal(10).listen((data) { 3 print(\u0026#34;data2 = $data\u0026#34;); 4 }); 5} 6 7 8Stream\u0026lt;int\u0026gt; naturalsStreamDownWithNormal(int n) { 9 var controller = StreamController\u0026lt;int\u0026gt;(); 10 if (n \u0026gt; 0) { 11 controller.add(n); 12 naturalsStreamDownWithNormal(n - 1).listen((data) { 13 controller.add(data); 14 }); 15 } 16 return controller.stream; 17} 1data2 = 10 2data2 = 9 3data2 = 8 4data2 = 7 5data2 = 6 6data2 = 5 7data2 = 4 8data2 = 3 9data2 = 2 10data2 = 1 这里常规的写法也比较复杂,而且还有 controller 不关闭的可能\n还需要注意一下 streamController 的关闭\n需要修改如下\n1 2Stream\u0026lt;int\u0026gt; naturalsStreamDownWithNormal(int n) { 3 var controller = StreamController\u0026lt;int\u0026gt;(); 4 if (n \u0026gt; 0) { 5 controller.add(n); 6 naturalsStreamDownWithNormal(n - 1).listen((data) { 7 controller.add(data); 8 }, onDone: () { 9 print(\u0026#34;close controller = $n\u0026#34;); 10 controller.close(); 11 }); 12 } else { 13 controller.close(); 14 } 15 return controller.stream; 16} 这里加了一个 print 输出\n1close controller = 1 2data2 = 10 3close controller = 2 4data2 = 9 5close controller = 3 6data2 = 8 7close controller = 4 8data2 = 7 9close controller = 5 10data2 = 6 11close controller = 6 12data2 = 5 13close controller = 7 14data2 = 4 15close controller = 8 16data2 = 3 17close controller = 9 18data2 = 2 19close controller = 10 20data2 = 1 日志是这样的,递归调用,结束后递归关闭\n官方的说法是,使用yield*会有性能优化,所以还是建议使用生成器函数\n后记 粗略的分析了一下生成器函数,记录下,为了以后的朋友能看到,同时最重要的是记录自己的学习过程\n以上\n","link":"https://kikt.top/posts/flutter/dart/generators/","section":"posts","tags":["flutter","flutter","yield"],"title":"dart中的生成器函数"},{"body":"","link":"https://kikt.top/tags/yield/","section":"tags","tags":null,"title":"yield"},{"body":"","link":"https://kikt.top/tags/doc/","section":"tags","tags":null,"title":"doc"},{"body":" 是 flutter 的 api 文档页\n但是这个文档页有的时候不那么好访问, 也许你有自己的页面,或者你就是想简单的搭建一个 pages 到 gitee/github 上方便你以后的访问\n本篇就来教你怎么简单的达成这个目的\ngitee 部署完成后是这样的 准备工作 一个终端工具 dart sdk 一个 web 服务器(pages) 作为一个 flutter/dart 开发者,sdk 肯定是必备工具了\n如果你运行过 flutter doctor 命令,则 flutter 自带的 sdk 就会存在在的系统内 ${FLUTTER_HOME}/bin/cache/dart-sdk 这里替换为自己的 flutter sdk 的文件夹\n这里可以看见 dartdoc 这个就是创建文档的工具了\n先进入 sdk 下的 packages/flutter 文件夹\n然后运行$FLUTTER_HOME/bin/cache/dart-sdk/bin/dartdoc .命令 $FLUTTER_HOME 为你的 flutter sdk 所在目录\n等待一段时间\n然后可以看到当前文件夹下生成了一个doc目录,里面就是所有的文档了\n部署 直接双击 index.html 也可以打开,但是根据官方的说法,如果本地运行可能右上角的搜索不能使用,这就需要部署到服务器上了\n如果你有自己的云服务器,那么你估计对于部署应该有自己的理解,就不用继续看了\n本地部署 所以我们需要使用一些本地服务来部署\n比如 nginx/caddy/tomcat/apache 之类的服务器\n我这里本地部署使用一个简单的serve命令来部署,基于npm安装\nnpm i serve或 yarn global add serve\n这样你就可以在本地访问这些页面了\n部署到 gitee 使用 gitee pages 来部署这些页面\n创建一个仓库,这步就不教了,一定要是一个空仓库(里面没有文件),如果你创建了 README,ignore 之类的文件,则你可能需要对于 git 有一定了解\n将文件都 push 到仓库内\n然后使用服务=\u0026gt;pages pages 也支持一些其他的静态页自动生成,也就是你可以部署 blog 到页面上,Jekyll,Hexo,Hugo\n因为这里我是直接 push 到仓库内,所以选择默认分支 master,根目录就可以了,接着点启动,等待部署完成\n接着会出现一行部署成功的提示 点击即可访问了\ngithub 的 pages 也差不多相同的方式,只不过操作界面是英文而已\n小优化 部署成功后我们使用搜索功能的时候会发现比如我想搜GestureDetector这个控件,需要输入最少 3 位以上,但是这个控件的名字太长了不好打\n我们可以微调一下 js,让这个字符变成 2 位,虽然也许效率和准确度会降低,但是使用起来会更好点\n打开script.js 搜索q.length \u0026lt;= 2,然后将这个修改为 1\n接着搜索,只需要输入两位就可以查到结果了\n后记 自己部署加上静态页加一个 CDN 加速就可以更加顺畅的访问了,如果你公司是内网环境开发,这样起码你也可以快速查询文档,flutter 的文档质量总体还是不错的\n","link":"https://kikt.top/posts/flutter/doc/create/","section":"posts","tags":["文档","doc","flutter"],"title":"创建 dart flutter 的 doc文档并部署"},{"body":"","link":"https://kikt.top/tags/%E6%96%87%E6%A1%A3/","section":"tags","tags":null,"title":"文档"},{"body":"之前的很多技术文章太严肃了,本篇写一篇插件发布的文章\n什么是 pub 偶尔会经常听人说 发布包到 pub 了,那什么是 pub 呢\n官方描述: Pub is the package manager for Dart. / dart 语言的包管理器\n官网 pub 的官方 url: 这个域名有多个小伙伴同时 ping 过, 对应 ip 不相同,所以可知这个网站是有负载均衡的, 但是坑的地方来了, 部分在墙外,所以这就是这个网站偶尔国内访问不通畅的原因\n然后有几个国内镜像站点,可以查看官网介绍\n设置访问镜像 在环境变量中配置,这个根据系统不同设置方法不同\nmac 的话 可以使用 export 命令临时添加\n也可以在vi ~/.bash_profile,在这个文件中添加\n其他系统的设置方式请自行查找\n1PUB_HOSTED_URL=https://pub.flutter-io.cn 2FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn 这样在国内就很快了\n如果你需要发布插件的话,到这里就结束了\n发布 有的时候我们自己写了开源库,想要发布到 pub 上怎么办呢\ndart/flutter 对于插件没有审核的概念,而且发布很简单,你可以任意发布插件到 pub 上,只要不重复就可以了\n必备前提 一份代码 一份命令行翻墙工具 一个 google 账号 代码是必须的,不然没意义\n命令行翻墙工具是因为国内镜像发布不了,必须要连接到 pub 的官方源\ngoogle 账号是确定权限用的,不能你说你是主人你就是主人了吧, 你要绑定库和你的作者身份,不然别人随手写一个覆盖你的插件岂不是乱套了\n终端翻墙 这里因为涉及到连接 google,所以你必须保证你的终端翻墙了\n以 mac 为例 你输入curl google.com,如果有成功的回文(一个 html 格式的文本信息)说明成功了,如果没有就说明你的终端还在墙内,你需要自行保证 curl 能连接成功\n提示: SS(小飞机) 的终端 http 协议翻墙可以简单在终端输入 export http_proxy=http://127.0.0.1:1081;export https_proxy=http://127.0.0.1:1081;\n其他的工具需要自行查看对应的解决方案\n开始发布 还记得之前设置的环境变量访问中国镜像吗,这一步需要去掉这些环境变量,但是我们今后还用国内的呢,修改文件很麻烦\n没事,我们可以临时在当前终端干掉这两个环境变量\nunset FLUTTER_STORAGE_BASE_URL;unset PUB_HOSTED_URL\n这样不会影响别的窗口\n在要上传的插件文件夹下输入\n1flutter packages pub publish --dry-run 这个是尝试上传,这里会提示你一些信息\n我们能看到第一行信息告诉我们上传的地址是flutter-io.cn,这样一定会失败\n修改一下, 这里使用\n1flutter packages pub publish --dry-run --server=https://pub.dartlang.org 这样就会看到上传到pub.dartlang.org上,这样就可以了\n这里会告诉你,我们需要协议,COPYING,LICENSE or UNLINCESE,必须至少有一个在根目录下\npubspec 中需要作者信息,主页信息,版本信息\n修改一下 然后看到,没有错误 去掉--dry-run后再试一下\n这时候应该会提示一个 account 的 url,这时候你需要将这个 url 复制到浏览器中,然后根据提示登录 google 帐号,且完成授权信息,这样他会如下图所示,提示你准备好上传了吗\n输入 y 回车就可以了\n成功的图在下面 如果你没有出现 google 帐号授权那个 url 只有两种情况,一个是你以前授权过,二是你连接失败了\n后记 本人维护有几个开源库,欢迎尝试使用,好用别忘了给个 star\n图片压缩\nlistview 加载更多\n纯 flutter toast 组件\npageview 的圆点 indicator\n照片管理\n多图片选择器\n图片显示+缓存控件\n以上\n","link":"https://kikt.top/posts/flutter/package/publish-fail/","section":"posts","tags":["flutter","pub","发布"],"title":"flutter pub 发布失败"},{"body":"","link":"https://kikt.top/tags/%E5%8F%91%E5%B8%83/","section":"tags","tags":null,"title":"发布"},{"body":"","link":"https://kikt.top/tags/python/","section":"tags","tags":null,"title":"python"},{"body":"","link":"https://kikt.top/categories/python/","section":"categories","tags":null,"title":"python"},{"body":"前言 最近打算使用 ,但是目前没有数据来源,就想着搜搜有没有 json 的数据,结果搜了一下只有各种数据库的\n然后搜了下有个网站说有很完整的数据的还是收费的\n作为一个穷人程序员,如果是公司用,我付费买一个也无所谓,但是本身是想私人使用,甚至开源出去,付费就没必要了\n这时候我想着,既然如此,我就爬一份数据,自己造一个吧\n说到爬虫,我们就想起了明年..两开花 python\n开发环境 使用的语言是 python3\nrequest_html+基本库\n爬取网页 查看网页 一级页面 使用 chrome dev 工具查看元素\n呃. table 体系,最近几年算是比较少见了\n分析了一下,整个页面只有备案号和省份名称是 a 标签,这下过滤一下备案号,剩下的不就是我们要的数据了吗\n二级页面 点开北京,数据比较少,只有市辖区 内蒙的就比较多一点了\n纯数字的是编码,其他的是名称,也是过滤掉 IPC 备案的就好\n三级页面 和二级页面基本一致\n撸码 city_get.py\n1import json 2from requests_html import HTMLSession 3import requests_html 4 5session = HTMLSession() 6 7 8class Entity: 9 name: str 10 link: str 11 no: str 12 baseUrl = \u0026#34;http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2017/\u0026#34; 13 14 def __str__(self) -\u0026gt; str: 15 return \u0026#34;name:%s,link=%s\u0026#34; % (self.name, self.link) 16 17 def __eq__(self, o: object) -\u0026gt; bool: 18 return self.link == o.link 19 20 def to_json(self) -\u0026gt; str: 21 pass 22 23 24class Province(Entity): 25 26 def __init__(self) -\u0026gt; None: 27 super().__init__() 28 self.cityList = [] 29 30 def __str__(self) -\u0026gt; str: 31 return \u0026#34;name:%s,link=%s\u0026#34; % (self.name, self.link) 32 33 def fetch_city_list(self): 34 url = \u0026#34;%s%s\u0026#34; % (Entity.baseUrl, self.link) 35 r = session.get(url) 36 r.encoding = \u0026#34;gbk\u0026#34; 37 h: requests_html.HTML = r.html 38 li: list[requests_html.Element] = h.find(\u0026#34;a\u0026#34;) 39 for a in li: 40 text = a.text 41 if text.__contains__(\u0026#34;京ICP\u0026#34;): 42 continue 43 href_ = a.attrs[\u0026#34;href\u0026#34;] 44 city = City() 45 city.link = href_ 46 city.province = self 47 # print(text, href_) 48 49 try: 50 index = self.cityList.index(city) 51 city = self.cityList[index] 52 except ValueError: 53 self.cityList.append(city) 54 55 if text.isnumeric(): 56 city.no = text 57 else: 58 city.name = text 59 60 for city in self.cityList: 61 city.fetch_county_list() 62 63 def to_json(self) -\u0026gt; str: 64 pass 65 66 67class City(Entity): 68 province: Province 69 70 def __init__(self) -\u0026gt; None: 71 super().__init__() 72 self.countyList = [] 73 74 def fetch_county_list(self): 75 print(\u0026#34;%s 开始\u0026#34; % self.name) 76 url = \u0026#34;%s%s\u0026#34; % (Entity.baseUrl, self.link) 77 r = session.get(url) 78 r.encoding = \u0026#34;gbk\u0026#34; 79 h: requests_html.HTML = r.html 80 li: list[requests_html.Element] = h.find(\u0026#34;a\u0026#34;) 81 for a in li: 82 text = a.text 83 if text.__contains__(\u0026#34;京ICP\u0026#34;): 84 continue 85 href_ = a.attrs[\u0026#34;href\u0026#34;] 86 county = County() 87 county.link = href_ 88 county.province = self 89 # print(text, href_) 90 91 try: 92 index = self.countyList.index(county) 93 county = self.countyList[index] 94 except ValueError: 95 self.countyList.append(county) 96 97 if text.isnumeric(): 98 county.no = text 99 else: 100 county.name = text 101 102 for county in self.countyList: 103 # print(county.__str__()) 104 pass 105 106 print(\u0026#34;%s 结束\u0026#34; % self.name) 107 108 pass 109 110 111class County(Entity): 112 city: City 113 pass 114 115 116provinceList = [] 117 118 119def fetch_province_list(): 120 response = session.get(\u0026#34;http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2017/index.html\u0026#34;) 121 response.encoding = \u0026#34;gbk\u0026#34; 122 html: requests_html.HTML = response.html 123 # s = response.content.decode(\u0026#34;gbk\u0026#34;) 124 l: list = html.find(\u0026#34;a\u0026#34;) 125 for a in l: 126 ae: requests_html.Element = a 127 href: str = ae.attrs.get(\u0026#34;href\u0026#34;) 128 if href.endswith(\u0026#34;html\u0026#34;): 129 province = Province() 130 province.name = ae.text.lstrip() 131 province.link = href.lstrip() 132 provinceList.append(province) 133 134 135fetch_province_list() 136 137if __name__ == \u0026#39;__main__\u0026#39;: 138 for p in provinceList: 139 if p.name == \u0026#34;黑龙江省\u0026#34;: 140 p.fetch_city_list() 141# session.close() dump_data.py\n1import json 2 3from city.city_get import Province, County, City, provinceList 4import datetime 5 6# for p in provinceList: 7# pr: Province = p 8version = 2 9 10di = dict() 11di[\u0026#34;version\u0026#34;] = version 12now = datetime.datetime.now() 13date = datetime.datetime.strftime(now, \u0026#34;%Y-%m-%d %H:%M:%S\u0026#34;) 14di[\u0026#34;date\u0026#34;] = date 15di[\u0026#34;timeStamp\u0026#34;] = now.timestamp() 16 17proList = [] 18 19 20def make_province(p: Province): 21 p.fetch_city_list() 22 p_dict = dict() 23 city_list = [] 24 25 p_dict[\u0026#34;name\u0026#34;] = p.name 26 27 for city in p.cityList: 28 city: City = city 29 c_dict = dict() 30 c_dict[\u0026#34;name\u0026#34;] = city.name 31 c_dict[\u0026#34;no\u0026#34;] = city.no 32 city_list.append(c_dict) 33 make_city(city, c_dict) 34 35 p_dict[\u0026#34;cityList\u0026#34;] = city_list 36 proList.append(p_dict) 37 38 39def make_city(city: City, city_obj: dict): 40 city.fetch_county_list() 41 li = [] 42 county_list: list[County] = city.countyList 43 for county in county_list: 44 c_obj = dict() 45 c_obj[\u0026#34;name\u0026#34;] = county.name 46 c_obj[\u0026#34;no\u0026#34;] = county.no 47 li.append(c_obj) 48 49 city_obj[\u0026#34;countyList\u0026#34;] = li 50 pass 51 52 53for province in provinceList: 54 print(\u0026#34;province = %s\u0026#34; % province.name) 55 make_province(province) 56 57di[\u0026#34;provinceList\u0026#34;] = proList 58 59s = json.dumps(di) 60 61f = open(\u0026#34;data/city-version-%s.json\u0026#34; % version, \u0026#39;w\u0026#39;) 62 63f.write(s) 分了两个文件,其中一个是获取数据,一个是将数据转为 json 形式保存\n如果后续有必要,也可以弄一个数据库,具体是 sqlite 还是 mysql 都可以自己解析 json 插入,对于一个合格的程序员都是小意思\n代码 代码可以从仓库查看\n生成数据 生成的数据比较大,大概有 22w 字符 200 多 K\n可以从下载\n或直接从 copy\n格式化完的数据有 14000 行左右, 可以查看\n","link":"https://kikt.top/posts/python/get_city_datas/","section":"posts","tags":["爬虫","python","城市"],"title":"使用python爬取一个省市城市列表"},{"body":"","link":"https://kikt.top/tags/%E5%9F%8E%E5%B8%82/","section":"tags","tags":null,"title":"城市"},{"body":"","link":"https://kikt.top/tags/%E7%88%AC%E8%99%AB/","section":"tags","tags":null,"title":"爬虫"},{"body":"最近做了一篇 android 原生中加入 flutter 的尝试,顺便查看下内存占用\n在 debug 模式下肯定是不准的,所以随便看看就好了,只是为了满足好奇心,不代表真实项目中的真实表现,也不代表我的观点\n在原生刚刚打开后稳定的情况下查看内存占用\n可以看到 打开 Flutter 后内存会有明显上升\n红点处是我点击了按钮后的情况,会有内存抖动\n关闭 Flutter 界面后会发现内存回落很明显,说明内存相对比较稳定 过了段时间,其实是我在码字+上传图片,没看手机,发现内存更加平稳了,而且降低到了只有 30m\n换句话说其实在 android 上内存的表现还算可以,目测在关闭 flutterview 的界面后简单的界面是可以完全回收的,而且众所周知 release 蜜汁流畅 :-D\n本篇是随便写写的,不代表 flutter 在实际项目中的表现,因为实际项目原生,flutter 中都会有更复杂的机制,所以内存 cpu 的消耗会更大, 也可能会发生不可预知的情况\n","link":"https://kikt.top/posts/flutter/android/profile-1/","section":"posts","tags":["flutter","android"],"title":"在Profile下分析android内存占用"},{"body":"","link":"https://kikt.top/categories/%E6%B6%82%E9%B8%A6/","section":"categories","tags":null,"title":"涂鸦"},{"body":"在 flutter 开发的过程中不可能所有项目都是从零构建\n换句话说不是所有项目都是 flutter 为主工程,然后 android/ios 的工程为副工程\n大概率会遇到需要将 flutter 作为组件加入到原生项目中, 这种例子典型的就是阿里闲鱼,当然闲鱼团队的实力不是普通的小公司可以比的\n所幸的是,flutter 团队提供了一个 用于帮助我们完成这个过程\n创建一个 Android 工程 使用 Android Studio 创建一个新工程来模拟这个过程,会看这里的普遍都应该是 android 程序员出身,Hello World 工程是肯定会的,不会的话还是回炉加强一下吧\n如果你已经有现有工程,肯定是有 VCS 管理的,放心大胆的走出第一步,大不了就删除当前分支嘛,然后你可以跳过这一步,直接看 flutter 的过程\n创建 Flutter 这一步仅作为 官方 Android 部分的参考\n我目前使用的是 1.0.0 的发布版\n1Flutter 1.0.0 • channel dev • https://github.com/flutter/flutter.git 2Framework • revision 5391447fae (11 days ago) • 2018-11-29 19:41:26 -0800 3Engine • revision 7375a0f414 4Tools • Dart 2.1.0 (build 2.1.0-dev.9.4 f9ebf21297) wiki 后续可能会被修改,请查看最新的文档去解决\n这里要注意,你要在和你现有的 Application 同级的目录来使用\n比如你的 Application\n1➜ ExistsApp flutter create -t module my_flutter 2Creating project my_flutter... 3 my_flutter/.gitignore (created) 4 my_flutter/.idea/libraries/Dart_SDK.xml (created) 5 my_flutter/.idea/libraries/Flutter_for_Android.xml (created) 6 my_flutter/.idea/modules.xml (created) 7 my_flutter/.idea/workspace.xml (created) 8 my_flutter/.metadata (created) 9 my_flutter/lib/main.dart (created) 10 my_flutter/my_flutter.iml (created) 11 my_flutter/my_flutter_android.iml (created) 12 my_flutter/pubspec.yaml (created) 13 my_flutter/README.md (created) 14 my_flutter/test/widget_test.dart (created) 15Running \u0026#34;flutter packages get\u0026#34; in my_flutter... 7.5s 16Wrote 12 files. 17 18All done! 19Your module code is in my_flutter/lib/main.dart. 这里 flutter 工程就创建成功了\n打包 aar 文件/修改 host application 这一步是构建一个 aar 文件\n1cd .android/ 2./gradlew flutter:assembleDebug 接着修改 setting.gradle 文件\n1include \u0026#39;:app\u0026#39; // assumed existing content 2setBinding(new Binding([gradle: this])) // new 3evaluate(new File( // new 4 settingsDir.parentFile, // new 5 \u0026#39;my_flutter/.android/include_flutter.groovy\u0026#39; // new 6)) sync 以后 如果有 flutter 说明关联到项目中了 接着,将 flutter 设置为 android 的库\n加入这个,然后继续同步一下\n1dependencies { 2 implementation project(\u0026#39;:flutter\u0026#39;) 3} 能看见的话就说明加入成功了\n修改 android 工程 activity_main.xml\n1\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; 2\u0026lt;android.support.constraint.ConstraintLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; 3 xmlns:app=\u0026#34;http://schemas.android.com/apk/res-auto\u0026#34; 4 xmlns:tools=\u0026#34;http://schemas.android.com/tools\u0026#34; 5 android:layout_width=\u0026#34;match_parent\u0026#34; 6 android:layout_height=\u0026#34;match_parent\u0026#34; 7 tools:context=\u0026#34;.MainActivity\u0026#34;\u0026gt; 8 9 \u0026lt;TextView 10 android:id=\u0026#34;@+id/tv_text\u0026#34; 11 android:layout_width=\u0026#34;wrap_content\u0026#34; 12 android:layout_height=\u0026#34;wrap_content\u0026#34; 13 android:text=\u0026#34;Hello World!\u0026#34; 14 app:layout_constraintBottom_toBottomOf=\u0026#34;parent\u0026#34; 15 app:layout_constraintLeft_toLeftOf=\u0026#34;parent\u0026#34; 16 app:layout_constraintRight_toRightOf=\u0026#34;parent\u0026#34; 17 app:layout_constraintTop_toTopOf=\u0026#34;parent\u0026#34; /\u0026gt; 18 19 \u0026lt;Button 20 android:id=\u0026#34;@+id/bt_to_flutter\u0026#34; 21 android:layout_width=\u0026#34;wrap_content\u0026#34; 22 android:layout_height=\u0026#34;wrap_content\u0026#34; 23 android:layout_marginTop=\u0026#34;8dp\u0026#34; 24 android:text=\u0026#34;to Flutter page\u0026#34; 25 app:layout_constraintLeft_toLeftOf=\u0026#34;parent\u0026#34; 26 app:layout_constraintRight_toRightOf=\u0026#34;parent\u0026#34; 27 app:layout_constraintTop_toBottomOf=\u0026#34;@id/tv_text\u0026#34; /\u0026gt; 28 29\u0026lt;/android.support.constraint.ConstraintLayout\u0026gt; MainActivity.java\n1package top.kikt.addexiststoandroid; 2 3import android.content.Intent; 4import android.os.Bundle; 5import android.support.v7.app.AppCompatActivity; 6import android.view.View; 7 8public class MainActivity extends AppCompatActivity { 9 10 @Override 11 protected void onCreate(Bundle savedInstanceState) { 12 super.onCreate(savedInstanceState); 13 setContentView(R.layout.activity_main); 14 15 findViewById(R.id.bt_to_flutter).setOnClickListener(new View.OnClickListener() { 16 @Override 17 public void onClick(View v) { 18 // to flutter activity 19 Intent intent = new Intent(MainActivity.this, MyFlutterActivity.class); 20 startActivity(intent); 21 } 22 }); 23 } 24} MyFlutterActivity.java\n1package top.kikt.addexiststoandroid; 2 3import android.os.Bundle; 4import android.support.v4.app.FragmentActivity; 5import android.widget.FrameLayout; 6 7import io.flutter.facade.Flutter; 8import io.flutter.view.FlutterView; 9 10/// create 2019/1/22 by cai 11 12 13public class MyFlutterActivity extends FragmentActivity { 14 15 @Override 16 protected void onCreate(Bundle savedInstanceState) { 17 super.onCreate(savedInstanceState); 18 FlutterView flutterView = Flutter.createView(this, getLifecycle(), \u0026#34;route1\u0026#34;); 19 FrameLayout.LayoutParams params = new FrameLayout.LayoutParams(FrameLayout.LayoutParams.MATCH_PARENT, FrameLayout.LayoutParams.MATCH_PARENT); 20 addContentView(flutterView, params); 21 } 22 23} 别忘了增加 Activity 的清单文件\n1 \u0026lt;activity android:name=\u0026#34;.MyFlutterActivity\u0026#34; /\u0026gt; 修改 flutter 工程 main.dart\n1import \u0026#39;package:flutter/material.dart\u0026#39;; 2import \u0026#39;dart:ui\u0026#39; as ui; 3 4void main() { 5 var routeName = ui.window.defaultRouteName; 6 7 switch (routeName) { 8 case \u0026#34;route1\u0026#34;: 9 runApp(MyApp()); 10 break; 11 default: 12 runApp(EmptyWidget()); 13 } 14} 15 16class EmptyWidget extends StatelessWidget { 17 @override 18 Widget build(BuildContext context) { 19 return MaterialApp( 20 home: Scaffold( 21 body: Center( 22 child: Container( 23 child: Text(\u0026#34;空路由\u0026#34;), 24 ), 25 ), 26 ), 27 ); 28 } 29} 30 31class MyApp extends StatelessWidget { 32 // This widget is the root of your application. 33 @override 34 Widget build(BuildContext context) { 35 return MaterialApp( 36 title: \u0026#39;Flutter Demo\u0026#39;, 37 theme: ThemeData( 38 // This is the theme of your application. 39 // 40 // Try running your application with \u0026#34;flutter run\u0026#34;. You\u0026#39;ll see the 41 // application has a blue toolbar. Then, without quitting the app, try 42 // changing the primarySwatch below to Colors.green and then invoke 43 // \u0026#34;hot reload\u0026#34; (press \u0026#34;r\u0026#34; in the console where you ran \u0026#34;flutter run\u0026#34;, 44 // or press Run \u0026gt; Flutter Hot Reload in a Flutter IDE). Notice that the 45 // counter didn\u0026#39;t reset back to zero; the application is not restarted. 46 primarySwatch: Colors.blue, 47 ), 48 home: MyHomePage(title: \u0026#39;Flutter Demo Home Page\u0026#39;), 49 ); 50 } 51} 52 53class MyHomePage extends StatefulWidget { 54 MyHomePage({Key key, this.title}) : super(key: key); 55 56 // This widget is the home page of your application. It is stateful, meaning 57 // that it has a State object (defined below) that contains fields that affect 58 // how it looks. 59 60 // This class is the configuration for the state. It holds the values (in this 61 // case the title) provided by the parent (in this case the App widget) and 62 // used by the build method of the State. Fields in a Widget subclass are 63 // always marked \u0026#34;final\u0026#34;. 64 65 final String title; 66 67 @override 68 _MyHomePageState createState() =\u0026gt; _MyHomePageState(); 69} 70 71class _MyHomePageState extends State\u0026lt;MyHomePage\u0026gt; { 72 int _counter = 0; 73 74 void _incrementCounter() { 75 setState(() { 76 // This call to setState tells the Flutter framework that something has 77 // changed in this State, which causes it to rerun the build method below 78 // so that the display can reflect the updated values. If we changed 79 // _counter without calling setState(), then the build method would not be 80 // called again, and so nothing would appear to happen. 81 _counter++; 82 }); 83 } 84 85 @override 86 Widget build(BuildContext context) { 87 // This method is rerun every time setState is called, for instance as done 88 // by the _incrementCounter method above. 89 // 90 // The Flutter framework has been optimized to make rerunning build methods 91 // fast, so that you can just rebuild anything that needs updating rather 92 // than having to individually change instances of widgets. 93 return Scaffold( 94 appBar: AppBar( 95 // Here we take the value from the MyHomePage object that was created by 96 // the App.build method, and use it to set our appbar title. 97 title: Text(widget.title), 98 ), 99 body: Center( 100 // Center is a layout widget. It takes a single child and positions it 101 // in the middle of the parent. 102 child: Column( 103 // Column is also layout widget. It takes a list of children and 104 // arranges them vertically. By default, it sizes itself to fit its 105 // children horizontally, and tries to be as tall as its parent. 106 // 107 // Invoke \u0026#34;debug painting\u0026#34; (press \u0026#34;p\u0026#34; in the console, choose the 108 // \u0026#34;Toggle Debug Paint\u0026#34; action from the Flutter Inspector in Android 109 // Studio, or the \u0026#34;Toggle Debug Paint\u0026#34; command in Visual Studio Code) 110 // to see the wireframe for each widget. 111 // 112 // Column has various properties to control how it sizes itself and 113 // how it positions its children. Here we use mainAxisAlignment to 114 // center the children vertically; the main axis here is the vertical 115 // axis because Columns are vertical (the cross axis would be 116 // horizontal). 117 mainAxisAlignment: MainAxisAlignment.center, 118 children: \u0026lt;Widget\u0026gt;[ 119 Text( 120 \u0026#39;You have pushed the button this many times:\u0026#39;, 121 ), 122 Text( 123 \u0026#39;$_counter\u0026#39;, 124 style: Theme.of(context).textTheme.display1, 125 ), 126 ], 127 ), 128 ), 129 floatingActionButton: FloatingActionButton( 130 onPressed: _incrementCounter, 131 tooltip: \u0026#39;Increment\u0026#39;, 132 child: Icon(Icons.add), 133 ), // This trailing comma makes auto-formatting nicer for build methods. 134 ); 135 } 136} 运行 运行 flutter 工程 这里要注意,我这里在 flutter 下直接运行会得到下面的结果, 所以你需要自己在 debug 的情况下指定一个路由\n修改 main.dart 中的 main 方法为如下结果\n1void main() { 2 var routeName = ui.window.defaultRouteName; 3 routeName = \u0026#34;route1\u0026#34;; // 新增这一行 4 switch (routeName) { 5 case \u0026#34;route1\u0026#34;: 6 runApp(MyApp()); 7 break; 8 default: 9 runApp(EmptyWidget()); 10 } 11} 正式运行的时候一定要注释掉,如果不注释掉, 原生工程中的那个 route1 就失效了\n然后运行下\n看起来和默认的 hello world 工程是一样的\n运行原生工程 为什么看起来是一样的呢,flutter run 默认运行的是当前目录下的 lib/main.dart, 然后找 main 方法, main 方法中就是 runApp,所以看起来就是这样的了\n但我们需要的是将 flutter 加入到原生工程中去,那么我们就需要在原生工程里面去运行这个项目\n我们直接在 android studio 中运行项目,可能会得到下面的结果,也可能没有 这个应该和你 android 中的 min sdk /target sdk 版本有关系,有原生经验的人\n拿着错误信息随手一百度能看到一个\nok 我们在 android 项目中加入这个, 这个意思就是指定 java 的版本为 1.8(java 8)\n修改 gradle 文件\napp 下的 build.gradle\n1android{ 2 compileOptions { 3 sourceCompatibility JavaVersion.VERSION_1_8 4 targetCompatibility JavaVersion.VERSION_1_8 5 } 6} 接着就可以跑起来项目了\n点击按钮 微调一下 我们看到 flutter 界面上会比较怪, 这是因为原生和 flutter 主题色不一样的原因\n修改原生的主题色 colors.xml\n1\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; 2\u0026lt;resources\u0026gt; 3 \u0026lt;color name=\u0026#34;colorPrimary\u0026#34;\u0026gt;#2196F3\u0026lt;/color\u0026gt; 4 \u0026lt;color name=\u0026#34;colorPrimaryDark\u0026#34;\u0026gt;#19639e\u0026lt;/color\u0026gt; 5 \u0026lt;color name=\u0026#34;colorAccent\u0026#34;\u0026gt;#D81B60\u0026lt;/color\u0026gt; 6\u0026lt;/resources\u0026gt; 再打开原生项目可以看到颜色发生了变化 后记 简单的添加 flutter 到 android 就完成了,当然在具体实施中还会有很多问题,只能在具体情况具体分析了\n如果遇到问题,欢迎在后面留言\n另外,如果遇到了本篇和 wiki 不同的情况,请以 wiki 为准,毕竟官方 wiki 的更新会比较频繁,就在我写这篇文章的时候,还在间隔几天更新一次\n","link":"https://kikt.top/posts/flutter/exists/android/","section":"posts","tags":["flutter","android","exists"],"title":"在原 Android 工程的基础上构建一个flutter工程"},{"body":"上篇介绍了如何 在 mac 系统下打包 ffmpeg 的 so\n这篇介绍如何引入 so 到项目中\n开发环境:\n1macos 2android studio 3.2.1 3ndk: 15.2.4203891 新建一个工程 新建工程时,勾选 c++支持\n将文件复制到项目内 需要复制的文件\n.h 头文件 so文件 在 cpp 中新建一个文件夹include/ffmpeg 把 include 中的文件夹复制到 ffmpeg 下\n在 main 下新建文件夹jniLibs,把 so 文件复制到其中 修改 CMakeList 完整的CMakeList.txt 如下\n1# For more information about using CMake with Android Studio, read the 2# documentation: https://d.android.com/studio/projects/add-native-code.html 3 4# Sets the minimum version of CMake required to build the native library. 5 6cmake_minimum_required(VERSION 3.4.1) 7 8# Creates and names a library, sets it as either STATIC 9# or SHARED, and provides the relative paths to its source code. 10# You can define multiple libraries, and CMake builds them for you. 11# Gradle automatically packages shared libraries with your APK. 12 13# 14# 15set(distribution_DIR ${CMAKE_SOURCE_DIR}/src/main/jniLibs) 16 17# 18 19 20#set(FFDIR /Users/cai/code/c/ffmpeg-3.3.6/android/arm/lib) 21 22include_directories( 23 src/main/cpp/include/ffmpeg 24) 25 26# ffmpeg 的library 27add_library( 28 avcodec 29 SHARED 30 IMPORTED 31) 32set_target_properties( 33 avcodec 34 PROPERTIES IMPORTED_LOCATION 35 ${CMAKE_SOURCE_DIR}/src/main/jniLibs/${ANDROID_ABI}/libavcodec-57.so 36) 37 38add_library( 39 avdevice 40 SHARED 41 IMPORTED 42) 43set_target_properties( 44 avdevice 45 PROPERTIES IMPORTED_LOCATION 46 ${CMAKE_SOURCE_DIR}/src/main/jniLibs/${ANDROID_ABI}/libavdevice-57.so 47) 48 49add_library( 50 avfilter 51 SHARED 52 IMPORTED 53) 54set_target_properties( 55 avfilter 56 PROPERTIES IMPORTED_LOCATION 57 ${CMAKE_SOURCE_DIR}/src/main/jniLibs/${ANDROID_ABI}/libavfilter-6.so 58) 59 60add_library( 61 avformat 62 SHARED 63 IMPORTED 64) 65set_target_properties( 66 avformat 67 PROPERTIES IMPORTED_LOCATION 68 ${CMAKE_SOURCE_DIR}/src/main/jniLibs/${ANDROID_ABI}/libavformat-57.so 69) 70 71add_library( 72 avutil 73 SHARED 74 IMPORTED 75) 76set_target_properties( 77 avutil 78 PROPERTIES IMPORTED_LOCATION 79 ${CMAKE_SOURCE_DIR}/src/main/jniLibs/${ANDROID_ABI}/libavutil-55.so 80) 81 82 83add_library( 84 swresample 85 SHARED 86 IMPORTED 87) 88set_target_properties( 89 swresample 90 PROPERTIES IMPORTED_LOCATION 91 ${CMAKE_SOURCE_DIR}/src/main/jniLibs/${ANDROID_ABI}/libswresample-2.so 92) 93 94add_library( 95 swscale 96 SHARED 97 IMPORTED 98) 99set_target_properties( 100 swscale 101 PROPERTIES IMPORTED_LOCATION 102 ${CMAKE_SOURCE_DIR}/src/main/jniLibs/${ANDROID_ABI}/libswscale-4.so 103) 104 105# ffmpeg 的library end 106 107# Searches for a specified prebuilt library and stores the path as a 108# variable. Because CMake includes system libraries in the search path by 109# default, you only need to specify the name of the public NDK library 110# you want to add. CMake verifies that the library exists before 111# completing its build. 112 113find_library( # Sets the name of the path variable. 114 log-lib 115 116 # Specifies the name of the NDK library that 117 # you want CMake to locate. 118 log) 119 120add_library( # Sets the name of the library. 121 native-lib 122 123 # Sets the library as a shared library. 124 SHARED 125 126 # Provides a relative path to your source file(s). 127 src/main/cpp/native-lib.cpp 128 ) 129 130# Specifies libraries CMake should link to your target library. You 131# can link multiple libraries, such as libraries you define in this 132# build script, prebuilt third-party libraries, or system libraries. 133 134target_link_libraries( # Specifies the target library. 135 native-lib 136 137 # ffmpeg 相关库 138 avcodec 139 avdevice 140 avfilter 141 avformat 142 avutil 143 swresample 144 swscale 145 # 146 147 # Links the target library to the log library 148 # included in the NDK. 149 ${log-lib}) 简单解释下:\n1# 设置so文件的目录 2set(distribution_DIR ${CMAKE_SOURCE_DIR}/src/main/jniLibs) 1# 引入头文件 2include_directories( 3 src/main/cpp/include/ffmpeg 4) 1#视为一组 2 3# 第一个为库名称,类型,已导入 4add_library( 5 avcodec 6 SHARED 7 IMPORTED 8) 9 10# 库名称, 属性名称, 文件路径 11set_target_properties( 12 avcodec 13 PROPERTIES IMPORTED_LOCATION 14 ${CMAKE_SOURCE_DIR}/src/main/jniLibs/${ANDROID_ABI}/libavcodec-57.so 15) 1# 这两个是新建项目时自带的, 这个应该是ndk中的库 2find_library( # Sets the name of the path variable. 3 log-lib 4 5 # Specifies the name of the NDK library that 6 # you want CMake to locate. 7 log) 8 9add_library( # Sets the name of the library. 10 native-lib 11 12 # Sets the library as a shared library. 13 SHARED 14 15 # Provides a relative path to your source file(s). 16 src/main/cpp/native-lib.cpp 17 ) 1# 最后是连接到项目中 2target_link_libraries( # Specifies the target library. 3 native-lib 4 5 # ffmpeg 相关库 6 avcodec 7 avdevice 8 avfilter 9 avformat 10 avutil 11 swresample 12 swscale 13 # 14 15 # Links the target library to the log library 16 # included in the NDK. 17 ${log-lib}) 作用解释没有那么准确,大概理解意思就行\n修改 cpp/kotlin 文件 新建项目时会有一个 cpp 文件,\n1#include \u0026lt;jni.h\u0026gt; 2#include \u0026lt;string\u0026gt; 3 4// 这里的导入是我们新建的 5extern \u0026#34;C\u0026#34; { 6#include \u0026lt;libavutil/log.h\u0026gt; 7#include \u0026lt;libavformat/avformat.h\u0026gt; 8} 9 10extern \u0026#34;C\u0026#34; JNIEXPORT jstring JNICALL 11Java_top_kikt_ffmpegandroidexample_MainActivity_stringFromJNI( 12 JNIEnv *env, 13 jobject /* this */) { 14 std::string hello = \u0026#34;Hello from C++\u0026#34;; 15 return env-\u0026gt;NewStringUTF(hello.c_str()); 16} 17 18 19// 这里是我们自己新建的方法 20extern \u0026#34;C\u0026#34; JNIEXPORT jint JNICALL 21Java_top_kikt_ffmpegandroidexample_MainActivity_dumpInfo( 22 JNIEnv *env, 23 jobject) { 24 25 av_log_set_level(AV_LOG_DEBUG); 26 av_register_all(); 27 28 return 1; 29} 有 2 个方法,第二个是我们自定义的, 导包部分引入了 avutil 和 avformat 的头文件\n这里有一点要格外注意 extern \u0026quot;C\u0026quot; 我们必须要用这个,这个是在 cpp 中使用 c 文件的必备方法\n不然在运行时会报错,当然如果你本身是 c 文件就不存在这个问题了\n然后修改 kotlin 文件\n1package top.kikt.ffmpegandroidexample 2 3import android.os.Bundle 4import android.support.v7.app.AppCompatActivity 5import kotlinx.android.synthetic.main.activity_main.* 6 7class MainActivity : AppCompatActivity() { 8 9 override fun onCreate(savedInstanceState: Bundle?) { 10 super.onCreate(savedInstanceState) 11 setContentView(R.layout.activity_main) 12 13 // Example of a call to a native method 14 sample_text.text = stringFromJNI() 15 16 sample_text.text = dumpInfo().toString() 17 } 18 19 /** 20 * A native method that is implemented by the \u0026#39;native-lib\u0026#39; native library, 21 * which is packaged with this application. 22 */ 23 external fun stringFromJNI(): String 24 25 external fun dumpInfo(): Int 26 27 companion object { 28 29 // Used to load the \u0026#39;native-lib\u0026#39; library on application startup. 30 init { 31 System.loadLibrary(\u0026#34;native-lib\u0026#34;) 32 System.loadLibrary(\u0026#34;avformat\u0026#34;) 33 System.loadLibrary(\u0026#34;avutil\u0026#34;) 34 } 35 } 36} 这里可以看到我们输出的内容来源于自己新建的内容 dumpInfo 会调用到刚刚在 cpp 中定义的第二个方法,并且运行时 loadLibrary 也没有报找不到 so 的异常, 这就说明成功了\n后记 本篇在 android 项目中引入了 ffmpeg ,完成了这一步的跨越后,很多 ffmpeg 的功能就可以自己写 jni 方法来调用了!\n比如直播,滤镜,yuv 处理等等,依托于 ffmpeg 强大的生态,音视频领域可以说有大半可做了!\n","link":"https://kikt.top/posts/android/android-include-ffmpeg/","section":"posts","tags":["ffmpeg","android","ndk"],"title":"android 引入ffmpeg"},{"body":"最近在努力学习音视频相关东西,以备未来不时之需\n在音视频处理领域有一个绕不过去的著名项目就是FFmpeg,这个项目基于 GPL 开源协议,\n最新版本目前我在 mac 上无法编译,会报错\n使用的总体环境如下:\n1Macos: 10.13.6 (17G65) 2ffmpeg: 3.3.6 3ndk: 15.2.4203891 引用外部源码(尝试失败) 初次尝试的时候,希望可以通过 CMakeLists 中配置头文件和库的方式,直接引用,发现可能需要拷贝所有源代码到项目中,但这样需要 copy 的东西很多,对于真实的项目来说也许可行,但 demo 项目就太复杂了,而且不方便今后的使用\n交叉编译 so 这里有一个坑,就是 ndk 版本不能太低,因为之前使用过 ijkplayer,那个项目要求 11d 还是 11e 的 ndk 版本,我这次想直接用这个 ndk 版本,过程中会报很多错误,具体原因没有深究\n然后使用我 android sdk 中带的 ndk 版本果断成功\n这个是我的 ndk 版本,截至当前最新版本应该是 18.X\n版本号在 ndk 中查看 propertis 文件可以看见\n另一个叫法是 android-ndk-r15c\n1Pkg.Desc = Android NDK 2Pkg.Revision = 15.2.4203891 ffmpeg 版本:我开始是下载的最新版本 4.1 版 ,结果编译不通过,在 udp.c 中报错了,通过网络搜索到一个原因,ffmpeg 通过下载了一个 ffmpeg-3.3.6 解决\n另外,亲测最新的 NDKr18 并不能编译 3.3.6 会报一个\n1/Users/caijinglong/Library/Android/sdk/ndk-bundle/toolchains/arm-linux-androideabi-4.9/prebuilt/darwin-x86_64/bin/arm-linux-androideabi-gcc is unable to create an executable file. 2C compiler test failed. 3 4If you think configure made a mistake, make sure you are using the latest 5version from Git. If the latest version fails, report the problem to the 6ffmpeg-user@ffmpeg.org mailing list or IRC #ffmpeg on irc.freenode.net. 7Include the log file \u0026#34;config.log\u0026#34; produced by configure as this will help 换成 r15c 后分分钟钟成功\n结论 在 mac 下,使用 ndk 15.2.4203891(r15c) + ffmpeg 3.3.6 一定可以成功,其他的环境不保证\n编译过程 脚本 使用的是楼上同学的脚本修改 ndk 路径\n这里要注意 TMPDIR 对应的这个文件夹请提前建立好\n1#!/bin/bash 2export TMPDIR=/Users/cai/code/c/ffmpeg/tempdir 3NDK=/Users/cai/Library/Android/sdk/ndk-bundle 4 5TOOLCHAIN=$NDK/toolchains/arm-linux-androideabi-4.9/prebuilt/darwin-x86_64 6 7NDK_VERSION=android-14 8 9PLATFORM=$NDK/platforms/$NDK_VERSION/arch-arm 10 11echo \u0026#34;NDK=$NDK NDK_VERSION=$NDK_VERSION\u0026#34; 12 13# darwin linux 14function build_one { 15./configure \\ 16--target-os=linux \\ 17--arch=$ARCH \\ 18--prefix=$PREFIX \\ 19--enable-shared \\ 20--disable-static \\ 21--disable-doc \\ 22--disable-ffmpeg \\ 23--disable-ffplay \\ 24--disable-ffprobe \\ 25--disable-ffserver \\ 26--disable-doc \\ 27--disable-symver \\ 28--enable-cross-compile \\ 29--cross-prefix=$CROSS_COMPILE \\ 30--sysroot=$SYSROOT \\ 31--extra-cflags=\u0026#34;-fpic\u0026#34; 32 33$ADDITIONAL_CONFIGURE_FLAG 34 35make clean 36make -j8 37make install 38} 39 40ARCH=arm 41CPU=arm 42PREFIX=$(pwd)/android/$CPU 43TOOLCHAIN=$NDK/toolchains/arm-linux-androideabi-4.9/prebuilt/darwin-x86_64 44CROSS_COMPILE=$TOOLCHAIN/bin/arm-linux-androideabi- 45SYSROOT=$NDK/platforms/$NDK_VERSION/arch-$ARCH 46 47echo \u0026#34;PREFIX=${PREFIX}\u0026#34; 48echo \u0026#34;TOOLCHAIN=${TOOLCHAIN}\u0026#34; 49echo \u0026#34;CROSS_COMPILE=${CROSS_COMPILE}\u0026#34; 50echo \u0026#34;SYSROOT=${SYSROOT}\u0026#34; 51 52echo \u0026#34;******************************\u0026#34; 53 54build_one 修改 ffmpeg 配置源码 使用 vi/文本编辑器 之类的东西打开 ffmpeg/configure 修改\n1#SLIBNAME_WITH_MAJOR=\u0026#39;$(SLIBNAME).$(LIBMAJOR)\u0026#39; 2#LIB_INSTALL_EXTRA_CMD=\u0026#39;\\$$(RANLIB) \u0026#34;$(LIBDIR)/$(LIBNAME)\u0026#34;\u0026#39; 3#SLIB_INSTALL_NAME=\u0026#39;$(SLIBNAME_WITH_VERSION)\u0026#39; 4#SLIB_INSTALL_LINKS=\u0026#39;$(SLIBNAME_WITH_MAJOR) $(SLIBNAME)\u0026#39; 5 6SLIBNAME_WITH_MAJOR=\u0026#39;$(SLIBPREF)$(FULLNAME)-$(LIBMAJOR)$(SLIBSUF)\u0026#39; 7LIB_INSTALL_EXTRA_CMD=\u0026#39;\\$$(RANLIB)\u0026#34;$(LIBDIR)/$(LIBNAME)\u0026#34;\u0026#39; 8SLIB_INSTALL_NAME=\u0026#39;$(SLIBNAME_WITH_MAJOR)\u0026#39; 9SLIB_INSTALL_LINKS=\u0026#39;\\$(SLIBNAME)\u0026#39; 修改上面的为下面的\n原始文件行为 3305~3308 行\n编译 使用sh build_android.sh 打包 也可以用 chmod -x build_android.sh;./build_android.sh\n然后等待完成就可以了\n我这里是这样的\n查看编译结果 我这里分别编译得到这样的结果\n我这里是分别编译了 arm/v7a/arm64 的 so 文件,你只需要修改 sh 文件,将 CPU 分别设置即可打包出对应的类型\n1arm =\u0026gt; armeabi 2armeabi-v7a =\u0026gt; armeabi-v7a 3arm64-v8a =\u0026gt; arm64-v8a 修改这两个为对应的 cpu 类型即可\n1ARCH=arm 2CPU=arm 其实,正常来说 只需要一个 armeabi-v7a 就可以了,因为我是用的 flutter,为了兼容更多的设备,最好是有且只有 v7a 的 so 即可\n后记 本篇是使用 mac 交叉编译出安卓可用的 so 库,下一篇会介绍如何将 so 置入\n","link":"https://kikt.top/posts/android/android-ffmpeg-compile-so/","section":"posts","tags":["ffmpeg","android","ndk"],"title":"ndk编译ffmpeg"},{"body":"","link":"https://kikt.top/tags/cupertino/","section":"tags","tags":null,"title":"cupertino"},{"body":"1NosuchMethodError: The getter \u0026#39;pasterButtonLabel\u0026#39; was called on null. 2Receiver: null 3Tried calling: pasteButtonLabel 在最近 app store 提交审核时被拒了,然后得到了一个这样的截图\n在 flutter 中可能会会出现各种问题,因为之前遇到过这个问题,但是那是我另一个应用,这个忘了设置了\n我快速搞了一下,重新提交了审核\n解决方式 1import \u0026#39;package:flutter/cupertino.dart\u0026#39;; 2import \u0026#39;package:flutter/foundation.dart\u0026#39;; 3import \u0026#39;package:flutter/material.dart\u0026#39;; 4import \u0026#39;package:flutter_localizations/flutter_localizations.dart\u0026#39;; 5 6class ChineseCupertinoLocalizations implements CupertinoLocalizations { 7 final materialDelegate = GlobalMaterialLocalizations.delegate; 8 final widgetsDelegate = GlobalWidgetsLocalizations.delegate; 9 final local = const Locale(\u0026#39;zh\u0026#39;); 10 11 MaterialLocalizations ml; 12 13 Future init() async { 14 ml = await materialDelegate.load(local); 15 print(ml.pasteButtonLabel); 16 } 17 18 @override 19 String get alertDialogLabel =\u0026gt; ml.alertDialogLabel; 20 21 @override 22 String get anteMeridiemAbbreviation =\u0026gt; ml.anteMeridiemAbbreviation; 23 24 @override 25 String get copyButtonLabel =\u0026gt; ml.copyButtonLabel; 26 27 @override 28 String get cutButtonLabel =\u0026gt; ml.cutButtonLabel; 29 30 @override 31 DatePickerDateOrder get datePickerDateOrder =\u0026gt; DatePickerDateOrder.mdy; 32 33 @override 34 DatePickerDateTimeOrder get datePickerDateTimeOrder =\u0026gt; 35 DatePickerDateTimeOrder.date_time_dayPeriod; 36 37 @override 38 String datePickerDayOfMonth(int dayIndex) { 39 return dayIndex.toString(); 40 } 41 42 @override 43 String datePickerHour(int hour) { 44 return hour.toString().padLeft(2, \u0026#34;0\u0026#34;); 45 } 46 47 @override 48 String datePickerHourSemanticsLabel(int hour) { 49 return \u0026#34;$hour\u0026#34; + \u0026#34;时\u0026#34;; 50 } 51 52 @override 53 String datePickerMediumDate(DateTime date) { 54 return ml.formatMediumDate(date); 55 } 56 57 @override 58 String datePickerMinute(int minute) { 59 return minute.toString().padLeft(2, \u0026#39;0\u0026#39;); 60 } 61 62 @override 63 String datePickerMinuteSemanticsLabel(int minute) { 64 return \u0026#34;$minute\u0026#34; + \u0026#34;分\u0026#34;; 65 } 66 67 @override 68 String datePickerMonth(int monthIndex) { 69 return \u0026#34;$monthIndex\u0026#34;; 70 } 71 72 @override 73 String datePickerYear(int yearIndex) { 74 return yearIndex.toString(); 75 } 76 77 @override 78 String get pasteButtonLabel =\u0026gt; ml.pasteButtonLabel; 79 80 @override 81 String get postMeridiemAbbreviation =\u0026gt; ml.postMeridiemAbbreviation; 82 83 @override 84 String get selectAllButtonLabel =\u0026gt; ml.selectAllButtonLabel; 85 86 @override 87 String timerPickerHour(int hour) { 88 return hour.toString().padLeft(2, \u0026#34;0\u0026#34;); 89 } 90 91 @override 92 String timerPickerHourLabel(int hour) { 93 return \u0026#34;$hour\u0026#34;.toString().padLeft(2, \u0026#34;0\u0026#34;) + \u0026#34;时\u0026#34;; 94 } 95 96 @override 97 String timerPickerMinute(int minute) { 98 return minute.toString().padLeft(2, \u0026#34;0\u0026#34;); 99 } 100 101 @override 102 String timerPickerMinuteLabel(int minute) { 103 return minute.toString().padLeft(2, \u0026#34;0\u0026#34;) + \u0026#34;分\u0026#34;; 104 } 105 106 @override 107 String timerPickerSecond(int second) { 108 return second.toString().padLeft(2, \u0026#34;0\u0026#34;); 109 } 110 111 @override 112 String timerPickerSecondLabel(int second) { 113 return second.toString().padLeft(2, \u0026#34;0\u0026#34;) + \u0026#34;秒\u0026#34;; 114 } 115 116 static const LocalizationsDelegate\u0026lt;CupertinoLocalizations\u0026gt; delegate = 117 _ChineseDelegate(); 118 119 static Future\u0026lt;CupertinoLocalizations\u0026gt; load(Locale locale) async { 120 var localizaltions = ChineseCupertinoLocalizations(); 121 await localizaltions.init(); 122 return SynchronousFuture\u0026lt;CupertinoLocalizations\u0026gt;(localizaltions); 123 } 124} 125 126class _ChineseDelegate extends LocalizationsDelegate\u0026lt;CupertinoLocalizations\u0026gt; { 127 const _ChineseDelegate(); 128 129 @override 130 bool isSupported(Locale locale) { 131 return locale.languageCode == \u0026#39;zh\u0026#39;; 132 } 133 134 @override 135 Future\u0026lt;CupertinoLocalizations\u0026gt; load(Locale locale) { 136 return ChineseCupertinoLocalizations.load(locale); 137 } 138 139 @override 140 bool shouldReload(LocalizationsDelegate\u0026lt;CupertinoLocalizations\u0026gt; old) { 141 return false; 142 } 143} 这个东西弄到项目里\n然后在 Application 里配置一下\n1class MyApp extends StatelessWidget { 2 // This widget is the root of your application. 3 @override 4 Widget build(BuildContext context) { 5 return MaterialApp( 6 title: \u0026#39;Flutter Demo\u0026#39;, 7 theme: ThemeData( 8 // This is the theme of your application. 9 // 10 // Try running your application with \u0026#34;flutter run\u0026#34;. You\u0026#39;ll see the 11 // application has a blue toolbar. Then, without quitting the app, try 12 // changing the primarySwatch below to Colors.green and then invoke 13 // \u0026#34;hot reload\u0026#34; (press \u0026#34;r\u0026#34; in the console where you ran \u0026#34;flutter run\u0026#34;, 14 // or simply save your changes to \u0026#34;hot reload\u0026#34; in a Flutter IDE). 15 // Notice that the counter didn\u0026#39;t reset back to zero; the application 16 // is not restarted. 17 primarySwatch: Colors.blue, 18 ), 19 home: MyHomePage(title: \u0026#39;Flutter Demo Home Page\u0026#39;), 20 localizationsDelegates: \u0026lt;LocalizationsDelegate\u0026lt;dynamic\u0026gt;\u0026gt;[ 21 ChineseCupertinoLocalizations.delegate, // 这里加上这个,是自定义的delegate 22 23 DefaultCupertinoLocalizations.delegate, // 这个截止目前只包含英文 24 25 // 下面两个是Material widgets的delegate, \u0008包含中文 26 GlobalMaterialLocalizations.delegate, 27 GlobalWidgetsLocalizations.delegate, 28 ], 29 supportedLocales: [ 30 const Locale(\u0026#39;en\u0026#39;, \u0026#39;US\u0026#39;), // English 31 const Locale(\u0026#39;zh\u0026#39;, \u0026#39;Hans\u0026#39;), // China 32 const Locale(\u0026#39;zh\u0026#39;, \u0026#39;\u0026#39;), // China 33 // ... other locales the app supports 34 ], 35 ); 36 } 37} 这样就能完成默认的中文的本地化,当然之前那个 Cupertino 的 \u0008delegate 实际上也是借助了 Material 中的 delegate 本地化\n这里还要注意,一定要保证你的设备是本地语言是中文(因为很多朋友是使用模拟器开发的,默认是英文)\n原因分析 这里要解析一波源码了,为什么会出现这种情况呢\n主要原因就是在某个版本,加入了一整套的 Cupertino 相关的支持,但是又因为某些原因遗忘了非英文版本,造成了默认的情况下,不包含其他语言\n而在未设置对应语言的 delegate 时,又没有一个默认的 delegate,从而造成空指针异常,进而抛出错误\n源码解析 这个是 Cupertino 中,弹出剪切/复制/粘贴/全选那个按钮那个 toolbar 的配置界面,这里会使用到这个类,然而又因为得到的是空的,所以会报空指针异常\n而获取的方式是使用CupertinoLocalizations.of(context);的方式\n查看这个方法的定义处又可以跟踪到另一个地方\n然后来到这段代码\n1Future\u0026lt;Map\u0026lt;Type, dynamic\u0026gt;\u0026gt; _loadAll(Locale locale, Iterable\u0026lt;LocalizationsDelegate\u0026lt;dynamic\u0026gt;\u0026gt; allDelegates) { 2 final Map\u0026lt;Type, dynamic\u0026gt; output = \u0026lt;Type, dynamic\u0026gt;{}; 3 List\u0026lt;_Pending\u0026gt; pendingList; 4 5 // Only load the first delegate for each delegate type that supports 6 // locale.languageCode. 7 final Set\u0026lt;Type\u0026gt; types = Set\u0026lt;Type\u0026gt;(); 8 final List\u0026lt;LocalizationsDelegate\u0026lt;dynamic\u0026gt;\u0026gt; delegates = \u0026lt;LocalizationsDelegate\u0026lt;dynamic\u0026gt;\u0026gt;[]; 9 for (LocalizationsDelegate\u0026lt;dynamic\u0026gt; delegate in allDelegates) { 10 if (!types.contains(delegate.type) \u0026amp;\u0026amp; delegate.isSupported(locale)) { 11 types.add(delegate.type); 12 delegates.add(delegate); 13 } 14 } 15 16 for (LocalizationsDelegate\u0026lt;dynamic\u0026gt; delegate in delegates) { 17 final Future\u0026lt;dynamic\u0026gt; inputValue = delegate.load(locale); 18 dynamic completedValue; 19 final Future\u0026lt;dynamic\u0026gt; futureValue = inputValue.then\u0026lt;dynamic\u0026gt;((dynamic value) { 20 return completedValue = value; 21 }); 22 if (completedValue != null) { // inputValue was a SynchronousFuture 23 final Type type = delegate.type; 24 assert(!output.containsKey(type)); 25 output[type] = completedValue; 26 } else { 27 pendingList ??= \u0026lt;_Pending\u0026gt;[]; 28 pendingList.add(_Pending(delegate, futureValue)); 29 } 30 } 31 32 // All of the delegate.load() values were synchronous futures, we\u0026#39;re done. 33 if (pendingList == null) 34 return SynchronousFuture\u0026lt;Map\u0026lt;Type, dynamic\u0026gt;\u0026gt;(output); 35 36 // Some of delegate.load() values were asynchronous futures. Wait for them. 37 return Future.wait\u0026lt;dynamic\u0026gt;(pendingList.map\u0026lt;Future\u0026lt;dynamic\u0026gt;\u0026gt;((_Pending p) =\u0026gt; p.futureValue)) 38 .then\u0026lt;Map\u0026lt;Type, dynamic\u0026gt;\u0026gt;((List\u0026lt;dynamic\u0026gt; values) { 39 assert(values.length == pendingList.length); 40 for (int i = 0; i \u0026lt; values.length; i += 1) { 41 final Type type = pendingList[i].delegate.type; 42 assert(!output.containsKey(type)); 43 output[type] = values[i]; 44 } 45 return output; 46 }); 47} 简单来说,这个方法是根据本地的语言读取所有支持这个语言的 delegate\n然后问题来了,\u0008 没读取到怎么办呢\n有几处代码需要关注一下\n这里就看出来了,为什么会有空指针异常的原因 3 =\u0026gt; 2 =\u0026gt; 1 但是 1 也没读取到 \u0008,自然就空指针了\n后记 本篇介绍了解决方案 pastelabel copylabel 各种 \u0008label 空指针的原因和解决方案\n","link":"https://kikt.top/posts/flutter/framework/cupertino-paste-tooltip/","section":"posts","tags":["cupertino","flutter"],"title":"flutter cupertino 复制粘贴弹窗报错的问题"},{"body":"开篇声明:本篇文章不算是新手向的东西,你需要对于 flutter 和 android 本身有一定的了解\n文章原因 为啥要写这个文章呢\n最近有 qq 群的同学询问如何在关闭界面后在 service 中执行 dart 代码\n我当时的理解就是 flutter 是依附于 activity 存在的,但是这部分并没有任何实际支撑\n所以我抱着好奇的想法去跟了一下 engine 部分的源码\nflutter engine 简单介绍 这里简单介绍一下 flutter engine,\n在 android 系统上 flutter 是使用 FlutterView 实现的,\n对应的 java 层级的源码都在这里\n一般一个纯 flutter 项目中是这样的, 有一个 FlutterApplication 一个 FlutterActivity 一个 FlutterView,而我们 flutter 所有的界面都是在 FlutterView 上画的\n解析开始 以下基于你对于 android 原生开发有所涉猎,而不是完全不了的基础上展开\n我们都知道,当 finish Activity 后页面会回调onDestroy方法\n这个方法中会回调一个eventDelegate.onDestroy,我们查看以下这个东西具体是调用到哪里\n能看到具体的调用是这样的\n如果 Application 是 FlutterApplication 会直接将当前 Activity 置空\n根据 flutterview 附着与否执行detach或destroy\n可以看到这东西是一个 FlutterView\n跟到这里的源码中去查看一下\n两个方法挨在一起,我们解析一下\ndetach 方法会调用mNativeView.detach()\ndestroy 会调用 mNativeView.destroy()\n而这两个方法又都会调用mFlutterJNI.detachFromNativeButKeepNativeResources();\n对应的调用如下\n这里是一个 native 方法,看来是 hi 用于销毁 native 部分的\n结论 所以,想在 flutterView 关闭后去调用 dart 层级的代码,如果不魔改 engine 应该是实现不了的\n以上\n","link":"https://kikt.top/posts/flutter/android/finish-activity/","section":"posts","tags":["flutter","android","源码解析"],"title":"Finish FlutterActivity 源码解析"},{"body":"","link":"https://kikt.top/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/","section":"tags","tags":null,"title":"源码解析"},{"body":"","link":"https://kikt.top/tags/bottomsheet/","section":"tags","tags":null,"title":"bottomsheet"},{"body":"前言 最近看到群里有朋友在问类似于\n这东西怎么实现\n我回答的可能不那么清楚,因为我就答了 bottomSheet,下次我可能会回答的更清楚些\n这东西在可能在 flutter 里有如下几种解释\nScaffold 的 bottomSheet 属性 一个叫 BottomSheet 的 widget 组件 Scaffold.showBottomSheet 方法 showBottomSheet 方法也就是一个底层弹窗 这里分别来简单的说一下\nScaffold 的 bottomSheet 属性 这个就是前言中的那种东西的简单实现方式,直接把聊天的输入框(TextField)放在里面,用 Container 也好,也用其他什么控件也可以,当然 Container =\u0026gt; Row =\u0026gt; [TextField,Button]就能实现图上的效果了\n简单的页面代码如下\n1import \u0026#39;package:flutter/material.dart\u0026#39;; 2 3class BottomSheet1Page extends StatefulWidget { 4 @override 5 _BottomSheetPageState createState() =\u0026gt; _BottomSheetPageState(); 6} 7 8class _BottomSheetPageState extends State\u0026lt;BottomSheet1Page\u0026gt; { 9 @override 10 Widget build(BuildContext context) { 11 return Scaffold( 12 appBar: AppBar( 13 title: Text(\u0026#39;bottom sheet\u0026#39;), 14 ), 15 body: ListView.builder( 16 itemBuilder: (BuildContext context, int index) { 17 return ListTile( 18 title: Text(index.toString()), 19 subtitle: Text(\u0026#34;我是${index}的副标题\u0026#34;), 20 ); 21 }, 22 itemCount: 300, 23 ), 24 bottomSheet: Container( 25 child: Row( 26 children: \u0026lt;Widget\u0026gt;[ 27 Expanded(child: TextField()), 28 RaisedButton( 29 child: Text(\u0026#39;发送\u0026#39;), 30 onPressed: () {}, 31 ), 32 ], 33 ), 34 ), 35 ); 36 } 37} 效果如下\n当然如果要适配 iphoneX 之类的 \u0008,底部可能需要套SafeArea在外面,这类的东西不属于本篇 blog 的内容,一笔带过而已\n一个叫 BottomSheet 的 widget 组件 这个看了一下内部实现,增加了一些手势,就是支持往下拉关闭BottomSheet\nScaffold.showBottomSheet 方法 1import \u0026#39;package:flutter/material.dart\u0026#39;; 2 3class ScaffoldBottomSheetPage extends StatefulWidget { 4 @override 5 _ScaffoldBottomSheetPageState createState() =\u0026gt; _ScaffoldBottomSheetPageState(); 6} 7 8class _ScaffoldBottomSheetPageState extends State\u0026lt;ScaffoldBottomSheetPage\u0026gt; { 9 @override 10 Widget build(BuildContext context) { 11 return Scaffold( 12 appBar: AppBar( 13 title: Text(\u0026#34;scaffold show bottom sheet\u0026#34;), 14 ), 15 body: ListView(), 16 floatingActionButton: Builder(builder: (c) { 17 return FloatingActionButton( 18 onPressed: () { 19 Scaffold.of(c).showBottomSheet( 20 (c) { 21 return Container( 22 child: Text(\u0026#34;我是底部弹出来的\u0026#34;), 23 height: 200.0, 24 ); 25 }, 26 ); 27 }, 28 ); 29 }), 30 ); 31 } 32} 使用前的状态\n点击后会弹出一个底部弹窗,等待关闭,关闭这个东西你只需要从上往下拖动即可\n因为这个是基于 Scaffold 的,所以会和 Scaffold 中的其他部件联动,比如如图所示那个FloatActionButton\nshowBottomSheet 方法也就是一个底层弹窗 用于从底部弹出弹窗,这个方法是material包中定义的一个全局方法\n实际上也是使用的 Scaffold 的 showBottomSheet 方法,直接参考上面就可以\n后记 以上\n","link":"https://kikt.top/posts/flutter/flutter-bootom-sheet/","section":"posts","tags":["flutter","bottomsheet","ui"],"title":"Flutter bottomSheet的使用"},{"body":"","link":"https://kikt.top/tags/ui/","section":"tags","tags":null,"title":"ui"},{"body":"","link":"https://kikt.top/categories/caddy/","section":"categories","tags":null,"title":"caddy"},{"body":"caddy 是使用 go 语言开发的一个 server 服务器\n相对于 nginx 来说,这个部署更简单,配置起来也很简单,很适合搭私人站点使用,而且相比于 nginx 来说,这个只有单文件,很适合小白使用\n而且,这东西最大的优点是,可以通过简单的配置来支持 https,而无需操心证书,另外还支持 http2 协议\n这里有一份,请注意查收\n入手 以 mac os 为例 我只需要 brew install caddy 然后, 运行 caddy,这样就完成了最简单的部署过程...\n当然这是因为有默认配置的关系,整个项目是单文件的,就只有一个 caddy 文件\n其他系统的参考\n运行结果如下 默认是 2015 端口,可能是代表这个项目是 2015 年创建/发布的?\n然后打开 就可以看到你的网页了,当然这里因为有默认的原因,你看到的也许是 404,或是其他的什么\n自定义配置 caddy 支持命令行的一些简单配置和配置文件的复杂配置\n命令行 使用caddy -h 可以看到最新最全的命令行参数列表 这里说命令行运行简单命令的意思并不是支持不全,而是有一些复杂的情况,如果用命令行来做调错比较麻烦\n比如 -agree 同意 CA 的协议\n-ca XXX 获取指定 host 的 ca 证书\n一般情况下比较有用的就是\n-conf string 使用配置文件\n-email string ca 的 email\n-host string 域名\n-http-port string http 协议的端口号 默认 80\n-https-port string https 协议的端口号 默认是 443\n-port string 端口号\n-log string 日志文件的目录\n-http2 支持 http2 协议\n这部分具体的可以参考 部分\nCA\u0008 相关的 \u0008 就是 https 要用到的东西\n在使用域名的方式之前 你需要确定好你的域名解析是指向当前这台计算机的\n配置文件 这个使用起来很简单 就是 caddy -conf XXX 这里的 XXX 是配置文件的目录\n然后 caddy 会去读取配置文件 这部分可以参考 部分,这个是 caddyfile 文件的基本语法\n还有一种方式就是简单的使用caddy 这里 caddy 会在当前的运行路径下根据默认约定去寻找 Caddyfile 文件作为配置\n1localhost:80 { 2 root /Users/caijinglong/www 3 gzip 4 log /Users/caijinglong/www/log/caddy.log 5} 这里是一个简单配置方案 80 端口\n这里就是开启 html 的文件目录,gzip ,指定日志文件,\n这里需要将目录替换成你自己的目录\n我的目录结构是这样的 只要我在这个目录下运行,就可以看到这样的 \u0008 效果 我们的服务器就启动起来了\n然后进行一些其他的配置\n这里可以参考一下 我们在配置文件上有标题的概念 这个标题就是反向代理的地址 支持如下的格式,包括协议 host ,通配符,端口,path\ndocker 的方式配置 以当前的网站为例,我在阿里 dns 上配置了域名解析,然后我只需要如下配置即可完成 kikt.top www.kikt.top的配置,且自动完成了 https 协议\n首先是 Caddyfile\n1kikt.top { 2 gzip 3 tls cjl_spy@163.com 4} 5 6www.kikt.top { 7 gzip 8 tls cjl_spy@163.com 9} 这里我没有指定目录是因为 Caddy 的 docker 镜像中我配置了映射的原因\ndocker-componse.yaml\n1version: \u0026#34;3\u0026#34; 2services: 3 blog-web-caddy: 4 image: abiosoft/caddy 5 ports: 6 - \u0026#34;80:80\u0026#34; 7 - \u0026#34;443:443\u0026#34; 8 volumes: 9 - $HOME/docker/caddy/.caddy:/root/.caddy 10 - $HOME/docker/caddy/Caddyfile:/etc/Caddyfile 11 - $HOME/html/www:/srv 12 environment: 13 - TZ=Asia/Shanghai 这里我使用的镜像是\n这里有详细介绍,我只是使用了几个简单的配置\n指定了端口号,将 80 443 端口映射出来 指定了文件映射,证书文件,Caddyfile,html 文件 去那边关掉 nginx 后\n接着执行docker-compose up -d,这样就完成了全部的部署,这样我的 blog html 服务器就从 nginx 切换到了 caddy 😁\n一些其他的配置 我的服务器中在 3000 端口有一个 gogs 的 git 服务器\n我修改 Caddyfile\n1kikt.top { 2 gzip 3 tls cjl_spy@163.com 4} 5 6www.kikt.top { 7 gzip 8 tls cjl_spy@163.com 9} 10 11git.kikt.top { 12 gzip 13 proxy / kikt.top:3000 14} 增加一个二级域名,把 git.kikt.top 代理到同域名的 3000 端口上\n后记 caddy 总体来说还是入门比较容易的,配置也相对简单,但是目前可能还没有 nginx 的周边那么丰富,而且市场占有率现在也无法相比\n如果是自己搭网站,可以用 caddy,简单易用,也不用考虑那么多东西,直接零配置支持 https\n如果是为了今后的职业规划 nginx 还是必须要学习的\n","link":"https://kikt.top/posts/server/caddy/caddy-first/","section":"posts","tags":["caddy","server","docker"],"title":"Caddy 初探"},{"body":"","link":"https://kikt.top/categories/docker/","section":"categories","tags":null,"title":"docker"},{"body":"最近沉迷 flutter,偶尔换换口味,看看 github\n很多知名的开源项目落户于 github,那么为什么呢,人云亦云吗?\n不一定, github 的工作流很强大.能够帮助我们更加清晰工作流程\n首先官方链接在此,英文好的直接去看\n另外还有一个帮助你学习 github 的小机器人\n这个小机器人能帮你系统的了解一些 github 的工作流和 github 的一些基本功能\n比如 github 仓库的元数据修改,关键字修改,github pages 的发布\n工作流包括 issues 中的\nPR 整体过程中 分派工作/审核/修改意见/冲突处理/merge 代码的流程,强烈建议 github 用的不好的人先去梳理一下\nissue 篇 常规的创建之类的就不说了,说一些你日常中看不到的东西,或者说看见了,但是不知道怎么玩出来的\n不会包含所有的东西,但是会有一些很神奇的效果\n通过代码创建一个 issue 比如我在某行代码发现了一个错误, 那么我可以直接在 github 中选中这个代码,然后开启一个 issue\n点击行号\nopen new issue\n通过这几个步骤,我们能看到,我们创建了一个指向改行的错误,这样开发者就能很简单的定位到该行,并且可以直观的在 issue 中看到该行代码,方便开发者定位\n创建一个永久可见的代码连接 提交后就可以看到了\nTODO List 进度条 有的时候我们会需要使用 issue 来记录我们的开发过程,或者功能需求来提醒我们什么没做\n使用类似如下的写法来创建即可\n1- [X] 第一项工作 2- [ ] 第二项工作 3- [X] 第三项工作 4- [X] 第四项工作 成功后是这样的\n然后这个是可以鼠标直接点击/拖动的\n好处就是可以在列表中直接看到进度条\n使用关键字关闭 issue 有如下的关键字可以用于关闭 issue\nclose closes closed fix fixes fixed resolve resolves resolved\n例子 比如我要关闭 123 号问题\n可以使用close #123 或者 Closes: #123\n上面的例子是关闭 \u001b 同一个储存库的方式\n如果你对于两个储存库都有权限,则可以使用\nfix flutter/flutter#3283 这样的方式来关闭 \u0008 这个问题\n重复问题 除了上面的关键字以外 还有另一个关键字可以用于关闭 当然原则上来讲只限于重复的提交\nDuplicate of 关键字\n比如 你网络出现了问题 提交了 3 个相同的 issue ,分别是#1 #2 #3\n则仓库所有者发现后可以在#2 #3其中分别回复Duplicate of #1来直接关闭 2 和 3\n","link":"https://kikt.top/posts/github/work-manager/","section":"posts","tags":["github","tips"],"title":"github 一些小技巧"},{"body":"","link":"https://kikt.top/tags/tips/","section":"tags","tags":null,"title":"tips"},{"body":"http 简介 http 是一个 http 网络请求框架, 由 dart team 出品\n与HttpClient不是一回事,至于和 dio 孰优孰劣自己见仁见智吧\n通过下载\n基础的 api http 协议中有多种 METHOD,当然最常见的就是 GET POST,\n因为最近几年 restful 协议的频繁使用,使得 PUT,DELETE,PATCH 方法也有了一定的使用率\n基础使用 1import \u0026#39;package:http/http.dart\u0026#39; as http; 2void get(String url) async { 3 http.Response response = await http.get(url); 4 5 // 其他的返回值都是一样的 6 http.post(url); 7 http.put(url); 8 http.patch(url); 9 http.delete(url); 10 http.head(url); 11} 增加请求头 1 void headerDemo(String url, Map\u0026lt;String, String\u0026gt; headers) async { 2 http.get(url, headers: headers); 3 4 // 其他的方法相同 5 } post 常见的请求方式 常见的请求方式有如下几种(来自于postman) 或者使用 查看也可以帮助加深理解\nform-data 模拟表单上传\n1Future\u0026lt;String\u0026gt; postFormData(String url, Map\u0026lt;String, String\u0026gt; headers, 2 Map\u0026lt;String, String\u0026gt; params, Map\u0026lt;String, File\u0026gt; files) async { 3 Completer\u0026lt;String\u0026gt; completer = Completer(); 4 5 var request = http.MultipartRequest(\u0026#34;POST\u0026#34;, Uri.parse(url)); 6 7 request.fields.addAll(params); 8 files.forEach((k, v) { 9 var partFile = http.MultipartFile( 10 k, 11 v.readAsBytes().asStream(), 12 v.lengthSync(), 13 ); 14 request.files.add(partFile); 15 }); 16 17 var ioClient = http.IOClient(); 18 var response = await ioClient.send(request); 19 20 List\u0026lt;int\u0026gt; responseBody = []; 21 22 response.stream.listen((data) { 23 responseBody.addAll(data); 24 }, onDone: () { 25 var string = String.fromCharCodes(responseBody); 26 completer.complete(string); 27 }, onError: (err) { 28 completer.completeError(err); 29 }); 30 31 return completer.future; 32 } x-www-form-urlencoded 这个也是\n1 Future\u0026lt;http.StreamedResponse\u0026gt; xWwwFormUrlencoded( 2 String url, Map\u0026lt;String, String\u0026gt; params) { 3 var request = http.Request(\u0026#34;POST\u0026#34;, Uri.parse(url)); 4 request.bodyFields = params; 5 return request.send(); 6 } 这里只需要简单的使用 bodyFild 设置 params 即可\n参考源码可知 当 contentType 为空的时候会自动设置 contentType 为x-www-form-urlencoded\nraw(文本) 这里有多种选择的原因是因为:有的时候部分第三方接口可能支持xml/json/protobuf等多种交互方案\n流(binary 二进制) 其实目前很多的 api 接口对于 contentType 并不敏感,单纯的接收一个数据/图片或其他的信息,然后返回值\n1 Future\u0026lt;http.StreamedResponse\u0026gt; streamRequest( 2 String url, List\u0026lt;int\u0026gt; streamContent) { 3 var request = http.StreamedRequest(\u0026#34;POST\u0026#34;, Uri.parse(url)); 4 request.sink.add(streamContent); 5 return request.send(); 6 } 本篇讲解了 http 的库的基本用法,理论上能满足大部分的需求了, 下一篇写几个可能会遇到也可能遇不到的写法\n","link":"https://kikt.top/posts/flutter/http/flutter-http1/","section":"posts","tags":["flutter","http"],"title":"flutter http框架简介(1)"},{"body":"","link":"https://kikt.top/tags/http/","section":"tags","tags":null,"title":"http"},{"body":"","link":"https://kikt.top/tags/apk/","section":"tags","tags":null,"title":"apk"},{"body":"java.lang.UnsatisfiedLinkError: dalvik.system.PathClassLoader[DexPathList[[zip file \u0026quot;/system/framework/android.test.runner.jar\u0026quot;, ...... base.apk!/lib/arm64-v8a, /system/lib64, /system/vendor/lib64]]] couldn't find \u0026quot;libflutter.so\u0026quot;\n这种问题可以看到其中有 arm64 的字样. 也有 libflutter.so\n在以前运行打包命令后 可以正常运行的项目,可能在更新 flutter 1.0.0 后不能正常运行\n1flutter build apk 这种情况通常是因为 so 文件没有打包到 apk 中造成的 拖动 apk 到 android Studio 中可以看到其中包含的库文件\n我前面有一篇的文章可以解释原理\n但是 flutter 升级后 可以查看flutter.gradle文件\n图片中的代码说明了当目标是 arm64 的时候, 会自动将 64 的 so 打包到 flutter 内, 这里的问题就造成了以前你在自己的 gradle 设置的打包选项和这个同时生效,也就是 v7 v8 的 so 都不进 apk 里了..\n一个小说明 在说解决方案前,有一点需要说明的是 armeabi -\u0026gt; v7 -\u0026gt;v8,这个是 arm cpu 架构的进化过程,而后来的 cpu 是兼容前代的 so 库,\n目前市面上的 android 手机 32 位都是很少见的了,但是为了可能发生的意外,目前使用 v7 足够了, 要知道 wechat 内的 so 还是 armeabi 版本的,所以不用担心\n解决方案 在项目 android 目录下有一个gradle.properties文件 这里添加target-platform=android-arm\n然后在 build.gradle android.buildTypes.release 里增加\n1android.buildTypes.release 2{ 3 ndk{ 4 abiFilters \u0026#34;armeabi-v7a\u0026#34; 5 } 6} 这样打包出来的 apk 内应该只包含 v7a 的 so,且 libflutter.so 也会在 apk 内\n现在市面上的手机 v7 都是少数派了,大部分都是 v8 的 cpu,所以放心大胆的去用吧\n","link":"https://kikt.top/posts/flutter/flutter-arm64-crash/","section":"posts","tags":["flutter","打包","apk"],"title":"Flutter 1.0.0 打包apk后运行错误"},{"body":"","link":"https://kikt.top/tags/%E6%89%93%E5%8C%85/","section":"tags","tags":null,"title":"打包"},{"body":"","link":"https://kikt.top/tags/channel/","section":"tags","tags":null,"title":"channel"},{"body":"原生通信系列\n本篇主要介绍如何在 iOS 中发布广播,然后在 dart 端进行订阅\noc 先来查看 OC 篇\n1#import \u0026#34;BattlePowerPlugin.h\u0026#34; 2#import \u0026lt;Foundation/NSTimer.h\u0026gt; 3 4@implementation BattlePowerPlugin 5 6+ (void)registerWithRegistrar:(NSObject\u0026lt;FlutterPluginRegistrar\u0026gt;*)registrar { 7 // ... 8 9 [self registerPostTimerWithRegistrar:registrar]; 10} 11 12+(void) registerPostTimerWithRegistrar:(NSObject\u0026lt;FlutterPluginRegistrar\u0026gt;*)registrar{ 13 FlutterBasicMessageChannel *channel = [FlutterBasicMessageChannel messageChannelWithName:@\u0026#34;run_time\u0026#34; binaryMessenger:[registrar messenger]]; 14 15 long start = [self getNow]; 16 17 [NSTimer scheduledTimerWithTimeInterval:5 repeats:true block:^(NSTimer * _Nonnull timer) { 18 long run = [self getNow] - start; 19 [channel sendMessage:[NSNumber numberWithLong:run]]; 20 21 if (run \u0026gt; 100){ 22 [timer invalidate]; 23 } 24 }]; 25} 26 27+(long)getNow{ 28 NSDate *date = [NSDate date]; 29 long timeStamp = [date timeIntervalSince1970]; 30 return timeStamp; 31} 32 33//... 34 35@end 间隔 5 秒通过 sendMessage 发送一条消息\ndart 再来看 dart 代码,这里和系列文章第二篇一致\n1import \u0026#39;dart:async\u0026#39;; 2 3import \u0026#39;package:flutter/services.dart\u0026#39;; 4 5class BattlePower { 6 // ... 7 8 static const BasicMessageChannel\u0026lt;dynamic\u0026gt; runTimer = const BasicMessageChannel(\u0026#34;run_time\u0026#34;, StandardMessageCodec()); 9 10 static void initMessageHandler() { 11 print(\u0026#34;initMessageHandler\u0026#34;); 12 runTimer.setMessageHandler((dynamic value) { 13 // 接收到的时间 14 int time = value; 15 print(\u0026#34;value = $time\u0026#34;); 16 }); 17 } 18} 这里使用BasicMessageChannel 接收回调\n看看 \u0008 运行结果,这里和 android 不一样, ios 的时间戳是 double 形式, 小数点左边是秒,\u0008 我这里进行了强转,所以获取到的时间就只有秒\n好了 插件入门篇到这里就结束了,希望大家多多为开源做出贡献,也希望大家的 flutter 开发之路越走越宽\n","link":"https://kikt.top/posts/flutter/channel/flutter-channel4/","section":"posts","tags":["channel","flutter","iOS"],"title":"Flutter 原生通信 (四) - iOS 通知 Flutter"},{"body":"原生通信系列\n本篇要介绍的是 flutter 调用 iOS 篇\n如果你没有看过我的前 2 篇,建议看一下. dart 端会承接上一篇的结果\ndart 1import \u0026#39;dart:async\u0026#39;; 2 3import \u0026#39;package:flutter/services.dart\u0026#39;; 4 5class BattlePower { 6 static const MethodChannel _channel = const MethodChannel(\u0026#39;battle_power\u0026#39;); 7 8 static Future\u0026lt;String\u0026gt; get platformVersion async { 9 final String version = await _channel.invokeMethod(\u0026#39;getPlatformVersion\u0026#39;); 10 return version; 11 } 12 13 static Future\u0026lt;int\u0026gt; requestNativeAdd(int x, int y) async { 14 int result = await _channel.invokeMethod(\u0026#39;add\u0026#39;, {\u0026#34;x\u0026#34;: x, \u0026#34;y\u0026#34;: y}); 15 return result; 16 } 17 18 //.... 19} 这里和第一篇一样\n不详细介绍了\n这里是以 oc 为例的,不建议用 swift 开发插件,尤其是开源插件\n当然如果你自用 还是可以用 swift 的. 后面有机会会更新一下 swift 的版本\n找到你的 oc 插件文件夹 如果你是苹果的死忠那就用 xcode 就好 不然 jetbrains 有一款 AppCode 很适合开发 oc,比 xcode 开发的体验好很多\n这里参考截图这里打开 会发现不太对 只有 Runner 部分,没有 \u0008 插件部分,这时候需要在命令行做如下操作\n1cd example/ios 2pod install 大概会得到如下的输出 这时候关闭 xcode 重新点 open in xcode\n打开后应该会看到项目变成了两个,这就说明你成功了,参考下图 接着准备开发插件\n这里比较坑,对于初次开发插件的人来说可能不太好找\n点开那个.m 就对了\n如果不会 oc 语法 你还是需要熟悉下的. 你看这篇文章学不到 oc 语法 😄😉\noc 代码 1#import \u0026#34;BattlePowerPlugin.h\u0026#34; 2 3@implementation BattlePowerPlugin 4+ (void)registerWithRegistrar:(NSObject\u0026lt;FlutterPluginRegistrar\u0026gt;*)registrar { 5 FlutterMethodChannel* channel = [FlutterMethodChannel 6 methodChannelWithName:@\u0026#34;battle_power\u0026#34; 7 binaryMessenger:[registrar messenger]]; 8 BattlePowerPlugin* instance = [[BattlePowerPlugin alloc] init]; 9 [registrar addMethodCallDelegate:instance channel:channel]; 10} 11 12- (void)handleMethodCall:(FlutterMethodCall*)call result:(FlutterResult)result { 13 if ([@\u0026#34;getPlatformVersion\u0026#34; isEqualToString:call.method]) { 14 result([@\u0026#34;iOS \u0026#34; stringByAppendingString:[[UIDevice currentDevice] systemVersion]]); 15 } else { 16 result(FlutterMethodNotImplemented); 17 } 18} 19 20@end 略微分析下:\n这里使用 [FlutterMethodChannel methodChannelWithName] 来定义插件的方法\n使用 handleMethodCall\u001b 来处理调用\n关于 dart-oc 类型对应查看\n添加方法 dart 中有一个 add 方法,我们在 \u0008OC 中添加这个 add 方法\n1#import \u0026#34;BattlePowerPlugin.h\u0026#34; 2 3@implementation BattlePowerPlugin 4+ (void)registerWithRegistrar:(NSObject\u0026lt;FlutterPluginRegistrar\u0026gt;*)registrar { 5 FlutterMethodChannel* channel = [FlutterMethodChannel 6 methodChannelWithName:@\u0026#34;battle_power\u0026#34; 7 binaryMessenger:[registrar messenger]]; 8 BattlePowerPlugin* instance = [[BattlePowerPlugin alloc] init]; 9 [registrar addMethodCallDelegate:instance channel:channel]; 10} 11 12- (void)handleMethodCall:(FlutterMethodCall*)call result:(FlutterResult)result { 13 if ([@\u0026#34;getPlatformVersion\u0026#34; isEqualToString:call.method]) { 14 result([@\u0026#34;iOS \u0026#34; stringByAppendingString:[[UIDevice currentDevice] systemVersion]]); 15 } if([@\u0026#34;add\u0026#34; isEqualToString:call.method]){ 16 NSDictionary *args = call.arguments; 17 int x = [[args valueForKey:@\u0026#34;x\u0026#34;] intValue]; 18 int y = [[args valueForKey:@\u0026#34;y\u0026#34;] intValue]; 19 NSNumber *sum = [NSNumber numberWithLong:(x+y)]; 20 result(sum); 21 }else { 22 result(FlutterMethodNotImplemented); 23 } 24} 25 26@end 这里参考文档可知\n我传入的参数在 dart 端会被解析为Map ,到了 oc 中会变成NSDictionary,然后通过 key 获取到对应的值\n\u0008 接着将 x y 相加后传为NSNumber传回 dart 即可\n这样一个简单的插件交互方法就完成了\n这里是 dart =\u0026gt; oc 的传递\n如果你是对于 oc 如何通知 dart 请看第四篇\n","link":"https://kikt.top/posts/flutter/channel/flutter-channel3/","section":"posts","tags":["channel","flutter","iOS"],"title":"Flutter 原生通信 (三) - Flutter 调用 iOS"},{"body":"原生通信系列\n第二篇介绍的是原生通知 dart\n开篇就是灵魂流程图,自己体会吧 😆 不同于第一篇, 本篇是由 java 端作为发布端, dart 作为订阅端\n具体的创建过程请参考第一篇\njava 先看看 java 端代码\n1package com.example.battlepower; 2 3import java.util.Timer; 4import java.util.TimerTask; 5 6import io.flutter.plugin.common.BasicMessageChannel; 7import io.flutter.plugin.common.MethodCall; 8import io.flutter.plugin.common.MethodChannel; 9import io.flutter.plugin.common.MethodChannel.MethodCallHandler; 10import io.flutter.plugin.common.MethodChannel.Result; 11import io.flutter.plugin.common.PluginRegistry.Registrar; 12import io.flutter.plugin.common.StandardMessageCodec; 13 14/** 15 * BattlePowerPlugin 16 */ 17public class BattlePowerPlugin implements MethodCallHandler { 18 19 private static BasicMessageChannel\u0026lt;Object\u0026gt; runTimeSender; 20 21 private static Timer timer; 22 23 private static long startTime; 24 25 /** 26 * Plugin registration. 27 */ 28 public static void registerWith(Registrar registrar) { 29 final MethodChannel channel = new MethodChannel(registrar.messenger(), \u0026#34;battle_power\u0026#34;); 30 BattlePowerPlugin handler = new BattlePowerPlugin(); 31 channel.setMethodCallHandler(handler); 32 33 runTimeSender = new BasicMessageChannel\u0026lt;\u0026gt;(registrar.messenger(), \u0026#34;run_time\u0026#34;, new StandardMessageCodec()); 34 startTime = System.currentTimeMillis(); 35 } 36 37 public static void startTimeSender() { 38 if (timer != null) { 39 timer.cancel(); 40 } else { 41 timer = new Timer(); 42 } 43 44 timer.schedule(new TimerTask() { 45 @Override 46 public void run() { 47 if (runTimeSender != null) { 48 runTimeSender.send(System.currentTimeMillis() - startTime); 49 } 50 } 51 }, 5000, 5000); 52 } 53 54 public static void cancelTimer() { 55 timer.cancel(); 56 } 57 58 // ... 59} 这里创建BasicMessageChannel类来负责传递消息\n1runTimeSender = new BasicMessageChannel\u0026lt;\u0026gt;(registrar.messenger(), \u0026#34;run_time\u0026#34;, new StandardMessageCodec()); 第一个可以视为固定参数 \u001b,略过不表, 第二个是插件名,需要全应用唯一,第三个是编解码器,如果你看过第一篇,则应该知道了\n这个主要功能大概能看懂,就是间隔 5 秒发送一个广播, 广播这个插件的运行时间\ndart 1 static const BasicMessageChannel\u0026lt;dynamic\u0026gt; runTimer = const BasicMessageChannel(\u0026#34;run_time\u0026#34;, StandardMessageCodec()); 2 3 static void initMessageHandler() { 4 runTimer.setMessageHandler((double value) { 5 // 接收到的时间 6 int time = value; 7 print(\u0026#34;value = $time\u0026#34;); 8 }); 9 } 这里定义后,就可以从原生端接收到时间了,间隔 5 秒接收一个时间\n这里可以看到,dart 端成功的接收到了从原生端发来的消息\n通过了两篇 blog 的讲解,flutter \u0026lt;=\u0026gt; android 端的双向通信机制基本都说到了\n后面还有 iOS 篇,也是插件开发的必备技能\n","link":"https://kikt.top/posts/flutter/channel/flutter-channel2/","section":"posts","tags":["channel","flutter","android"],"title":"Flutter 原生通信 (二) - Android通知Flutter"},{"body":"原生通信系列\n在 flutter 开发中一定会有需要和原生通信的情况\n第一篇介绍的是 flutter 调用 Android\n这篇是给刚刚入门或者刚刚接触原生调用的朋友们使用的,老鸟们或者英文强的朋友还是直接看官方文档比较好\n创建项目 一般来说建议使用一个 plugin 作为一个单独的项目来将业务逻辑独立出去\n我这里使用命令行创建,事实上一律建议使用命令行创建,因为信息更加可见一些\n1flutter create --template plugin battle_power 2cd battle_power 前面都是固定格式,最后面那个是插件名,根据你自己的需要来修改\n创建好的截图如下 和开发 package 的时候不同,开发 plugin 需要打开 example/android 目录\n使用快捷的方式,或自己通过 Android Studio 的 open 打开项目\n等待完成\n接着就可以开始开发了,\n默认生成了一个 java 文件,可以称之为插件的主文件\n流程图 乱画的..随便看看就好\nandroid 端 1package com.example.battlepower; 2 3import io.flutter.plugin.common.MethodCall; 4import io.flutter.plugin.common.MethodChannel; 5import io.flutter.plugin.common.MethodChannel.MethodCallHandler; 6import io.flutter.plugin.common.MethodChannel.Result; 7import io.flutter.plugin.common.PluginRegistry.Registrar; 8 9/** BattlePowerPlugin */ 10public class BattlePowerPlugin implements MethodCallHandler { 11 /** Plugin registration. */ 12 public static void registerWith(Registrar registrar) { 13 final MethodChannel channel = new MethodChannel(registrar.messenger(), \u0026#34;battle_power\u0026#34;); //这里对应dart端的 MethodChannel 14 channel.setMethodCallHandler(new BattlePowerPlugin()); 15 } 16 17 @Override 18 public void onMethodCall(MethodCall call, Result result) { 19 if (call.method.equals(\u0026#34;getPlatformVersion\u0026#34;)) { // 对应dart端 invoceMethod 20 result.success(\u0026#34;Android \u0026#34; + android.os.Build.VERSION.RELEASE); 21 } else { 22 result.notImplemented(); 23 } 24 } 25} 当然如果你对于 kotlin 比较喜欢也可以使用 kotlin 进行插件开发\n如果你不会 Java/Kotlin ,甚至不会原生开发,只能说你进入了一个全新的领域,希望你一切都好吧...,建议你先系统的学习下 android 再来\ndart 端 1import \u0026#39;dart:async\u0026#39;; 2 3import \u0026#39;package:flutter/services.dart\u0026#39;; 4 5class BattlePower { 6 static const MethodChannel _channel = 7 const MethodChannel(\u0026#39;battle_power\u0026#39;); 8 9 static Future\u0026lt;String\u0026gt; get platformVersion async { 10 final String version = await _channel.invokeMethod(\u0026#39;getPlatformVersion\u0026#39;); 11 return version; 12 } 13} dart 端和 java 端是一一对应的\n交互 调用 由 dart 端使用_channel.invokeMethod调用,这个方法的参数是方法名和一个可选参数\n返回值是一个Future\u0026lt;dynamic\u0026gt; 因为 java 端的调用是不可预知的,所以是异步的\n换句话说,无论结果是对是错你在 java 端都需要有返回值,否则 dart 端会挂起\n查看 java 端\n可选参数 可选参数是 dart 中的一个语法特点,方法的签名中通过[]包裹的为匿名可选参数,通过{}包裹的为命名可选参数\n而 channel 中的这个方法的完整实现如下\n结果返回 查看\n不同于传统的同步方法调用,java 端需要使用result.success(object)来返回一个结果给 dart\n使用result.notImplemented();来表示未定义的方法,dart 端会接收到一个异常\n返回一个错误result.error(String code,String msg,Throwable throwable)\n调用过程分析 1 Future\u0026lt;dynamic\u0026gt; invokeMethod(String method, [dynamic arguments]) async { 2 assert(method != null); 3 final dynamic result = await BinaryMessages.send( 4 name, 5 codec.encodeMethodCall(MethodCall(method, arguments)), 6 ); 7 if (result == null) 8 throw MissingPluginException(\u0026#39;No implementation found for method $method on channel $name\u0026#39;); 9 return codec.decodeEnvelope(result); 10 } method 是必填参数, 这个和 java 端的监听一一对应\n第二个是一个可选一个参数,这个参数可传递任意参数,但只能有一个,然后会通过内部的 codec 进行编码后传递给 native 端,这个 codec 对象是创建MethodChannel时创建的 有一个默认类型为StandardMethodCodec,这个类型后面会解析,先略过\n1 public static void registerWith(Registrar registrar) { 2 final MethodChannel channel = new MethodChannel(registrar.messenger(), \u0026#34;battle_power\u0026#34;); 3 channel.setMethodCallHandler(new BattlePowerPlugin()); 4 } 在 java 端使用这类代码来注册插件\n1 2 @Override 3 public void onMethodCall(MethodCall call, Result result) { 4 if (call.method.equals(\u0026#34;getPlatformVersion\u0026#34;)) { 5 result.success(\u0026#34;Android \u0026#34; + android.os.Build.VERSION.RELEASE); 6 } else { 7 result.notImplemented(); 8 } 9 } 这里的代码是用来监听回调的,当 dart 调用invokeMethod这里会被触发\n比如getPlatformVersion是一个没有传参数的方法, 直接返回了 Android os 对应的版本号\n这样 dart 在 java 端result.success调用后就会 返回版本号\nStandardMethodCodec 解析 这个类也是在两端都有的一个类, 通常来说就是作为发送端负责编码, 作为接受端负责解码\n作为一个内置类,其中做了一些\u0026quot;自动\u0026quot;的转码过程,将原生类型映射为 dart 类型 或者反过来映射\n查看\n这里代表了基础的映射关系 也就是说 你在 \u0008invokeMethod 时,参数会被映射为右边的原生类型 如果这里没有的类型就是不支持的类型,建议不要使用,否则会抛出无法解码的异常\n当然有正向映射,也会有对应的反向映射,也就是说, 你在 java 中作为结果返回的类型在 dart 端也会被映射为 dart 对应类型\n当然这个编解码器也可以自定义,基于二进制扩展即可,不过这个不属于基础的应用篇,暂时先不做\n自定义 前面是自动生成的方法和签名\n现在自己添加一个带参数的方法\ndart\n1 static Future\u0026lt;int\u0026gt; requestNativeAdd(int x, int y) async { 2 int result = await _channel.invokeMethod(\u0026#39;add\u0026#39;, {\u0026#34;x\u0026#34;: x, \u0026#34;y\u0026#34;: y}); 3 return result; 4 } java\n1 @Override 2 public void onMethodCall(MethodCall call, Result result) { 3 switch (call.method) { 4 case \u0026#34;getPlatformVersion\u0026#34;: 5 result.success(\u0026#34;Android \u0026#34; + android.os.Build.VERSION.RELEASE); 6 break; 7 case \u0026#34;add\u0026#34;: 8 Integer x = call.argument(\u0026#34;x\u0026#34;); 9 Integer y = call.argument(\u0026#34;y\u0026#34;); 10 if (x != null \u0026amp;\u0026amp; y != null) { 11 result.success(x + y); 12 } else { 13 result.error(\u0026#34;1\u0026#34;, \u0026#34;不能为空\u0026#34;, null); 14 } 15 break; 16 default: 17 result.notImplemented(); 18 break; 19 } 20 } 方法很简单,传入一个 x 一个 y,然后 java 端加完返回回来\n这样一个简单的自定义就完成了\n你以为就这样结束了?\n请看第二篇 ","link":"https://kikt.top/posts/flutter/channel/flutter-channel1/","section":"posts","tags":["channel","flutter","android"],"title":"Flutter 原生通信 (一) - flutter调用Android"},{"body":"pub 库\n项目名: 项目地址: 简介: 图片压缩\n项目名: 项目地址: 项目简介: 仿 android toast 纯 flutter 实现\n项目名: 项目地址: 项目简介: 读取系统相册 纯 api 版 支持(ios/android)\n项目名: 项目地址: 项目简介: 相册图片选择器 基于 photo_manager\n项目名: 项目地址: 项目简介: ListView 的加载更多\n项目名: 项目地址: 项目简介: 配合 pageview 的简单圆点指示器\n项目名: 项目地址: 项目简介: 城市选择器\n项目名: 项目地址: 项目简介: 一个长按弹出菜单的小部件\n项目名: 项目地址: 项目简介: 日志插件,用于帮助将 flutter 上的日志记录至开发机\n如果用过的朋友觉得好用,请在遇到别人想用的时候帮忙感谢宣传\n","link":"https://kikt.top/posts/flutter/flutter-self-library/","section":"posts","tags":["flutter","library","pub","github"],"title":"Flutter 本人开发的一些开源库"},{"body":"","link":"https://kikt.top/tags/library/","section":"tags","tags":null,"title":"library"},{"body":"本人技术栈 Flutter: 主修 + 吃饭之物，Since 2018 Android: 对于 java/kotlin/android 较为熟练，但是已经有几年没有做纯原生开发了。 Gradle: 可以熟练使用 iOS: swift/oc 有所了解,可以开发常见的原生 ios 应用 Java/Kotlin: spring boot, jpa, mybatis, redis 等等，可以做常见的后端开发（业务堆砌工程师） 数据库: mysql/sqlite/postgreSQL 等常见的 sql 语句可运用 python: 一些常见脚本, 爬虫, 可以做 API 调用工程师 web: ts/js/react/rn/小程序，可以做常见需求 shell: 写一些简单的脚本，不求甚解 golang: 初步入门，会用看得懂即可 运维相关: docker/docker-compress 了解、会用 本站使用工具 静态工具: hugo\n主题: Clarity, 是 fork 自定制版, 添加了视频播放的简单支持\n文章: markdown\n建站过程 早先很久开始在 新浪 csdn 都写过技术博客\n后来，简书的 markdown 很友好，所以将博客迁移至简书\n然而因简书强行要求绑定微信号，我不想给，加上简书对于开发者不是友好的网站，故决定迁移出简书\n在经过了掘金,回归 csdn,博客园的一番折腾后,无奈还是打算自己建一个 blog，不是说思否、掘金不好，而是限制还是较多，故而自行建站是唯一的选择\n建站 目前使用 hugo + github pages 搭建\nhugo 是一个静态网站生成器,可以使用 markdown 语法编写文章\n然后通过主题\n","link":"https://kikt.top/about/","section":"","tags":null,"title":"关于"},{"body":"在搜索引擎中,搜索了一下如何部署一个 go 的程序, 发现都是基于 golang 的镜像部署 go 源码的方案\n而基于 golang 源码部署 docker image 的大小有 700MB, 有时候并不需要这么大,我们生成二进制文件后 只需要基于 centos 来制作 image 就可以了, 当然如果对于 go 源码有持续部署的需求,那还是只能使用 golang 镜像\n目录结构 完整的目录结构就这么简单, main 是二进制运行文件\nmain.go 1package main 2 3import \u0026#34;github.com/gin-gonic/gin\u0026#34; 4 5func main() { 6 g := gin.Default() 7 8 g.LoadHTMLGlob(\u0026#34;static/*\u0026#34;) 9 10 g.GET(\u0026#34;/index\u0026#34;, func(c *gin.Context) { 11 c.HTML(200, \u0026#34;index.html\u0026#34;, gin.H{ 12 \u0026#34;title\u0026#34;: \u0026#34;标题\u0026#34;, 13 }) 14 }) 15 16 g.Run(\u0026#34;:80\u0026#34;) 17} 打包 go 二进制运行文件 这里因为我是 mac 系统,所以我需要交叉编译,具体的交叉编译可以查看我的\n1cd main 2 3CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build main.go 制作镜像 Dockerfile 1FROM centos:latest 2 3LABEL cjl \u0026#34;cjl_spy@163.com\u0026#34; 4 5WORKDIR /root 6 7ADD ./main ./main 8ADD ./static/ ./static/ 9 10EXPOSE 80 11 12ENTRYPOINT [\u0026#34;./main\u0026#34;] FROM 基于 centos\nLABEL 随便写\nWORKDIR 工作目录, 在 docker 中的目录, 直接使用/root 就行了 当然你也可以自己指定\nADD [源文件] [目标文件]\nEXPOSE 80 端口号是多少,这里设置 80 ,因为我的程序中写的是 80\nENTRYPOINT [\u0026quot;./main\u0026quot;] 这个是在运行容器时会执行的命令, 因为假设我在 centos 中 我开启这服务只需要./main 就够了\n打包镜像 在 main 目录下执行\n1 docker build -t dockertest . 接着就会根据 Dockerfile 的内容进行打包,看到 sucessful 就说明成功了\n测试镜像运行 1docker run --name dtest -d -p 8888:80 dockertest 接着访问浏览器\nhttp://localhost:8888/index\n通过 docker-compose 部署 这里需要先移除掉上一个容器,即使不移除也需要先停止运行\n1docker container rm -f dtest 配置 docker-compose.yml\n1version: \u0026#34;3\u0026#34; 2services: 3 go-web: 4 image: dockertest 5 ports: 6 - \u0026#34;8888:80\u0026#34; 这里就完成了配置\n然后执行 docker-compose up -d\n接着在浏览器输入 http://localhost:8888/index 还是和上一步一样,这样就完成了带静态资源的服务器完整部署\n结语 越学习 docker 就越觉得 docker 的部署方案真的太方便了,即使只是自己使用云服务器搭设一个博客也应该好好学习\n","link":"https://kikt.top/posts/docker/docker-delop-bin-file/","section":"posts","tags":["docker","二进制"],"title":"Docker 部署二进制"},{"body":"","link":"https://kikt.top/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/","section":"tags","tags":null,"title":"二进制"},{"body":"","link":"https://kikt.top/tags/docker-compose/","section":"tags","tags":null,"title":"docker-compose"},{"body":"开发环境 mac zsh docker-compose\n1$ docker-compose --version 2docker-compose version 1.22.0, build f46880f 目录结构 docker-compose.yml 1version: \u0026#34;3\u0026#34; 2services: 3 web: # 服务的名称 4 image: nginx 5 volumes: # 文件夹映射 6 - /Users/cai/Documents/www:/usr/share/nginx/html:ro # 宿主:docker:只读 ,www目录 7 - ./config/web.conf:/etc/nginx/nginx.conf:ro # nginx配置文件 8 ports: # 端口转发 宿主:docker 9 - \u0026#34;8080:80\u0026#34; 10 - \u0026#34;8081:81\u0026#34; 11 # environment: 12 # - NGINX_HOST=foobar.com 13 # - NGINX_PORT=80 14 # command: /bin/bash -c \u0026#34;envsubst \u0026lt; /etc/nginx/conf.d/mysite.template \u0026gt; /etc/nginx/conf.d/default.conf \u0026amp;\u0026amp; exec nginx -g \u0026#39;daemon off;\u0026#39;\u0026#34; 15 networks: ## 定义网络 16 nn: ## 加入的网络的名称 17 ipv4_address: 192.168.5.101 ## ipv4的ip地址 18 19 web8082: 20 image: nginx 21 volumes: 22 - /Users/cai/Documents/www/8082:/usr/share/nginx/html:ro 23 ports: 24 - \u0026#34;8082:80\u0026#34; 25 26 networks: 27 nn: 28 ipv4_address: 192.168.5.102 29 30 web8083: 31 image: nginx 32 volumes: 33 - /Users/cai/Documents/www/8083:/usr/share/nginx/html:ro 34 ports: 35 - \u0026#34;8083:80\u0026#34; 36 37 networks: 38 nn: 39 ipv4_address: 192.168.5.103 40 41networks: ##定义网络组 42 nn: ## 网络组名称 43 driver: bridge ## 网络的模式 44 ipam: ## 配置网络 45 driver: default 46 config: 47 - subnet: 192.168.5.0/24 ## ip地址网络 这里宿主机一般会是该网段的 192.168.5.1,所以不要设置自网段为1 配置服务 配置网络\n将服务加入同一个网络组,这样 docker 就可以在同一个网络组里了,由于 docker 的特性,每个容器会认为自己和另一个容器是局域网的关系\n我这里做的是 nginx 转发\nnginx.conf 1user nginx; 2worker_processes 1; 3 4error_log /var/log/nginx/error.log warn; 5pid /var/run/nginx.pid; 6 7 8events { 9 worker_connections 1024; 10} 11 12 13http { 14 include /etc/nginx/mime.types; 15 default_type application/octet-stream; 16 17 log_format main \u0026#39;$remote_addr - $remote_user [$time_local] \u0026#34;$request\u0026#34; \u0026#39; 18 \u0026#39;$status $body_bytes_sent \u0026#34;$http_referer\u0026#34; \u0026#39; 19 \u0026#39;\u0026#34;$http_user_agent\u0026#34; \u0026#34;$http_x_forwarded_for\u0026#34;\u0026#39;; 20 21 access_log /var/log/nginx/access.log main; 22 23 sendfile on; 24 #tcp_nopush on; 25 26 keepalive_timeout 65; 27 28 #gzip on; 29 30 # include /etc/nginx/conf.d/*.conf; 31 32 33 server { 34 listen 80; 35 server_name localhost; 36 37 #charset koi8-r; 38 #access_log /var/log/nginx/host.access.log main; 39 40 location / { 41 root /usr/share/nginx/html; 42 index index.html index.htm; 43 # proxy_pass http://web8081; 44 } 45 46 error_page 500 502 503 504 /50x.html; 47 location = /50x.html { 48 root /usr/share/nginx/html; 49 } 50 51 location = /300.html { 52 proxy_redirect off; 53 proxy_pass http://192.168.5.102/index.html; ## 备注1 54 } 55 56 location = /600.html { 57 proxy_redirect off; 58 proxy_pass http://192.168.5.103/index.html; ## 备注2 59 } 60 } 61 62 server{ 63 listen 81; 64 server_name localhost; 65 66 location / { 67 root /usr/share/nginx/html/sub; 68 index index.html index.htm; 69 } 70 } 71} 备注 1,备注 2 将 300.html 600.html 转发到 103 的 ip 地址 由于 docker 中 nginx 端口默认配置的是 80,所以 http 的端口转发没有端口号 8082 端口 对于 8080 端口默认服务器来讲 ip 地址是 102\n启动 1docker up 加 -d 的话就是后台运行, 直接运行可以看见日志\n这里测试了一下 可以看到 服务器那边有日志 我们发的请求 8082 的服务器给出了反馈\n后记 这里简单记录了下 docker 配合 nginx 达到两个隔离容器间的通信问题\n同样的 这里如果用 mysql+服务器 app 程序 也可以达成通信的原理,无非就是换个 ip 地址和通过命令启动服务端程序的问题\n","link":"https://kikt.top/posts/docker/docker-compose-and-nginx-forward/","section":"posts","tags":["docker","nginx","docker-compose"],"title":"Docker-Compose 结合nginx实现跨容器转发"},{"body":"","link":"https://kikt.top/tags/nginx/","section":"tags","tags":null,"title":"nginx"},{"body":"\nflutter 中 如果给图片外面套 InkWell ,你会发现点击的逻辑生效了,但是 UI 上没反应\n备注: , 违反版权请联系我,删除\n代码如下\n1import \u0026#39;package:flutter/material.dart\u0026#39;; 2 3class ImageTapWidget extends StatefulWidget { 4 final Widget child; 5 final Function onTap; 6 7 const ImageTapWidget({Key key, this.child, this.onTap}) : super(key: key); 8 9 @override 10 ImageTapWidgetState createState() { 11 return new ImageTapWidgetState(); 12 } 13} 14 15class ImageTapWidgetState extends State\u0026lt;ImageTapWidget\u0026gt; { 16 var isDown = false; 17 @override 18 Widget build(BuildContext context) { 19 return GestureDetector( 20 child: AnimatedContainer( 21 duration: Duration(milliseconds: 500), 22 foregroundDecoration: BoxDecoration( 23 color: isDown ? Colors.white.withOpacity(0.5) : Colors.transparent, 24 ), 25 child: widget.child, 26 ), 27 onTap: widget.onTap, 28 onTapDown: (d) =\u0026gt; setState(() =\u0026gt; this.isDown = true), 29 onTapUp: (d) =\u0026gt; setState(() =\u0026gt; this.isDown = false), 30 onTapCancel: () =\u0026gt; setState(() =\u0026gt; this.isDown = false), 31 ); 32 } 33} 利用 Container 的前景色完成点击色的变化\n利用 AnimatedContainer 完成颜色的过度\n这样就完成了一个有点击效果的控件,当然这个控件的效果不止于对图片有效,对所有的控件都有效,但是正常来说我对于其他类型的控件应该不需要做这个操作\n点击效果过快 当然,有的时候你会遇到点击和松开之间过快,造成了视觉上没点击的感觉,这种情况下可以使用另一种方法,利用动画的方式来实现\n1import \u0026#39;package:flutter/material.dart\u0026#39;; 2 3class ImageTapWidget extends StatefulWidget { 4 final Widget child; 5 final Function onTap; 6 7 const ImageTapWidget({Key key, this.child, this.onTap}) : super(key: key); 8 9 @override 10 ImageTapWidgetState createState() { 11 return new ImageTapWidgetState(); 12 } 13} 14 15class ImageTapWidgetState extends State\u0026lt;ImageTapWidget\u0026gt; with SingleTickerProviderStateMixin { 16 AnimationController _ctl; 17 18 @override 19 void initState() { 20 super.initState(); 21 _ctl = AnimationController(vsync: this, duration: Duration(milliseconds: 200)); 22 } 23 24 @override 25 void dispose() { 26 _ctl.stop(); 27 _ctl.dispose(); 28 super.dispose(); 29 } 30 31 @override 32 Widget build(BuildContext context) { 33 return GestureDetector( 34 child: AnimatedBuilder( 35 animation: _ctl, 36 builder: (BuildContext context, Widget child) { 37 return Container( 38 foregroundDecoration: BoxDecoration( 39 color: Colors.white.withOpacity(0.5 * _ctl.value), 40 ), 41 child: widget.child, 42 ); 43 }, 44 ), 45 onTap: widget.onTap, 46 onTapDown: (d) =\u0026gt; _ctl.forward(), 47 onTapUp: (d) =\u0026gt; prepareToIdle(), 48 onTapCancel: () =\u0026gt; prepareToIdle(), 49 ); 50 } 51 52 void prepareToIdle() { 53 AnimationStatusListener listener; 54 listener = (AnimationStatus statue) { 55 if (statue == AnimationStatus.completed) { 56 _ctl.removeStatusListener(listener); 57 toStart(); 58 } 59 }; 60 _ctl.addStatusListener(listener); 61 if (!_ctl.isAnimating) { 62 _ctl.removeStatusListener(listener); 63 toStart(); 64 } 65 } 66 67 void toStart() { 68 _ctl.stop(); 69 _ctl.reverse(); 70 } 71} 创建一个AnimationBuilder结合 AnimationController 来实现\n在按下的时候执行动画, 然后在抬起或取消的时候也先不结束动画,而是监听动画状态,等待动画完成再执行动画效果上的取消动画\n后记 点击效果相关的简单实现就在这里了,有不明白的可以留言哦\n","link":"https://kikt.top/posts/flutter/flutter-click-event-2/","section":"posts","tags":["flutter","点击","tap"],"title":"flutter - 点击事件(二) - 给图片增加点击UI效果"},{"body":"","link":"https://kikt.top/tags/tap/","section":"tags","tags":null,"title":"tap"},{"body":"","link":"https://kikt.top/tags/%E7%82%B9%E5%87%BB/","section":"tags","tags":null,"title":"点击"},{"body":"点击事件 android 中,所有 View 都可以直接 setOnClickListener, RN 中也有 TouchableHightlight 这样的控件可以直接套在外面,ios 中也可以有 UIControl 这样的控件可以直接添加点击事件.\n那么 flutter 中有吗? 答案自然是有. GestureDetector,InkResponse,InkWell, 包括一些琳琅满目的按钮,比如 FlatButton,MaterialButton,CupertinoButton,IconButton,ImageButton 这些组件都可以达到目的. 那么自定义的目的是什么呢?\n自定义的优点 最重要的自然就是可控性强,复用性强. 一次修改终身受用. 来看下面的这段代码\n1import \u0026#39;package:flutter/material.dart\u0026#39;; 2 3class MaterialTapWidget extends StatelessWidget { 4 final double radius; 5 final Function onTap; 6 final Widget child; 7 final double elevation; 8 final Color backgroundColor; 9 final Color splashColor; 10 final Function onLongTap; 11 12 const MaterialTapWidget({ 13 Key key, 14 this.radius = 0.0, 15 this.onTap, 16 this.onLongTap, 17 @required this.child, 18 this.splashColor, 19 this.elevation = 0.0, 20 this.backgroundColor = Colors.transparent, 21 }) : super(key: key); 22 23 @override 24 Widget build(BuildContext context) { 25 Widget w = ClipRRect( 26 borderRadius: BorderRadius.circular(radius), 27 child: Material( 28 borderRadius: BorderRadius.circular(radius), 29 color: backgroundColor, 30 elevation: 0.0, 31 child: InkWell( 32 child: child, 33 onTap: onTap, 34 onLongPress: onLongTap, 35 ), 36 ), 37 ); 38 39 if (this.splashColor != null) { 40 return Theme( 41 data: Theme.of(context).copyWith(splashColor: this.splashColor), 42 child: w, 43 ); 44 } 45 46 return w; 47 } 48} 一共有下面几个属性\n1 final double radius; //圆角 2 final Function onTap; //点击回调 3 final Widget child; // 内部的控件 4 final double elevation; //阴影\u0026#34;高度\u0026#34; 5 final Color backgroundColor; //背景颜色 6 final Color splashColor; // 点击的水波纹颜色 7 final Function onLongTap; //长按回调 这个在日常开发中可以满足我的需求了,但是有一天我还需要单独设置其他的呢 比如我需要添加双击事件,那么我只需要修改几处地方\n1class MaterialTapWidget extends StatelessWidget { 2 final double radius; 3 final Function onTap; 4 final Widget child; 5 final double elevation; 6 final Color backgroundColor; 7 final Color splashColor; 8 final Function onLongTap; 9 final Function onDoubleTap; //添加字段 10 11 const MaterialTapWidget({ 12 Key key, 13 this.radius = 0.0, 14 this.onTap, 15 this.onLongTap, 16 @required this.child, 17 this.splashColor, 18 this.elevation = 0.0, 19 this.backgroundColor = Colors.transparent, 20 this.onDoubleTap, //添加构造方法 21 }) : super(key: key); 22 23 @override 24 Widget build(BuildContext context) { 25 Widget w = ClipRRect( 26 borderRadius: BorderRadius.circular(radius), 27 child: Material( 28 borderRadius: BorderRadius.circular(radius), 29 color: backgroundColor, 30 elevation: 0.0, 31 child: InkWell( 32 child: child, 33 onTap: onTap, 34 onDoubleTap: onDoubleTap, //添加控件回调 35 onLongPress: onLongTap, 36 ), 37 ), 38 ); 39 40 if (this.splashColor != null) { 41 return Theme( 42 data: Theme.of(context).copyWith(splashColor: this.splashColor), 43 child: w, 44 ); 45 } 46 47 return w; 48 } 49} 这样就完成了双击的支持, 同样的,如果有别的需求也可以往这里放\n比如我们有了特殊需求,希望如果设备是 ios 设备,则不使用 Material 风格,而使用一个点击背景变色的风格\n在整体项目是使用 MaterialApp 的情况下,可以像下面这样写\n1import \u0026#39;package:flutter/material.dart\u0026#39;; 2 3class PlatformTapWidget extends StatefulWidget { 4 final double radius; 5 final Function onTap; 6 final Widget child; 7 final double elevation; 8 final Color backgroundColor; 9 final Color splashColor; 10 final Function onLongTap; 11 12 const PlatformTapWidget({ 13 Key key, 14 this.radius = 0.0, 15 this.onTap, 16 this.elevation, 17 this.backgroundColor = Colors.white, 18 this.splashColor, 19 this.onLongTap, 20 this.child, 21 }) : super(key: key); 22 23 @override 24 _PlatformTapWidgetState createState() =\u0026gt; _PlatformTapWidgetState(); 25} 26 27class _PlatformTapWidgetState extends State\u0026lt;PlatformTapWidget\u0026gt; { 28 bool isDown = false; 29 30 @override 31 Widget build(BuildContext context) { 32 Color splashColor = widget.splashColor ?? Colors.grey.withOpacity(0.3); 33 34 if (Theme.of(context).platform == TargetPlatform.iOS) { 35 Widget w; 36 37 w = ClipRRect( 38 borderRadius: BorderRadius.circular(widget.radius), 39 child: GestureDetector( 40 behavior: HitTestBehavior.translucent, 41 onTap: widget.onTap, 42 onTapDown: (d) =\u0026gt; setState(() =\u0026gt; this.isDown = true), 43 onTapUp: (d) =\u0026gt; setState(() =\u0026gt; this.isDown = false), 44 onTapCancel: () =\u0026gt; setState(() =\u0026gt; this.isDown = false), 45 child: AnimatedContainer( 46 duration: Duration(milliseconds: 600), 47 curve: Curves.easeIn, 48 color: isDown ? splashColor : widget.backgroundColor, 49 child: widget.child, 50 ), 51 ), 52 ); 53 54 return w; 55 } 56 57 Widget w = ClipRRect( 58 borderRadius: BorderRadius.circular(widget.radius), 59 child: Material( 60 borderRadius: BorderRadius.circular(widget.radius), 61 color: widget.backgroundColor, 62 elevation: 0.0, 63 child: InkWell( 64 child: widget.child, 65 onTap: widget.onTap, 66 onLongPress: widget.onLongTap, 67 ), 68 ), 69 ); 70 71 if (widget.splashColor != null) { 72 return Theme( 73 data: Theme.of(context).copyWith(splashColor: widget.splashColor), 74 child: w, 75 ); 76 } 77 78 return w; 79 } 80} 这样就可以达到 ios 设备和 android 设备不同的方法 而这个也很符合 flutter 的设计理念, 组合优于继承 ,使用 flutter 自带的组件 通过组合的方式构建出自己的组件\nflutter 中可以有很多这样的组合方式\n比如我项目中有大量左图片,右文字的按钮,并且按钮的图片大小是固定的,字体大小也固定,并且附带圆角 那么这种情况下可以自己封装一个控件\n1import \u0026#39;package:flutter/material.dart\u0026#39;; 2import \u0026#39;package:platform_widget_demo/widgets/platform_tap_widget.dart\u0026#39;; 3 4class IconTextButton extends StatelessWidget { 5 final IconData icon; 6 final String text; 7 final Function onTap; 8 9 const IconTextButton({ 10 Key key, 11 this.icon, 12 this.text, 13 this.onTap, 14 }) : super(key: key); 15 16 @override 17 Widget build(BuildContext context) { 18 return PlatformTapWidget( 19 onTap: onTap, 20 child: Row( 21 children: \u0026lt;Widget\u0026gt;[ 22 Icon(icon), 23 Text(text), 24 ], 25 ), 26 ); 27 } 28} 1 IconTextButton( 2 icon: Icons.scanner, 3 text: \u0026#34;扫描\u0026#34;, 4 ), ","link":"https://kikt.top/posts/flutter/flutter-click-event-1/","section":"posts","tags":["flutter","点击","tap"],"title":"flutter - 点击事件(一) - 自定义一个方便的点击控件"},{"body":"转自 Golang 支持交叉编译，在一个平台上生成另一个平台的可执行程序，最近使用了一下，非常好用，这里备忘一下。\nMac 下编译 Linux 和 Windows 64 位可执行程序\n1CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build main.go 2CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build main.go Linux 下编译 Mac 和 Windows 64 位可执行程序\n1CGO_ENABLED=0 GOOS=darwin GOARCH=amd64 go build main.go 2CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build main.go Windows 下编译 Mac 和 Linux 64 位可执行程序\n1SET CGO_ENABLED=0 2SET GOOS=darwin 3SET GOARCH=amd64 4go build main.go 5 6SET CGO_ENABLED=0 7SET GOOS=linux 8SET GOARCH=amd64 9go build main.go GOOS：目标平台的操作系统（darwin、freebsd、linux、windows） GOARCH：目标平台的体系架构（386、amd64、arm） 交叉编译不支持 CGO 所以要禁用它\n上面的命令编译 64 位可执行程序，你当然应该也会使用 386 编译 32 位可执行程序 很多博客都提到要先增加对其它平台的支持，但是我跳过那一步，上面所列的命令也都能成功，且得到我想要的结果，可见那一步应该是非必须的，或是我所使用的 Go 版本已默认支持所有平台。\n","link":"https://kikt.top/posts/go/cross-compilation/","section":"posts","tags":["交叉","编译","golang"],"title":"【转】Golang 在 Mac、Linux、Windows 下如何交叉编译"},{"body":"","link":"https://kikt.top/tags/golang/","section":"tags","tags":null,"title":"golang"},{"body":"","link":"https://kikt.top/categories/golang/","section":"categories","tags":null,"title":"golang"},{"body":"","link":"https://kikt.top/tags/%E4%BA%A4%E5%8F%89/","section":"tags","tags":null,"title":"交叉"},{"body":"","link":"https://kikt.top/tags/%E7%BC%96%E8%AF%91/","section":"tags","tags":null,"title":"编译"},{"body":"简单翻译 英文链接来自于\n对应的版本为 11 月 11 日版本 连接为 后续如有改动,请以最新的英文版本为准,有翻译不准确的地方请参照英文版本自行理解\n概述 本文档描述了 Flutter 工具包的内部工作原理，使 Flutter 的 API 成为可能。因为 Flutter 小部件是使用积极的可组合性(aggressive composition)构建的，所以使用 Flutter 构建的用户界面具有大量小部件。\n为了支持这种工作量，Flutter 使用次线性算法来布局和构建小部件，这些数据结构使树形手术变得高效，并且具有许多常量因子优化。\n通过一些额外的细节，这种设计还使开发人员可以使用回调来轻松创建无限滚动列表，这些回调可以构建用户可见的小部件。\n积极的可组合性（Aggressive composability） Flutter 最独特的一个方面是其积极的可组合性。\n小部件是通过组合其他小部件构建的，这些小部件本身是由逐步更基本的小部件构建的。例如，Padding 是一个小部件而不是其他小部件的属性。因此，使用 Flutter 构建的用户界面由许多小部件组成。\n小部件构建递归在 RenderObjectWidgets 中触底，这些小部件在底层渲染树中创建节点。渲染树是一种数据结构，用于存储用户界面的几何图形，该几何图形在布局期间计算并在绘制和命中测试期间使用。大多数 Flutter 开发人员不直接创建对象，而是使用小部件操纵渲染树。\n为了在小部件层支持积极的可组合性，Flutter 在小部件和渲染树层使用了许多有效的算法和优化，这些将在以下小节中介绍。\n次线性布局 使用大量小部件和渲染对象，良好性能的关键是高效的算法。最重要的是布局的性能，布局是确定渲染对象的几何（例如，大小和位置）的算法。其他一些工具包使用 O（N²）或更差的布局算法（例如，某些约束域中的定点迭代）。 Flutter 的目标是初始布局的线性性能，以及随后更新现有布局的常见情况下的次线性布局性能。通常，布局所花费的时间量应该比渲染对象的数量更慢。\nFlutter 每帧执行一个布局，布局算法一次完成。约束通过父对象向下传递，父对象在每个子对象上调用布局方法。子项递归地执行自己的布局，然后通过返回布局方法将几何返回到树中。重要的是，一旦渲染对象从其布局方法返回，该渲染对象将不再被访问，直到下一帧的布局。这种方法将可能单独的度量和布局传递组合成单个传递，因此，每个渲染对象在布局期间最多访问两次：一次在树下，一次在树上。\nFlutter 有这个通用协议的几个专业。最常见的专业是 RenderBox，它以二维笛卡尔坐标运算。在框布局中，约束是最小和最大宽度以及最小和最大高度。在布局期间，子项通过选择这些边界内的大小来确定其几何。孩子从布局返回后，父母决定孩子在父母坐标系中的位置。请注意，孩子的布局不能取决于孩子的位置，因为孩子的位置直到孩子从布局返回后才确定。因此，父母可以自由地重新定位孩子，而无需重新计算孩子的布局。\n更一般地说，在布局期间，从父节点传递到子节点的唯一信息是约束，并且从子节点流向父节点的唯一信息是几何体。这些不变量可以减少布局期间所需的工作量：\n如果孩子没有将自己的布局标记为脏，则孩子可以立即从布局返回，切断步行，只要父母给孩子的约束与孩子在前一个布局中收到的约束相同。\n每当父级调用子级的布局方法时，父级指示它是否使用从子级返回的大小信息。如果经常发生父级不使用大小信息，那么如果子级选择新大小，则父级不需要重新计算其布局，因为父级保证新大小将符合现有约束。\n严格约束是指只能通过一个有效几何体来满足的约束。例如，如果最小和最大宽度彼此相等并且最小和最大高度彼此相等，则满足这些约束的唯一尺寸是具有该宽度和高度的尺寸。如果父级提供严格约束，则父级无需在子级重新计算其布局时重新计算其布局，即使父级在其布局中使用子级的大小，因为子级无法在没有父级的新约束的情况下更改大小。\n渲染对象可以声明它仅使用父级提供的约束来确定其几何。这样的声明通知框架该子渲染对象的父级在子级重新计算其布局时不需要重新计算其布局，即使约束不紧，即使父级的布局取决于子级的大小，因为子级无法更改大小没有来自其父级的新约束。\n作为这些优化的结果，当渲染对象树包含脏节点时，在布局期间仅访问那些节点以及它们周围的子树的有限部分。\n次线性小部件构建 与布局算法类似，Flutter 的小部件构建算法是次线性的。构建之后，小部件由元素树保存，元素树保留用户界面的逻辑结构。元素树是必要的，因为小部件本身是不可变的，这意味着（除其他外），它们不能记住它们与其他小部件的父或子关系。元素树还包含与有状态窗口小部件关联的状态对象。\n响应于用户输入（或其他刺激），元素可能变脏，例如，如果开发人员在关联的状态对象上调用 setState（）。框架保留一个脏元素列表，并在构建阶段直接跳转到它们，跳过干净的元素。在构建阶段，信息在元素树中单向流动，这意味着在构建阶段期间每个元素最多访问一次。清洁后，元素不会再次变脏，因为通过感应，它的所有祖先元素也都是干净的。\n因为窗口小部件是不可变的，所以如果元素没有将自身标记为脏，则元素可以立即从构建返回，如果父级使用相同的窗口小部件重建元素，则会切断步行。此外，元素只需要比较两个窗口小部件引用的对象标识，以确定新窗口小部件与旧窗口小部件相同。开发人员利用此优化来实现重投影模式，其中窗口小部件包括在其构建中存储为成员变量的预构建子窗口小部件。\n在构建期间，Flutter 还避免使用 InheritedWidgets 遍历父链。如果窗口小部件通常走他们的父链，例如确定当前的主题颜色，则构建阶段将在树的深度变为 O（N 2），由于积极的组合，这可能非常大。为了避免这些父行为，框架通过在每个元素上维护一个 InheritedWidgets 的哈希表来向下推送元素树中的信息。通常，许多元素将引用相同的哈希表，该哈希表仅在引入新的 InheritedWidget 的元素上更改。\n线性对比 与流行的看法相反，Flutter 不使用树差异算法。相反，框架通过使用 O（N）算法独立地检查每个元素的子列表来决定是否重用元素。子列表协调算法针对以下情况进行了优化：\n旧子列表为空。 两个列表是相同的。 在列表中的一个位置插入或删除一个或多个小部件。 如果每个列表包含具有相同键的窗口小部件，则匹配两个窗口小部件。 一般方法是通过比较每个小部件的运行时类型和键来匹配两个子列表的开头和结尾，可能在包含所有不匹配子节点的每个列表的中间找到非空范围。然后，框架将旧子列表中的子项放入基于其键的哈希表中。接下来，框架遍历新子列表中的范围，并按键查询哈希表以进行匹配。无法对比的孩子被丢弃并从头开始重建，而匹配的孩子则用他们的新小部件重建。\n树手术（Tree surgery） 重用元素对性能很重要，因为元素拥有两个关键数据：状态小部件的状态和底层的渲染对象。当框架能够重用元素时，保留用户界面的逻辑部分的状态，并且可以重用先前计算的布局信息，通常避免整个子树遍历。事实上，重用元素非常有价值，Flutter 支持非本地树突变，可以保留状态和布局信息。\n开发人员可以通过将 GlobalKey 与其中一个小部件相关联来执行非本地树突变。每个全局密钥在整个应用程序中都是唯一的，并使用特定于线程的哈希表进行注册。在构建阶段，开发人员可以使用全局键将窗口小部件移动到元素树中的任意位置。框架将检查哈希表，并将现有元素从其先前位置重新显示到新位置，而不是在该位置构建新元素，而是保留整个子树。\n重新构造的子树中的渲染对象能够保留其布局信息，因为布局约束是渲染树中从父级传递到子级的唯一信息。新父级被标记为脏，因为其子列表已更改，但如果新父级传递子级具有子级从其旧父级接收的相同布局限制，则子级可以立即从布局返回，从而切断遍历。\n开发人员广泛使用全局键和非本地树突变来实现英雄过渡和导航等效果。\n恒定因子优化（Constant-factor optimizations） 除了这些算法优化之外，实现积极的可组合性还依赖于几个重要的恒定因子优化。这些优化在上面讨论的主要算法的叶子中是最重要的。\n子布局模型不可知论者。与大多数使用子列表的工具包不同，Flutter 的渲染树不会提交给特定的子模型。例如，RenderBox 类有一个抽象的 visitChildren（）方法，而不是具体的 firstChild 和 nextSibling 接口。许多子类仅支持单个子项，直接作为成员变量而不是子项列表。例如，RenderPadding 仅支持单个子节点，因此，布局方法更简单，执行时间更短。 视觉渲染树，逻辑小部件树。在 Flutter 中，渲染树在与设备无关的视觉坐标系中操作，这意味着即使当前读取方向是从右到左，x 坐标中的较小值也始终向左。小部件树通常在逻辑坐标中操作，意味着具有开始和结束值，其视觉解释取决于阅读方向。从逻辑坐标到可视坐标的转换是在小部件树和渲染树之间的切换中完成的。这种方法更有效，因为渲染树中的布局和绘制计算比窗口小部件到渲染树的切换更频繁，并且可以避免重复的坐标转换。 由专门的渲染对象处理的文本。绝大多数渲染对象都不了解文本的复杂性。相反，文本由专门的渲染对象 RenderParagraph 处理，RenderParagraph 是渲染树中的叶子。开发人员不是使用文本感知渲染对象进行子类化，而是使用合成将文本合并到用户界面中。这种模式意味着 RenderParagraph 可以避免重新计算其文本布局，只要其父级提供相同的布局约束，这是常见的，即使在树手术期间也是如此。 可观察的对象。颤动使用模型观察和反应范例。显然，反应范式占主导地位，但 Flutter 对一些叶子数据结构使用可观察的模型对象。例如，动画在值发生变化时通知观察者列表。颤动将这些可观察对象从小部件树移交给渲染树，渲染树直接观察它们并且在它们改变时仅使管道的适当阶段无效。例如，对动画的更改可能仅触发绘制阶段，而不是构建和绘制阶段。 这些优化结合起来并总结了积极构图所产生的大树，对性能产生了重大影响。\n无限滚动 无限的滚动列表对于工具包来说是非常困难的。 Flutter 支持基于构建器模式的简单接口的无限滚动列表，其中 ListView 使用回调按需构建窗口小部件，因为它们在滚动期间对用户可见。支持此功能需要视口感知布局和按需构建窗口小部件。\n视口感知布局 像 Flutter 中的大多数东西一样，可滚动的小部件是使用合成构建的。可滚动窗口小部件的外部是一个视口，它是一个“内部较大”的框，这意味着它的子窗口可以超出视口的边界，并可以滚动到视图中。但是，视口不是具有 RenderBox 子元素，而是具有 RenderSliv​​er 子元素，称为Slivers，具有视口感知布局协议。\nSlivers布局协议与框布局协议的结构相匹配，因为父级将约束传递给子级并返回接收几何。但是，约束和几何数据在两个协议之间不同 ​​。在Slivers协议中，向孩子们提供有关视口的信息，包括剩余的可见空间量。它们返回的几何数据可实现各种滚动链接效果，包括可折叠标题和视差。\n不同的条纹以不同的方式填充视口中可用的空间。例如，产生儿童线性列表的Slivers按顺序排列每个孩子，直到Slivers用完儿童或用完空间。类似地，产生二维儿童网格的Slivers仅填充其可见的网格部分。因为他们知道可以看到多少空间，所以即使他们有可能产生无限数量的儿童，也可以产生有限数量的儿童。\n可以组合 Slivers 来创建定制的可滚动布局和效果。例如，单个视口可以具有可折叠标题，后跟线性列表，然后是网格。所有三个Slivers都将通过Slivers布局协议进行协作，以仅生成通过视口实际可见的子项，无论这些子项是否属于标题，列表或网格。\n按需构建小部件 如果 Flutter 有一个严格的构建 - 然后 - 布局 - 然后 - 绘制管道，前面的内容将不足以实现无限滚动列表，因为通过视口可以看到多少空间的信息仅在布局阶段可用。如果没有额外的机器，布局阶段就太晚了，无法构建填充空间所需的小部件。 Flutter 通过交错管道的构建和布局阶段来解决这个问题。在布局阶段的任何时候，只要这些小部件是当前执行布局的渲染对象的后代，框架就可以开始按需构建新的小部件。\n只有在构建和布局算法中对信息传播进行严格控制，才能实现交错构建和布局。具体而言，在构建阶段，信息只能在树下传播。当渲染对象正在执行布局时，布局遍历没有访问该渲染对象下面的子树，这意味着通过在该子树中构建而生成的写入不能使到目前为止已进入布局计算的任何信息无效。类似地，一旦布局从渲染对象返回，在此布局期间将永远不再访问该渲染对象，这意味着后续布局计算生成的任何写入都不会使用于构建渲染对象的子树的信息无效。\n此外，线性协调和树形外观对于在滚动期间有效更新元素以及在元素在视口边缘滚动进出视图时修改渲染树至关重要。\nAPI 人体工程学（API Ergonomics） 快速只有在框架能够有效使用时才有意义。为了引导 Flutter 的 API 设计更具可用性，Flutter 已经在开发人员的广泛用户体验研究中反复测试过。这些研究有时会确认已有的设计决策，有时可以帮助指导功能的优先级，有时会改变 API 设计的方向。例如，Flutter 的 API 记录很多;用户体验研究证实了此类文档的价值，但也强调了专门针对示例代码和说明性图表的需求。\n本节讨论 Flutter API 设计中为帮助可用性而做出的一些决策。\n专门用于匹配开发人员思维模式的 API Flutter 的 Widget，Element 和 RenderObject 树中节点的基类未定义子模型。这允许每个节点专用于适用于该节点的子模型。\n大多数 Widget 对象都有一个子 Widget，因此只显示一个子参数。一些小部件支持任意数量的子节点，并公开带有列表的子参数。有些小部件根本没有任何子节点，并且没有内存，也没有任何参数。同样，RenderObjects 公开特定于其子模型的 API。 RenderImage 是一个叶子节点，没有子节点的概念。 RenderPadding 只占用一个子节点，因此它具有存储单指针的单个指针。 RenderFlex 占用任意数量的子节点并将其作为链表进行管理。\n在极少数情况下，使用更复杂的子模型。 RenderTable 渲染对象的构造函数接受一个子数组数组，该类公开控制行数和列数的 getter 和 setter，并且有一些特定的方法用 x，y 坐标替换单个子节点，以添加一行，以提供一个新的子数组数组，并用一个数组和一个列数替换整个子列表。在实现中，对象不像大多数渲染对象那样使用链接列表，而是使用可索引数组。\nChip 小部件和 InputDecoration 对象具有与相关控件上存在的插槽匹配的字段。如果一个通用的子模型将强制语义分层在子列表之上，例如，将第一个子项定义为前缀值，将第二个子项定义为后缀，则专用子模型允许用于替代使用的专用命名属性。\n这种灵活性允许这些树中的每个节点以其最常用的角色进行操作。很少想要在表格中插入一个单元格，导致所有其他单元格环绕;同样，很少想要通过索引而不是通过引用从 flex 行中删除子项。\nRenderParagraph 对象是 ​​ 最极端的情况：它有一个完全不同类型的子 TextSpan。在 RenderParagraph 边界处，RenderObject 树转换为 TextSpan 树。\n专门用于满足开发人员期望的 API 的整体方法不仅适用于儿童模型。\n一些相当琐碎的小部件专门存在，以便开发人员在寻找问题的解决方案时会找到它们。一旦知道如何使用 Expanded 小部件和零大小的 SizedBox 子级，就可以轻松地为行或列添加空格，但发现该模式是不必要的，因为搜索空间会揭示 Spacer 小部件，它直接使用 Expanded 和 SizedBox 达到效果。\n类似地，通过根本不在构建中包括窗口小部件子树，可以容易地隐藏窗口小部件子树。但是，开发人员通常希望有一个小部件来执行此操作，因此存在可见性小部件以将此模式包装在一个简单的可重用小部件中。\n明确的论点（Explicit arguments） UI 框架往往具有许多属性，因此开发人员很少能够记住每个类的每个构造函数参数的语义含义。由于 Flutter 使用反应范例，因此 Flutter 中的构建方法通常会对构造函数进行多次调用。通过利用 Dart 对命名参数的支持，Flutter 的 API 能够使这些构建方法保持清晰易懂。\n此模式扩展到具有多个参数的任何方法，特别是扩展到任何布尔参数，以便方法调用中隔离的 true 或 false 文字始终是自我记录的。此外，为避免通常由 API 中的双重否定引起的混淆，布尔参数和属性始终以正形式命名（例如，enabled：true 而不是 disabled：false）。\n摊铺陷阱（Paving over pitfalls） 在 Flutter 框架中的许多地方使用的技术是定义 API，使得不存在错误条件。这样可以避免考虑整个错误类别。\n例如，插值函数允许插值的一端或两端为空，而不是将其定义为错误情况：两个空值之间的插值始终为空，并且从空值或空值插值等效于对给定类型插值为零模拟。这意味着不小心将 null 传递给插值函数的开发人员不会遇到错误情况，而是会获得合理的结果。\n一个更微妙的例子是 Flex 布局算法。这种布局的概念是赋予 flex 渲染对象的空间在其子节点之间划分，因此 flex 的大小应该是整个可用空间。在原始设计中，提供无限空间会失败：这意味着 flex 应该是无限大小的，无用的布局配置。相反，调整了 API，以便在为 flex 渲染对象分配无限空间时，渲染对象会调整其大小以适应子节点的所需大小，从而减少可能的错误情况数。\n该方法还用于避免具有允许创建不一致数据的构造函数。例如，PointerDownEvent 构造函数不允许将 PointerEvent 的 down 属性设置为 false（这种情况会自相矛盾）;相反，构造函数没有 down 字段的参数，并始终将其设置为 true。\n通常，该方法是为输入域中的所有值定义有效解释。最简单的例子是 Color 构造函数。而不是取四个整数，一个用于红色，一个用于绿色，一个用于蓝色，一个用于 alpha，每个都可能超出范围，默认构造函数采用单个整数值，并定义每个位的含义（对于例如，底部的八位定义红色分量），因此任何输入值都是有效的颜色值。\n一个更精细的例子是 paintImage（）函数。此函数需要 11 个参数，其中一些具有相当宽的输入域，但它们经过精心设计，大部分彼此正交，因此很少有无效组合。\n积极报告错误案例 聆听翻译 并非所有错误条件都可以设计出来。对于那些剩下的，在调试版本中，Flutter 通常会尝试很早地捕获错误并立即报告它们。断言被广泛使用。构造函数参数详细检查完整性。监视生命周期，当检测到不一致时，它们会立即引发异常。\n在某些情况下，这是极端的：例如，在运行单元测试时，无论测试正在做什么，每个积极布局的 RenderBox 子类都会检查其内在的大小调整方法是否满足内部大小调整合同。这有助于捕获可能无法执行的 API 中的错误。\n抛出异常时，它们包含尽可能多的信息。 Flutter 的一些错误消息会主动探测相关的堆栈跟踪，以确定实际错误的最可能位置。其他人走相关树来确定不良数据的来源。最常见的错误包括详细说明，包括在某些情况下用于避免错误的示例代码或指向其他文档的链接。\n响应式范式（Reactive paradigm） 可变的基于树的 API 受二元访问模式的影响：创建树的原始状态通常使用与后续更新完全不同的操作集。 Flutter 的渲染层使用这种范例，因为它是维护持久树的有效方法，这是高效布局和绘画的关键。然而，这意味着与渲染层的直接交互充其量是尴尬的，并且在最坏的情况下容易出错。\nFlutter 的小部件层引入了一个使用反应范式来操作底层渲染树的组合机制。此 API 通过将树创建和树变异步骤组合到单个树描述（构建）步骤中抽象出树操作，其中，在每次更改系统状态之后，开发人员描述用户界面的新配置。 framework 计算反映这种新配置所必需的一系列树突变。\n插值（Interpolation ） 由于 Flutter 的框架鼓励开发人员描述与当前应用程序状态匹配的接口配置，因此存在一种在这些配置之间隐式动画的机制。\n例如，假设在状态 S1 中接口由一个圆组成，但在状态 S2 中它由一个正方形组成。如果没有动画机制，状态更改将会有一个不和谐的界面更改。隐式动画允许圆在几帧上平滑平方。\n每个可以隐式动画的特征都有一个有状态小部件，它保存输入当前值的记录，并在输入值改变时开始动画序列，在指定的持续时间内从当前值转换为新值。\n这是使用 lerp（线性插值）函数使用不可变对象实现的。每个状态（在这种情况下为圆形和方形）表示为不可变对象，配置有适当的设置（颜色，笔触宽度等）并知道如何绘制自身。当在动画期间绘制中间步骤时，将开始和结束值传递给适当的 lerp 函数以及表示动画点的值，其中 0.0 表示开始，1.0 表示结束，函数返回表示中间阶段的第三个不可变对象。\n对于圆到边的过渡，lerp 函数将返回一个表示“圆角正方形”的对象，其半径描述为从 t 值导出的分数，使用颜色的 lerp 函数插值的颜色和笔划使用 lerp 函数对双精度进行插值。该对象实现与圆形和正方形相同的界面，然后可以在请求时绘制自己。\n这种技术允许状态机制，状态到配置的映射，动画机制，插值机制，以及与如何绘制每个帧完全相互分离有关的特定逻辑。\n这种方法广泛适用。在 Flutter 中，可以插入基本类型（如颜色和形状），但也可以使用更精细的类型，例如装饰，TextStyle 或主题。这些通常由可以自己插值的组件构成，并且插入更复杂的对象通常就像递归插值描述复杂对象的所有值一样简单。\n某些可插入对象由类层次结构定义。例如，形状由 ShapeBorder 接口表示，并且存在各种形状，包括 BeveledRectangleBorder，BoxBorder，CircleBorder，RoundedRectangleBorder 和 StadiumBorder。单个 lerp 函数不能具有所有可能类型的先验知识，因此接口定义了 lerpFrom 和 lerpTo 方法，静态 lerp 方法遵循这些方法。当被告知从形状 A 插入到形状 B 时，首先询问它是否可以从 A 变形，然后，如果它不能，则向 A 询问它是否可以变为 B.（如果两者都不可能，则该函数返回 A 从 t 小于 0.5 的值，否则返回 B.）\n这允许任意扩展类层次结构，后面的添加能够在先前已知的值和它们自身之间进行插值。\n在某些情况下，插值本身不能由任何可用类描述，并且定义私有类来描述中间阶段。例如，在 CircleBorder 和 RoundedRectangleBorder 之间进行插值时就是这种情况。\n这种机制还有一个额外的优点：它可以处理从中间阶段到新值的插值。例如，在圆形到方形过渡的中途，形状可以再次改变，导致动画需要插入到三角形。只要三角形类可以从圆角方形中间类中获得，就可以无缝地执行转换。\n结论（Conclusion） Flutter 的口号“一切都是小部件”，围绕着构建用户界面，通过组合小部件来构建，小部件又由逐步更基本的小部件组成。这种积极组合的结果是大量的小部件需要精心设计的算法和数据结构才能有效地处理。通过一些额外的设计，这些数据结构还使开发人员可以轻松创建无限滚动列表，以便在可见时按需构建窗口小部件。\n","link":"https://kikt.top/posts/flutter/inside-flutter/","section":"posts","tags":["flutter","inside"],"title":"【简单翻译】flutter的设计哲学（ inside flutter）"},{"body":"","link":"https://kikt.top/tags/inside/","section":"tags","tags":null,"title":"inside"},{"body":"so 库说明 so 库在 android 中,是使用 c/c++代码编译出来的库文件,可以使用 ndk 调用,就是你在 android 代码中见到的 native 方法,具体的实现就在 so 库中\n关于 so 库兼容性问题 andorid 中或多或少都会引用到第三方库,而很多第三方库中都有 so 的存在,不论是复制到项目中(如百度地图),或是 gradle 依赖(如个推) 其中都涉及到了 so 库的相关问题,如果你选择的库是有所有 cpu 类型可选还好,如果不是,那么就需要自定义设置了\n举个栗子 你的 app 依赖两个库,分别是 lib1,lib2\n1 lib1: arm64-v8a,armeabi-v7a 2 lib2: armeabi-v7a 那么当你运行在 v7 的手机上时,因为你的项目含有 v7 的 so 库,所以没有问题,可以跑起来\n如果,你运行在 v8 手机上,那么你的项目就会 boom,崩了, 为啥呢? 这就涉及到 so 对齐了\nso 对齐 简单来说,就是要有就必须都有,如果一个没有,那就一个都不要\n比如上面的例子,如果你是自己复制到项目下的,你需要删掉 arm64-v8a 的文件夹\n如果是个推那种使用 gradle 依赖的方案,那么你需要修改 gradle 文件,这个是我的个推的配置 gradle\n1// 个推的ndk配置 2apply plugin: \u0026#39;com.android.application\u0026#39; 3 4android { 5 defaultConfig { 6 ndk { 7 abiFilters \u0026#34;armeabi-v7a\u0026#34; 8// abiFilters \u0026#34;armeabi-v7a\u0026#34;,\u0026#34;arm64-v8a\u0026#34; 9 } 10 } 11 buildTypes { 12 debug { 13 ndk { 14 abiFilters \u0026#34;armeabi-v7a\u0026#34;, \u0026#34;x86\u0026#34; 15// abiFilters \u0026#34;armeabi-v7a\u0026#34;, \u0026#34;x86\u0026#34;/*, \u0026#34;arm64-v8a\u0026#34;*/ 16 } 17 } 18 release{ 19 ndk{ 20 abiFilters \u0026#34;armeabi-v7a\u0026#34; 21 } 22 } 23 } 24} 25 26repositories { 27 maven { url \u0026#34;http://mvn.gt.igexin.com/nexus/content/repositories/releases/\u0026#34; } 28} 这里因为涉及到 flutter 的调试,而很多模拟器都是 x86 的,所以 debug 的情况下开启了 x86\n最优选择 原则上来讲,so 库的最优选择是提供所有的 so,或者分 cpu 类型打包,这样能做到最优,因为 v8 读取 v7 的 so 库会有性能上的损失\n如果全打包到 apk 里,则会增加 apk 体积\n无奈,目前还没有提供多 cpu 分 apk 上传的应用商店,然后根据手机的 cpu 类型提供对应的下载\n所以目前的方案是提供最低的 cpu 类型, 因为 v7 会去自动兼容 armeabi 的 而 v8 会兼容 v7 和 armeabi\n比如只提供 armeabi so 的,你可以兼容 3 种 cpu 的手机,而只提供 v7 的就要少一点\n目前 android 普遍应该都是 v7+的了,而 flutter 提供的 so 也只有 v7 和 v8 两种而已,所以我们基于这种情况,建议打包的时候自主删除除 armeabi-v7a 以外的选项\n使用如上的 gradle 能解决大部分问题,可以在 gradle 中再修改下打包脚本,自动去除 lib 中的其他 cpu 类型\n这部分可以参考美团的 SO 库兼容性部分 来尝试修改自己的 gradle 打包脚本\n","link":"https://kikt.top/posts/flutter/so-about-1/","section":"posts","tags":["so","flutter","android"],"title":"flutter android So库对齐"},{"body":"自定义 loadmore 写在前面 这类的库在 pub 上有很多\n我为什么要自定义呢\n首先是项目需要，并且这种库普适性高，抽取出来今后复用也方便点\n另外记录一下编码思路,方便后续查看\n使用说明 或 看看构造方法 一共 5 个属性 child 是 ListView\nonLoadMore 是加载更多时的回调,由外部实现\nisFinish 加载完成\ndelegate 是一个抽象类 有默认实现, 其中有 3 个方法,一个是根据状态给一个 widget 高度 一个是延迟加载的毫秒时间 一个是构建显示在内部的 Widget,这样就完全实现了外部可根据状态自定义 Widget\nLoadMoreTextBuilder 是一个根据状态构建文字的方案,默认实现了 中文/英文文字,如果只想修改文字,使用默认样式的话,可以直接用这个即可\n思路 首先考虑怎么自定义 一般来讲有 2 种方式，一个是到底部继续上拉加载，另一种是滚动到底部自动加载，我这里采取的是到底部自动加载方案\n不使用上拉加载的原因是：滚动到底继续上拉不符合正常人习惯，如果是惯性滚动到底，谁知道你后面还有没有东西的\n思考如何自定义 首先怎么样可以知道滚动到底了呢，最简单的方式，listview 的最后一行 build 的时候一定滚动到底了\n所以我们可以使用如下的方式定义\n1 2class _ListViewDemoPageState extends State\u0026lt;ListViewDemoPage\u0026gt; { 3 var count = 10; 4 5 @override 6 Widget build(BuildContext context) { 7 return ListView.builder( 8 itemCount: count + 1, 9 itemBuilder: _buildItem, 10 ); 11 } 12 13 Widget _buildItem(BuildContext context, int index) { 14 if (index == count) { 15 return Text(\u0026#39;到底了\u0026#39;); 16 } 17 return Text(index.toString()); 18 } 19} 这样的话 只要到最后了，你自然知道应该加载了\n可是这个方法不优雅啊，我们应该封装为 Widget 控件，方便复用，接下来就要开始分析怎么自定义了\n首先观察 ListView 的构造方法 有如下几个构造方法\nListView：同名构造方法 ListView.builder ListView.separated ListView.custom\n这里 custom，需要自定义 childrenDelegate 类型为 SliverChildDelegate，我先暂时不考虑\n看其他的三个，发现内部都实现了这个 Delegate 那么我们接收一个 ListView，然后判断其中的 delegate 类型，然后分别进行处理不就可以了吗\n这里我们分别处理，一个是增加一个 count，另一个因为直接获取到了 List ,把 loadmore 的 widget 添加进去就行了\n这里就完成了第一部，在调用方不发生变化的情况下，我们获取 ListView，并且在底部添加了一个 loadmore 的 widget\n构造 widget\n这里要思考了，我们一共需要几种状态 一个是默认时的状态，这个基本很难见到，也就是空闲状态 一个是加载中 一个是加载失败 一个是没更多的数据\n到底这种状态，因为控件理论上不应该控制数据，所以必须由外部传入 其他的状态包含在内部\n1enum LoadMoreStatus { 2 /// 空闲中，表示当前等待加载 3 /// 4 /// wait for loading 5 idle, 6 7 /// 刷新中，不应该继续加载，等待future返回 8 /// 9 /// the view is loading 10 loading, 11 12 /// 刷新失败，刷新失败，这时需要点击才能刷新 13 /// 14 /// loading fail, need tap view to loading 15 fail, 16 17 /// 没有更多，没有更多数据了，这个状态不触发任何条件 18 /// 19 /// not have more data 20 nomore, 21} 这里写一个 enum 用于标示状态\n然后就是构建 widget 了 这里我们根据一些方法得到状态，并且构建一个StatefulWidget返回 这里之所以这么做，是因为如果返回是无状态的 Widget，则二次滚动到底时，不会再次自动触发 build 方法\n1 Widget _buildLoadMoreView() { 2 if (widget.isFinish == true) { 3 this.status = LoadMoreStatus.nomore; 4 } else { 5 if (this.status == LoadMoreStatus.nomore) { 6 this.status = LoadMoreStatus.idle; 7 } 8 } 9 return NotificationListener\u0026lt;_RetryNotify\u0026gt;( 10 child: NotificationListener\u0026lt;_BuildNotify\u0026gt;( 11 child: DefaultLoadMoreView( 12 status: status, 13 delegate: loadMoreDelegate, 14 textBuilder: widget.textBuilder, 15 ), 16 onNotification: _onLoadMoreBuild, 17 ), 18 onNotification: _onRetry, 19 ); 20 } 这里之所以有两个 NotifycationListener 是用于捕捉内部返回的两种动作，一个是自动刷新的动作 一个是点击重试的动作\n触发动作后，我这里就会修改 this.status setState，这样就会触发 loadmorev View 的状态变化\n这里应用到了一个 Flutter 的机制,Notification 机制,Widget 内部通知,外部父节点 NotificationListener 进行捕获,然后根据捕获时的返回值决定是否继续传递.\nDefaultLoadMoreView是一个 StatefulWidget,在内部定义了点击事件和加载事件\n因为一旦显示就自动构建,所以内部会根据状态,只有当 idle 状态时会传递出一个加载的通知,然后上层的 Widget 获取 Notify 后,修改状态为 loading,并调取加载数据的借口\n同理,当加载状态为错误时,内部就不会抛出 notify 了,除非在 LoadMore 的调用方修改 finish 状态,否则理论上 widget 就不会再变化,不论滚动与否,这时需要用户主动点击加载重试,这里在点击事件中抛出重试的通知,外部加载\n这里之所以有一个延时,目的是为了防止 setState 太频繁造成界面不变化的问题,理论上这里大于 16ms 就可以了\n然后我们回到捕获处 后记 总体代码只有 300 行,可以在 pub 里直接使用,目前最新版本为 0.1.1 欢迎 issue 欢迎 star\n","link":"https://kikt.top/posts/flutter/flutter-custom-loadmore/","section":"posts","tags":["loadmore","flutter"],"title":"Flutter 如何自定义一个loadmore 加载更多"},{"body":"","link":"https://kikt.top/tags/loadmore/","section":"tags","tags":null,"title":"loadmore"},{"body":"在 flutter 中 route 是一个绕不开,必须面对,且很常用东西\nRoute 就是路由,顾名思义,负责你页面间的跳转\n不想看代码和思路分析的直接 copy 了拿去用就行 没有啥外部依赖,只需要注意_rootRoute 后面的字符串需要和 initialRoute 对应即可\n路由又分静态和动态路由\n静态就是不需要传参数的,这样的路由可以直接定义在 MaterialApp/WidgetsApp 里 这样可以通过Navigator.pushNamed调用\n动态的就是传入一个PageRoute, 通常是一个MaterialPageRoute 或者CupertinoPageRoute,或者你如果有自定义的有可以使用\n这里我使用一个我的工具类来实现跳转,因为大部分情况下,工程中的路由都是动态的,也就是需要传参数的,所以工具类中只包含了静态路由\n1import \u0026#39;dart:async\u0026#39;; 2 3import \u0026#39;package:flutter/material.dart\u0026#39;; 4 5class RouteHelper { 6 static Future\u0026lt;T\u0026gt; pushWidget\u0026lt;T\u0026gt;( 7 BuildContext context, 8 Widget widget, { 9 bool replaceRoot = false, 10 bool replaceCurrent = false, 11 }) { 12 return pushRoute( 13 context, 14 MaterialPageRoute(builder: (ctx) =\u0026gt; widget), 15 replaceRoot: replaceRoot, 16 replaceCurrent: replaceCurrent, 17 ); 18 } 19 20 static Future\u0026lt;T\u0026gt; pushRoute\u0026lt;T\u0026gt;( 21 BuildContext context, 22 PageRoute\u0026lt;T\u0026gt; route, { 23 bool replaceRoot = false, 24 bool replaceCurrent = false, 25 }) { 26 assert(!(replaceRoot == true \u0026amp;\u0026amp; replaceCurrent == true)); 27 if (replaceRoot == true) { 28 return Navigator.pushAndRemoveUntil( 29 context, 30 route, 31 _rootRoute, 32 ); 33 } 34 if (replaceCurrent == true) { 35 return Navigator.pushReplacement(context, route); 36 } 37 return Navigator.push(context, route); 38 } 39} 40 41var _rootRoute = ModalRoute.withName(\u0026#34;home\u0026#34;); 解析一下这个类,有两个方法,一个是接受 PageRoute,一个是接收 Widget\n接收 Widget 的是讲 Widget 包装为 MaterialPageRoute,然后传给另一个方法\n另一个方法中包含 3 种情况,一种是替换根节点,一种是替换当前页面(关闭当前,且开启新页面),还有一种就是平常的 push(即 不关闭当前,直接开启新的)\n根据传参不同而有所不同\n有一个_rootRoute变量,这个变量的目的是用于替换根节点,'home'是我定义在MaterialApp里的initialRoute,这样一一对应才能确保替换根节点\n当然这个类也可以继续扩展,比如将 routes 定义在内,然后传 route name 参数,接着通过 routes 来提取出 named 对应的 Widget/Route 接着传入pushRoute方法进行跳转即可\n这个简便的 Helper 还有另一个好处,就是可以方便后续批量替换 Route 实现,比如有一天你想自定义一个 PageRoute,不使用 MaterialRoute ,那么你只需要替换如下如所示的部分即可\n当然还可以有别的扩展方法来支持named 比如查看Navigator的源码发现pushNamed,就是通过widget.onGenerateRoute方法获取到route的,我这里直接在 helper 中写就好了 Helper 写完了,我们看看使用的方法 使用起来也很简单\n比如强登陆应用\n1 void _login() { 2 RouteHelper.pushWidget(context, HomeRootPage(), replaceRoot: true); 3 } 这里登录成功后,我直接替换了 root 节点,然后根路由就变成了主页面\n1 void _forgetPwd() { 2 RouteHelper.pushWidget(context, ForgetPwdPage()); 3 } 4 5 void _register() { 6 RouteHelper.pushWidget(context, RegiseterPage()); 7 } 忘记密码和注册都基于登录在做,最终要返回登录,所以这里用普通的调用方法\n1 _register() { 2 RouteHelper.pushWidget( 3 context, 4 RegisterSuccessPage(), 5 replaceCurrent: true, 6 ); 7 } 注册成功后我这里有一个单独的注册成功页,写了一些注册后的注意事项,而返回又应该直接返回到登录页面,所以这里我需要替换掉当前的页面,只用 replaceCurrent 即可\n当然方法接受返回值也是允许的\n1 2 _orderDetail(String item) async { 3 //todo 查看订单详情 4 var result = await RouteHelper.pushWidget\u0026lt;bool\u0026gt;(context, OrderDetailPage(id: item)); 5 if (result == true) { 6 _refresh(); 7 } 8 } 这里如果在详情页买了东西/加到购物车,回到主页面,是要刷新页面的,所以我们接收返回值,然后判断\n小 tips:这里之所以用 result == true 而不是 if(result) 是因为 dart 中 bool是有 3 个值的 true false null\nif(result==true) 可以将 result 为 null 的情况规避掉,提升代码健壮性,这个不得不说是 dart 完全面向对象造成的副作用\n补:在这之后有朋友发出了他的代码运行结果,显示这个在他那里没有问题,我这里出现这个问题是 dart 的正式发布版 2.0.0/2.1.0 出现的 flutter 中自带的 dart sdk 也会出现这样的问题\n","link":"https://kikt.top/posts/flutter/flutter-simple-route-helper/","section":"posts","tags":["route","路由","flutter"],"title":"Flutter 一个简单的Route Helper/Navigator Helper"},{"body":"","link":"https://kikt.top/tags/%E8%B7%AF%E7%94%B1/","section":"tags","tags":null,"title":"路由"},{"body":"有时候 flutter 更新 sdk 版本后不知道该不该更新 有时候 pub 库更新后和自己的其他类库发生了冲突\n类似于图上的情况\n遇到这样的问题应该怎么解决呢\n我们一步步解决\n首先,这种依赖一般是 pub 中引用的,先查看下原作者有没有最新版,也许就解决了呢\n无奈我们用到的类库是一个 5 个月没有更新过的类库,看来是指望不上了 没关系,我们进 pub 主页中\n一般都是有 github 的,我们点进 github 中 如果真没有 那就下一个 zip,然后自己创建一个吧\n然后 fork 项目,clone 下来,修改下\n可以参考下这个修改日志, 修改了库的引用地址,因为这两个库是同一个作者,这个依赖了另一个,我这里修改了另一个库,并且也同样 fork+clone 修改后上传到了自己的 github\n这里是另一个库的修改 我在这里修改了作者使用的依赖为更加新的版本\n接着返回自己的 app 项目中\n修改引用为 git 的方式\n接着再使用就没问题了\ngit 依赖的引用方式可以参考 ,\n","link":"https://kikt.top/posts/flutter/flutter-depo-conflict/","section":"posts","tags":["flutter","冲突"],"title":"Flutter 依赖冲突解决"},{"body":"","link":"https://kikt.top/tags/%E5%86%B2%E7%AA%81/","section":"tags","tags":null,"title":"冲突"},{"body":"文章首发地址: 前言 最近看 qq 群里发的很多代码截图,感觉命名规则/文件命名都不符合规范 很多朋友都是从其他语言转向 dart/flutter 的,深感语言环境还需要大家共同去维护,建议还是规范化代码,这样所有人看着都会舒服 恰好 dart 语言官方有自己的代码规范和相关的说明,在 dartlang 官网上,英文好的建议阅读原文 连接地址 我这里仅粗略翻译和加入一些自己的理解\n图片均来自于上述 url 对应的页面中 当前 dart 版本为 2.0 版本,日期为 2018 年 08 月 22 日 可能会在未来有改动,到时请以最新文档为准\n文档中图片的绿色部分为正例,右上角带good标识 红色是反例,右上角带bad标识\n标识方案 在 dart 有 3 种常规标识方案 第一个为大写字母开头的驼峰式 如 UserInterface 每个词的首字母为大写 第二个是小写开头的驼峰式,如testRun,第一个单词是小写,后续每个单词首字母大写 第三个是每个单词均为小写,以下划线分隔,如user_response\n总结 如果不想往下看具体的图片和翻译,直接看这里\n文件名: 小写+下划线 类型名(类名,函数类型名):大写开头驼峰 变量名(包含 const final 常量):使用小写开头驼峰, 项目有特殊要求 const 可以使用大写+下划线的方式,如同java中一样 导包 as 后的名称为小写+下划线 不要用匈牙利命名法中的 kXXXX 这样的命名方式,应该去掉 k 超过两位的英文缩写一律按该单词为普通小写单词处理,使用小写\n导包有顺序要求,且每\u0026quot;部分\u0026quot;间空行分隔开,每部分内按字母排序,按如下顺序排序 dart sdk 内的库 flutter 内的库 第三方库 自己的库 相对路径引用\n先全部 import 再 export,不要交替进行\n使用 dartfmt 工具格式化 dart 文件代码 dartfmt -w lib/ flutter 可以用flutter format lib 单行字符建议不要超过 80 个 流程控制语句无论如何都使用花括号包裹,即使只有单行\n格式化个人建议:\n建议不要使用 idea/as/vscode 的自动储存格式化作为交付\n因为 idea/vs 有自己的格式化工具,并不是使用的 dartfmt,这样会造成代码交付格式不统一,写代码过程中可以使用以方便提高阅读性,但每次代码 commit 前建议使用 dartfmt -w lib/ 来格式化代码,以便于项目代码风格的统一,flutter 用户使用 flutter format lib\n这段话在之前是没问题的,目前来看,插件中会默认使用 dartfmt 作为格式化工具, 当然也可以通过设置解除, 不过统一的代码风格会带来代码交付的便利性, 所以还是建议使用 dartfmt 进行格式化的\n类型名称 适用于类名,注解名,typedef 定义的函数名\n这里有一个特例,当你的注解是一个 const 的常量时,使用@foo的方式作为注解\n库名称,文件名用小写+下划线 使用小写+下划线方式命名 library,文件名\n原因如下: 某些文件系统不区分大小写，因此许多项目要求文件名全部为小写。使用分隔字符允许名称仍以该形式可读。使用下划线作为分隔符可确保名称仍然是有效的 Dart 标识符\n导入时 当导入包时, 如果涉及到 as, 一律使用小写+下划线方式\n其他标识符 包含顶级成员,类成员,方法内成员,参数名,命名参数名,一律使用小写驼峰式\n常量名称 建议使用小写驼峰式命名 但是你的项目中如果使用大写+下划线分割单词的方式,则可以继续使用这种方式 这里有个小说明:最初 dart 中采用的大写+下划线方式,但是后来有一些变量需要修改为非 const 变量,就需要修改为小写驼峰式,后一律使用小写驼峰式\n缩写相关 超过两位的使用常规方式,两位以内使用大写\n在小写驼峰式中,会出现一些约定俗成的缩写,如http ftp io等,这些在英文词法中都应该是大写,但大写连续会破坏可读性,如HTTPSFTP,你不知道是 HTTPS FTP 还是 HTTP SFTP,所以采用如上图绿色的方式来命名\n不要使用前缀字母 匈牙利命名法中使用缩写开头的小写驼峰命名法时,是因为当时编辑器无法很好帮助理解你的代码,这样命名法能够很好的帮助你去理解代码,现在 dart 语言中,编辑器可以很好的通过声明等方式帮你理解你的代码,故,不要使用前缀字母,如上图绿色\n规定代码的顺序 为了使文件保持整洁，我们有一个规定代码顺序。每个“部分”应该用空行分隔。 保证 dart 的导入顺序在所有其他包之前\n保证带包名的引用方式在相对路径引用之前\n首先 import 第三方的包 导入自己的包在后面一个单独的部分\n全部导入完毕后,再 export 导出\n每个部分按字母顺序排序\n格式化 使用 dartfmt 程序来格式化代码\n单行长度为 80 字符\n可读性研究表明，长行文字难以阅读，因为当你移动到下一行的开头时，你的眼睛必须走得更远。这就是报纸和杂志使用多列文本的原因。\n如果你真的发现自己想要超过 80 个字符的行，我们的经验是你的代码可能过于冗长而且可能更紧凑。主要罪犯通常是 VeryLongCamelCaseClassNames。问问自己，“该类型名称中的每个单词是否告诉我一些关键或防止名称冲突？”如果不是，请考虑省略它。\n流程控制使用花括号 ","link":"https://kikt.top/posts/flutter/dart-flutter-code-style/","section":"posts","tags":["flutter","代码规范","翻译"],"title":"Dart Flutter中的代码规范"},{"body":"","link":"https://kikt.top/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/","section":"tags","tags":null,"title":"代码规范"},{"body":"","link":"https://kikt.top/tags/%E7%BF%BB%E8%AF%91/","section":"tags","tags":null,"title":"翻译"},{"body":"以下所有相关来自于当前认知,flutter 还在高速发展/dart 也在不停更新,后续可能发生变化 目前 flutter dev 版本是 0.7.0\ndart 正式版是 2.0.0\njson_serializable 版本是 1.1.0\n具体的 json 解析可以参考这篇 连接来自于官网\n其中介绍了两种方式，第一种是手动解析\n需要的话可以参考一位大佬写的 这个有一个工具，python+qt 写的跨平台工具，有 linux/mac/windows 三端可执行文件\n第二种是利用\n1dependencies: 2 # Your other regular dependencies here 3 json_annotation: ^0.2.3 4 5dev_dependencies: 6 # Your other dev_dependencies here 7 build_runner: ^0.9.0 8 json_serializable: ^0.5.4 这里有一个坑，就是高版本的 flutter hello world 工程创建时会自动依赖 flutter_test 的高版本，但是这个高版本的 flutter_test 和这个库的当前不兼容，所以会报错，删除掉 test 的引用或等待兼容性更新,我目前版本是 dev 分支的 0.5.7，不排除后续可以使用\n第二种方法需要手写 entity，bean，model，喜欢怎么叫你说了算，\n类似于这种格式，这里我写了一个网页专门用于 json=\u0026gt;dart 文件，可以直接完成这个步骤，将懒最大化\n这里点击下载 复制文件到你的 flutter 中\n接着在命令行中敲\n1flutter packages pub run build_runner build 这里会有一个自动生成.g.dart 的文件，其中就有所有的解析相关的代码\n需要持久化的自动生成就敲击下面的代码，这样会自动监视你 lib 目录下，然后当你的文件发生改变时会自动重新 build 一次，生成对应的文件\n1flutter packages pub run build_runner watch 最后祝使用愉快 我写的工具是开源项目，用 dart web 写的\n对于输入的内容有本地缓存 网页没有任何网络请求相关的连接,下载功能是模拟下载,github 的 release 中有打包好的 html+css+js 文件,可以本地部署,离线使用\n原本用网页写，没有用 python 之类的工具写的目的是为了可以有界面，还易于使用，因为整体压缩完的页面 zip 包只有 40k，还可以在线打开，结果遇到了一个坑\n坑 dart2js 后 1.0 这样的数无法区分是 int 还是 double\n因为 1.0 is int 是 true, 1.0 is double 也是 true 这个是 js 的问题，最终我使用 num 来代替 int,否则在解析的过程中 double 强转为 int 会报错\n这个问题我在 dart 官方的中提问了,结果是因为 js 方面性能来考虑的问题。\n2018-08-24 更新\n这部分问题已经得到了修正\n我用了另一个解决方案来解决 int/double 的问题\n使用字符串替换的方案,将类似 1.0 替换为 1.1\n然后完成解析\n因为 json_serializable 的 1.0 版本更新后,外加生成规则的改变,我添加了版本区分,1.0 版本和 0.x.x 的版本都支持\n关于新注解 JsonLiteral\njson_serializable 库在 1.0 版本中添加了对于本地 json 文件的支持,你将 json 文件放入本地,然后使用 JsonLiteral 注解引入 json 文件,即可自动生成对应的 dart 文件,g.dart 文件,不过这种方式我本人并未验证\n可以参考,这个示例是 1.0.0 中的 ref 版本\n最后祝大家使用愉快\njson 解析愉快\nflutter 很好 欢迎入坑\n后续如果方法失效,请联系 email 我 ,或者 github issue\n","link":"https://kikt.top/posts/flutter/flutter-json/","section":"posts","tags":["flutter","json","json_serializable"],"title":"flutter json解析相关 for json_serializable"},{"body":"","link":"https://kikt.top/tags/json/","section":"tags","tags":null,"title":"json"},{"body":"","link":"https://kikt.top/tags/json_serializable/","section":"tags","tags":null,"title":"json_serializable"},{"body":"mac 开发环境配置 从入门到完成 本文首发简书 转载请注明出处 高能提示：文章字数不多，图很多，请做好战斗准备\n前言 写这篇文章的原因是我自己的 macbook 开不开机，返修后，所有开发环境全部没有了，正好要重新配置开发环境，所以写一个从零配置的文章 因为 flutter 涉及到跨平台开发，所以预想中会包含四部分 mac 篇，android 篇，ios 篇，flutter 篇\n术语相关 cmd = command 键（空格左边） opt／alt = option 键（cmd 左边） ctrl = control（opt 左边） cli = 命令行工具（command-line interface,命令行界面) as = Android Studio\n写在前面 最低需要 xcode 9.0.0 以上的 xcode 版本 但是不建议从非官方渠道下载 xcode，以免遇到之前盗版 xcode 的问题\n我就是都装好了 8.3 才告诉我这个，没办法只能升级系统，再升级 xcode\nmac 篇 所谓 mac 篇就是一些基础的环境，和效率工具\n后面会使用\ncli 我这里使用，一个免费的开源的命令行工具 默认的命令行工具用 launchpad=\u0026gt; 其他 =\u0026gt; 终端打开\nzsh，用于替换 bash 环境，直接命令行中敲 zsh,即可进入，修改默认 zsh 的可以自行百度 oh my zsh，一个 zsh 插件 具体可以自行百度\n一个很方便的包管理工具，基于 ruby+git 命令行敲 /usr/bin/ruby -e \u0026quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\u0026quot;即可 这里会自动安装 xcode 命令行环境，git 环境，需要输入密码确认\n效率篇 Alfred 一个快速开启 app 的辅助工具 Paw http 工具 Sip 取色器\ndmg 相关 遇到提示 dmg 损坏，不要着急 并不一定是真的损坏里，参考这里 ，允许所有的来源即可\n对于 mac 新手来说，可能不会使用 dmg，双击打开，有允许点允许，有 dmg 密码输入密码，最后将应用拖入到 application／应用里，一般 dmg 里都有快捷方式，没有的话自己打开 finder／访达，拖到应用程序里面也行 环境变量相关 不会配置环境变量的，这要仔细看了 在 cli 中敲对应的命令即可\nexport NAME=VALUE //加入环境变量 unset NAME //删除环境变量\nsource fileName //使重新读取配置文件\n这个敲击仅当前 cli 或衍生 cli 有效，想要永久生效就要将配置加入配置文件中\n默认是 bash，所以我们编辑 bash 的配置文件 vi .bash_profile 我这里使用的是 vim 工具，如果不习惯 后续的 vi 可以换成 open ，遇到文件不存在就先敲 touch $fileName\n默认是没有.bash_profile 文件的，创建 并添加 export PATH=XXXXX:$PATH 这里 XXX 代表了你自己的环境变量（adb，jdk，flutter）等\n因为我使用的是 zsh,这里配置 zsh 相关的，让 zsh 可以“读取”到 bash 的配置即可\n1vi .zshrc 在最后一行添加 source .bash_profile 保存，退出\nvi 个人常用命令 i 插入 a 在后插入 shift+4 行尾 l+数字，enter 指定行号 dd 删除行 yy 复制行 p 粘贴行 :wq 保存退出 :q 保存退出 :q! 强制退出不保存\nios 篇 从 app store 安装 xcode，建议不要使用迅雷等工具下载 我这里不是最新的 mac os 版本，所以需要下一个旧的 xcode\n等待漫长的安装，然后运行 xcode 只能同意\n等待中 看到这里 xcode 就算 ok 了\n插一句，我这里因为先安装了 brew，所以 xcode 命令行工具预先安装到了 mac 里，如果没装 brew，这里可能会提示安装 xcode 命令行工具，git 等等，请同意即可\n点击 cmd+，打开首选项 左下角加号 apple id 来登陆你自己的苹果开发者账号／ 不是开发者也能开发 ios 就是不能上传 apple store android 环境篇 android studio 安装 这里我使用一个中文镜像 下载 有梯子的可以去 android 官网下载\n拖到 application 里\n打开\n出现这个不要紧 cancel 就行 一路 next finish 等待，这里大部分的资源目前应该不需要梯子，头几年都是要翻才能下的 finish 出现这个窗口就说明 android 的环境 ok 了 配置 android 的环境变量 jdk 打开 dmg 双击 pkg 一路 next\n新开一个命令行 javac -version java -version\n能正确显示版本号即可 添加 javahome 环境变量\n如果你是 pkg 安装的，先看看 java 安装目录，自己解压的压缩包那就按照自己的目录\n1/usr/libexec/java_home -V 复制这里的最后一行 也就是那个 Home 的目录\n配置在.bash_profile 里\n1export JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_181.jdk/Contents/Home 2export PATH=$JAVA_HOME/bin:$PATH 别忘了\n1source .bash_profile androidsdk 如果是通过刚刚的 android studio 自动安装的，则目录会在/Users/caijinglong/Library/Android/sdk下 这里根据你的用户名不同会有不同的地址，继续添加到.bash_profile 中\n目前我的.bash_profile 是这样的\n1export ANDROID_HOME=/Users/caijinglong/Library/Android/sdk/ 2export JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_181.jdk/Contents/Home 3export PATH=$JAVA_HOME/bin:$ANDROID_HOME/platform-tools:$PATH 第三行的$JAVA_HOME/bin 有没有其实没关系 现在返回 cli 中，敲adb会出现很长的英文，这个是 adb 命令的说明 能出现则说明成功，不成功的话请重新检查下环境变量是不是没配置好\nflutter 篇 终于要开始 flutter 篇了\npub 环境变量 这里建议没有常驻翻墙的同学打开下面的页面，配置下中文的 pub 镜像，pub 是 dart 官方提供的一个中心仓库，可以将依赖／开源库上传到上面\n官网 有能力的同学这里自己进入按照 mac 篇进行配置 或者继续看下去\n开始安装 flutter cli：\n1cd ~/Library 2mkdir Flutter \u0026amp;\u0026amp; cd Flutter 这里可能会比较慢 可以使用 gitee 的镜像来 clone\n1//github 2git clone -b dev https://github.com/flutter/flutter.git 3 4//gitee（我同步github的库） 5git clone -b dev https://gitee.com/kikt/flutter.git 后续修改 git 的 remote 为 github 地址即可\n1git remote set-url origin https://github.com/flutter/flutter.git 查看下\n1git remote -v 配置 flutter 的环境变量 这里配置 flutter_home\n1export FLUTTER_HOME=/Users/caijinglong/Library/Flutter/flutter 2export PATH=$JAVA_HOME/bin:$ANDROID_HOME/platform-tools:$FLUTTER_HOME/bin:$PATH 接着返回 cli\n1cd ~ 2source .bash_profile 3flutter doctor -v 这个 flutter doctor -v 就是显示 flutter 的环境问题，以后可能会经常敲\n这里加-v 就是详情，如果有问题需要帮助，这里一定要带-v 这里加-v 就是详情，如果有问题需要帮助，这里一定要带-v 这里加-v 就是详情，如果有问题需要帮助，这里一定要带-v\n这里加-v 就是详情，如果有问题需要帮助，这里一定要带-v\n接着就是漫长的等待，这里会下载 flutter 的相关构建工具等等 这里带 X 的就是有问题的，我们需要一项项的去解决 大部分都给了 cli 方案 就是 run： 后面的东西 这里我们看到了建议大家使用 brew 去安装这些库，这也是为什么我这里开篇就介绍如何安装 brew 的原因\n这里我标记了 6 个问题\nandroid 许可证问题 flutter doctor --android-licenses 一路 y 过去 xcode 的问题 sudo xcode-select --switch /Applications/Xcode.app/Contents/Developer\nflutter ios 工具链的问题 这里需要使用 brew 安装一些工具以帮助 flutter 可以调试 ios 程序，你模拟器能跑起来，但是 ios 真机不行大概率就是这里的原因 cli:\n1brew install --HEAD libimobiledevice` 这里会安装很多的二进制库 完成后继续下一步\n1brew install ideviceinstaller 这里比较简短\n1brew install ios-deploy 这里是 ios 开发相关的了 使用 cocoapod 作为 ios 的库管理工具，这个是 ios 开发中很常见的一个包管理工具，我们按照提示安装\n1brew install cocoapods 接着是安装 pod 的库相关的索引\n1pod setup 这里看到 下载速度还行，虽然没有国内快，但是也有接近 4m 的速度了，如果这里你的速度不佳，可以考虑使用 gitee 的 spec 中转，\n这里因为涉及到的文件很多 百万级文件数量，所以会比较慢，耐心等待就行了 如果你是 imac／mac mini 没有固态，建议你自己想办法加一个，不然这步时间可能 1 ～ 3 小时不等 我的 2016 款 macbook pro 是 pcie 的 ssd，下载时间大概 5 分钟，“解压”也用了 5 分钟，全程 10 分钟左右\n平心而论，pod 的索引方式个人感觉很蠢，最初数量级小的情况下还算能接受，现在 pod 的库数量越来越多，用这种方式来做中心库索引简直接受不了，后面会越来越臃肿\nandroid studio 插件问题 在 studio 中点 cmd+, 打开首选项 点击 plugin\n选下载人多的 点 yes\n然后耐心等待\n完成后是这样的\n点击重启后\n问题解决完毕\n我们返回到 cli 中 敲\n1flutter doctor -v 这里我发现我这遇到里之前没有的问题， 第一个 X 提示我 xcode 需要最低 9.0.0 的版本 第二个 X 提示我缺少一个叫 six 的 python 库\n我这里因为系统版本的原因下载不了 9.0.0 以上的 xcode，只能升级版本后重新下载了，这个后面补上\n先完成第二个，有两个选择 pip install six sudo easy_install six 根据提示敲击，我这里选择的是第二个\n1sudo easy_install six 然后我们只剩下 xcode 的问题了，如果你的 xcode 版本没问题，那你可以跳过这里，直接看 flutter 的运行相关\n系统更新\n到 mac app store 中 去下载新的系统版本\n完成后打开，接着一路下一步，都是中文，等待完成就行 系统更新完成，现在开始更新 xcode 完成后，回到 cli 中\n1flutter doctor -v 提示我要同意协议 这里可以打开 xcode，也可以直接命令行敲击，建议直接打开 xcode\n我这里用命令行同意\n1sudo xcodebuild -license 这里点 enter（回车）\n这里输入 agree 回车\n这里的错误还是需要打开 xcode，所以前面建议你直接打开 xcode app\n这里之前遇到过，install 就行了\n到这里 xcode 的问题就都解决了 再次flutter doctor -v\npod 又出问题了，还是应该先升级系统，再一次性安装，这又来了无用功 按提示走把\n1brew install cocoapods 告诉我已经安装了 提示我 reinstall\n1brew reinstall cocoapods 这是最后一次了 除了没连接设备外，没其他问题了 😊\nflutter 部分的环境配置到这里基本完成了，接着就该运行项目了\n运行项目 初次建立项目建议使用 cli 创建，因为会很慢，用 as 的话 你很难知道自己在等什么，甚至网络链接失败你都不知道\ncli 里敲击\n1flutter create hello_world 项目名不能有大写字母，所以建议使用下划线作为单词的分隔 这样就代表项目的文件都 ok 了，接着按照提示进入项目内，这里慢的话 可能是获取依赖的时候卡住了\nandroid 运行 右上角 我这里新装的 sdk，没有 android 的镜像，所以 download 下 完成后点 finish 即可\n接着点选刚刚下载的，一路 next+finish\n运行后关闭 device manager 回到主界面 这第一次运行会下载 gradle，速度不好说，可能会很慢 这个会下载这个，你可以用迅雷复制这里的链接下载下来，复制到如下图的文件夹下 我这里速度很好，很快就跑起来了 ios 运行 在 as 中点这个 会开启一个 ios 模拟器\n在开启模拟器成功后，发现 as 识别不到，这种情况不要怕\n命令行敲 flutter doctor -v 试试 我们看到，是有设备的，重启下 as 试试吧 设备出来了，我们点旁边的 run（绿三角）试试吧\n项目也跑起来了，大功告成\n后记 整篇文章是我边搭环境边写的 可以说很详细了，中间我还走了 xcode 版本号的弯路 但是项目后来还是成功的跑起来了，希望各位看我文章的 也能成功\n可以看到我开始的截图 macos 版本是 10.12.3 后来安装了新版本 变成了 10.13.6\n我单位的版本是 10.12.6 那个 macos 版本是可以安装 xcode 9.0 的\n","link":"https://kikt.top/posts/flutter/mac-flutter-env-0-to-1/","section":"posts","tags":["flutter","mac","开发环境"],"title":"Mac Flutter 开发环境配置 从0到1 流程"},{"body":"","link":"https://kikt.top/tags/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/","section":"tags","tags":null,"title":"开发环境"},{"body":"","link":"https://kikt.top/tags/faq/","section":"tags","tags":null,"title":"faq"},{"body":"写在前面 这篇文章的目的是给纯 flutter 萌新回答一些基础问题,ctrl+f/cmd+f 搜索关键字 控件名 本篇会持续更新 最后更新时间 2018-08-02\n布局篇 flutter 中 控件各司其职,基础控件中基本只包含自己的功能 显示内容的负责显示内容,如 Text 负责文字,Image 负责图片 容器的负责容器,Row,Column,ListView 等 尺寸位置的负责自己,Padding,Container,SizedBox 等 触摸手势触摸相关:GestureDetector\nflutter 中在 widget 层级提倡组合模式,而不提倡继承模式 比如你不应该有一个class TextButton extend Text/RaisedButton这样的方案出现 而应该是\n1 2class TextButton extends StatelessWidget { 3 final Function onPressed; 4 final String text; 5 final Color color; 6 final double fontSize; 7 final EdgeInsets padding; 8 9 const TextButton({ 10 Key key, 11 this.onPressed, 12 this.text = \u0026#34;\u0026#34;, 13 this.color = Colors.black87, 14 this.fontSize = 14.0, 15 this.padding = EdgeInsets.zero, 16 }) : super(key: key); 17 18 @override 19 Widget build(BuildContext context) { 20 return new Material( 21 color: Colors.transparent, 22 child: InkWell( 23 onTap: onPressed, 24 child: Padding( 25 padding: padding, 26 child: new Text( 27 text, 28 style: new TextStyle(fontSize: fontSize, color: color), 29 ), 30 ), 31 ), 32 ); 33 } 34} 类似于这样的方案\n怎么设置宽度/高度 外面包一个 SizedBox,设置 height,Container 也可以,还能加 padding,背景颜色等 child 可以是任意属性\n这样的,我应该怎么布局,那样的我该怎么布局 这样的问题,通常归结为不会划分,总体来说有以下几点\n横向多控件,用 Row 包起来,顺序排下去 纵向多控件,用 Column 包起来,顺序排下去 单页显示不下的,用 ListView,默认纵向,修改 scrollDirection 属性,ListView 在 flutter 中就是 scrollView 我要给某某控件加一个点击事件,没有 onTap,onPressed 吗 GestureDetector 包含了丰富的手势,包上你的控件就好了\n1GestureDetector(onTap:()=\u0026gt;print(\u0026#39;点击点击\u0026#39;),child:Text(\u0026#39;点击\u0026#39;)); 这 on 开头的属性全部都是系统定义好的回调 tap 是点击相关,doubleTap 是双击,longPress 长按 VerticalDrag 相关是纵向拖动 HorizontalDrag 相关是横向拖动 pan 相关是手指移动 scale 是双指缩放手势\nbehavior代表控件透明时是否可以响应手势\n圆角怎么设置,背景图片怎么设置 Container 控件中有decoration属性可以设置,要注意的一点是 这个属性本身和 color 是互斥的,一旦设置 decoration,需要去掉 color 属性 BoxDecoration 有很多属性可以用 颜色,图片,边框,圆角,阴影,渐变色,形状\nSnackBar 显示没有 scaffold 1Scaffold.of() called with a context that does not contain a Scaffold. context 层级用错了 这个是由于 flutter 层级中 这个 context 的父布局没有 Scaffold 的原因,大概就是你是直接用的页面级的 context page -\u0026gt; scaffold -\u0026gt; button 你用了 page 级的, 所以找不到了 解决方案就是中间套一个 builder,用于\u0026quot;转换\u0026quot;出一个位于 scaffold 后的 context,然后就可以了 page -\u0026gt; scaffold -\u0026gt; Builder -\u0026gt;button\n1import \u0026#39;package:flutter/material.dart\u0026#39;; 2import \u0026#39;package:kappbar/kappbar.dart\u0026#39;; 3 4class HomePage extends StatefulWidget { 5 @override 6 _HomePageState createState() =\u0026gt; _HomePageState(); 7} 8 9class _HomePageState extends State\u0026lt;HomePage\u0026gt; { 10 @override 11 Widget build(BuildContext context) { 12 return Scaffold( 13 appBar: MyAppBar( 14 title: Text(\u0026#39;测试\u0026#39;), 15 elevation: 0.0, 16 ), 17 body: Container( 18 child: Builder( // 这里套一层 19 builder: (ctx) =\u0026gt; RaisedButton( 20 onPressed: () =\u0026gt; _click(ctx), //把builder给的ctx传递给方法 21 )), 22 ), 23 ); 24 } 25 26 void _click(BuildContext context) { 27 // 这里使用传入的context就好了 28 Scaffold.of(context).showSnackBar(SnackBar( 29 content: Text(\u0026#39;内容\u0026#39;), 30 )); 31 } 32} ListView 套 ListView 报错 这个是因为 ListView 是会占满父布局的控件,你需要给内部的 ListView 加一个高度/宽度限制,如果外部是纵向,则需要高度,外部是横向,需要宽度 可以看你的情况,可以使用 SizedBox,Container,AspectRatio 这样的控件\n这样的道理也适用于 Column 内部嵌套 ListView 的情况\n适配篇 我个人理解的最佳适配方案是当年那套.文字流式,图片宽高比 图片应该在设计时给定宽高比 文字的话没特殊要求直接自适应 控件弹性的意思,控件高度是固定的,然后占满屏幕,或者百分比,内部的东西左对齐的左对齐,右对齐的右对齐,剩下的占满剩余区域,或者比例分配\ndart 相关语法篇 先定义一个类,后面用到\n1class User{ 2 String name; 3 void print(){ 4 print(this.name); 5 } 6} ?. 什么意思 以下两种写法是等效的\n1void foo(User user){ 2 user?.print(); 3} 1void foo(User user){ 2 if(user != null){ 3 user.print(); 4 } 5} ??啥意思 以下两种写法是等效的\n1var text = user?.name ?? \u0026#34;默认名字\u0026#34;; 1String text; 2if(user != null \u0026amp;\u0026amp; user.name != null){ 3 text = user.name; 4}else{ 5 text = \u0026#34;默认名字\u0026#34;; 6} ??= 啥意思 1User create(User user){ 2 var user ??= User(); 3 return user; 4} 1User create(User user){ 2 if(user == null){ 3 user = User(); 4 } 5 return user; 6} typedef 是啥意思 在 dart 语言中,函数是一等公民,函数本身也是对象 可以被赋值给变量\n举个栗子 这个是在 Hero 动画中用到的 final CreateRectTween createRectTween;\n查看下 CreateRectTween 的定义,会发现有这么一个写法 typedef Tween\u0026lt;Rect\u0026gt; CreateRectTween(Rect begin, Rect end);\n简单的说: 这个是一个函数类型,名称是CreateRectTween,这个函数接收两个 Rect 值,返回一个 Tween 对象 使用的时候就是这样的\n1Hero( 2 createRectTween:(Rect begin,Rect end){ 3 return MaterialRectArcTween(begin:begin,end:end); 4 } 5); 拆开来写\n1CreateRectTween method = (Rect begin,Rect end){ 2 return MaterialRectArcTween(begin:begin,end:end); 3}; 4Hero( 5 createRectTween:method, 6); android studio 中 怎么编辑 android 项目,没有代码提示,还报错 这里需要在一个新窗口中打开 android 项目\n","link":"https://kikt.top/posts/flutter/flutter-base-faq/","section":"posts","tags":["flutter","faq"],"title":"Flutter基础faq"},{"body":"github 是每个程序员应该都会用到的平台,无奈对于国内貌似没有 CDN,速度极慢..\n我在网上搜了各种修改 host 的方案,无奈并不好用,也许用国外的 VPS 中转可以解决,当然那是要收费的,还需要一些技术门槛\n今天来一个傻瓜式的帮助方案 用 gitee 中转项目\n开始 注册账号 注册账号,已经有的话可以直接登录,更简单的方案,直接用 github 账号登录 新建项目 二选一 新开一个窗口,把你需要的 github 项目地址复制过来,我这里以 flutter/engine 为例 然后回到新建项目的页面\n点这里 然后照图上操作 最后点创建\n接着就等项目好了\n这里需要耐心等待,但无论如何 很大的项目应该比你自己从那下载要快很多,毕竟有时候你从 github 每秒只有几十或者 100 200K 项目好了后 我们看到,项目都好了\n这里复制项目地址\n然后命令行中 我们看到 4M 每秒的速度, 这在大项目中就帮了大忙了\n如果是 200M 的项目,你 200k 一秒 需要下 1000 秒,也就是 20 分钟\n而我这里 clone 只要 50 秒 前面的工作一共操作也就是 2 分钟 等待时间也就是 3~5 分钟\n并且哪怕需要在 github 提 PR 或者 fork github 项目也没关系 修改 remote 的 url 即可,毕竟 git 是去中心化的仓库\n另外 cocoapod 这个项目的 spec 简直就是大坑 用 github 能下死你 用这种方案就很快了 能节省你最少 1~2 小时的时间 cocoapods 的 spec gitee 地址 好了这篇纯小白向的帮助 😉 就到这里了,希望能帮助到你\n","link":"https://kikt.top/posts/other/github-clone-slow/","section":"posts","tags":["github","慢"],"title":"github Clone速度慢的解决方案之一"},{"body":"","link":"https://kikt.top/tags/%E6%85%A2/","section":"tags","tags":null,"title":"慢"},{"body":"flutter 面向新手向 flutter 中一切界面层级的东西全部都是 Widget 这句话怎么理解呢?\n大到整个应用,小到一个文字控件,全部都是 Widget\n一个常规的 Application 图级可能是这样的,当然实际情况下会比这复杂很多 对应代码和实际情况看一下 为了和图片对应 我把所有的写到一个文件里\n1 2import \u0026#39;package:flutter/material.dart\u0026#39;; 3 4void main() =\u0026gt; runApp(new MyApp()); 5 6class MyApp extends StatelessWidget { 7 @override 8 Widget build(BuildContext context) { 9 return new MaterialApp( 10 title: \u0026#39;Flutter 结构简析\u0026#39;, 11 theme: new ThemeData( 12 primarySwatch: Colors.blue, // 这里是项目的主色调 13 ), 14 home: MyHomePage(), 15 ); 16 } 17} 18 19class MyHomePage extends StatefulWidget { 20 @override 21 _MyHomePageState createState() =\u0026gt; _MyHomePageState(); 22} 23 24class _MyHomePageState extends State\u0026lt;MyHomePage\u0026gt; { 25 @override 26 Widget build(BuildContext context) { 27 return Scaffold( 28 appBar: AppBar(), 29 body: ListView( 30 children: \u0026lt;Widget\u0026gt;[ 31 ListTile(title: Text(\u0026#39;我是第一个item\u0026#39;)), 32 ListTile(title: Text(\u0026#39;我是第二个item\u0026#39;)), 33 ], 34 ), 35 ); 36 } 37} 这里的一切皆 widget 的意思就是 Application 是 Widget Page 是 Scaffold 是 Appbar 是 ListView 是 ListTile 也是 Text 也是\n组合达到常见的效果 以官方的一个页面为例子 我们来做的话就是整体是一个 Column 或者 ListView 然后子项目是\n1Image 2Row 3 Column 4 Text 5 Text 6 Row 7 Image(Icon) 8 Text 9Row 10 Column 11 Row 12 Image 13 Text 14 Column 15 Column 16Text 当然这个是指的主体结构,实际上还会有更多的 接着不看这个链接里的代码,自己撸一个 demo\ndemo 相关 一阶段 头部图片 第一阶段对应的截图 代码\n1class TutorialsPage extends StatefulWidget { 2 @override 3 _TutorialsPageState createState() =\u0026gt; _TutorialsPageState(); 4} 5 6class _TutorialsPageState extends State\u0026lt;TutorialsPage\u0026gt; { 7 @override 8 Widget build(BuildContext context) { 9 return Scaffold( 10 body: ListView( 11 children: \u0026lt;Widget\u0026gt;[ 12 //为了好分辨,我将内部的4大块分为四个方法 13 _buildHeader(), 14 ], 15 ), 16 ); 17 } 18 19 Widget _buildHeader() { 20 // 这里对应的是图片 21 return Image.asset(\u0026#34;images/lakes_header.jpg\u0026#34;); 22 } 23} 二阶段 第二阶段的截图 1 2class _TutorialsPageState extends State\u0026lt;TutorialsPage\u0026gt; { 3 @override 4 Widget build(BuildContext context) { 5 return Scaffold( 6 body: ListView( 7 children: \u0026lt;Widget\u0026gt;[ 8 //为了好分辨,我将内部的4大块分为四个方法 9 _buildHeader(), 10 Padding( 11 //这里我观察到下面有一个整体的左右边距,所以这里单独抽取了一个padding 12 child: Column( 13 children: \u0026lt;Widget\u0026gt;[ 14 _buildSecond(), // 第二部分 15 ], 16 ), 17 padding: const EdgeInsets.only( 18 left: 30.0, 19 right: 30.0, 20 ), 21 ), 22 ], 23 ), 24 ); 25 } 26 27 Widget _buildHeader() { 28 // 这里对应的是图片 29 return Image.asset(\u0026#34;images/lakes_header.jpg\u0026#34;); 30 } 31 32 _buildSecond() { 33 Widget row = Row( 34 children: \u0026lt;Widget\u0026gt;[ 35 Expanded( 36 child: Column( 37 children: \u0026lt;Widget\u0026gt;[ 38 Text(\u0026#39;旅游圣地\u0026#39;), 39 Text(\u0026#39;不要钱\u0026#39;,style: TextStyle(fontSize: 12.0,color: Colors.grey),), 40 ], 41 mainAxisAlignment: MainAxisAlignment.spaceEvenly, 42 crossAxisAlignment: CrossAxisAlignment.start, 43 ), 44 ), 45 Row( 46 children: \u0026lt;Widget\u0026gt;[ 47 Icon( 48 Icons.star, 49 color: Colors.yellow, 50 ), 51 Text(\u0026#39;30\u0026#39;), 52 ], 53 ), 54 ], 55 ); 56 row = SizedBox( 57 height: 60.0, 58 child: row, 59 ); 60 return row; 61 } 62} 第三部分 截图: 1 2/// 对应 https://flutter.io/tutorials/layout/ 的 https://flutter.io/tutorials/layout/images/lakes.jpg 图片 3class TutorialsPage extends StatefulWidget { 4 @override 5 _TutorialsPageState createState() =\u0026gt; _TutorialsPageState(); 6} 7 8class _TutorialsPageState extends State\u0026lt;TutorialsPage\u0026gt; { 9 @override 10 Widget build(BuildContext context) { 11 return Scaffold( 12 body: ListView( 13 children: \u0026lt;Widget\u0026gt;[ 14 //为了好分辨,我将内部的4大块分为四个方法 15 _buildHeader(), 16 Padding( 17 //这里我观察到下面有一个整体的左右边距,所以这里单独抽取了一个padding 18 child: Column( 19 children: \u0026lt;Widget\u0026gt;[ 20 _buildSecond(), // 第二部分 21 _buildThird(), // 第二部分 22 ], 23 ), 24 padding: const EdgeInsets.only( 25 left: 30.0, 26 right: 30.0, 27 ), 28 ), 29 ], 30 ), 31 ); 32 } 33 34 Widget _buildHeader() { 35 // 这里对应的是图片 36 return Image.asset(\u0026#34;images/lakes_header.jpg\u0026#34;); 37 } 38 39 _buildSecond() { 40 Widget row = Row( 41 children: \u0026lt;Widget\u0026gt;[ 42 Expanded( 43 child: Column( 44 children: \u0026lt;Widget\u0026gt;[ 45 Text(\u0026#39;旅游圣地\u0026#39;), 46 Text(\u0026#39;不要钱\u0026#39;,style: TextStyle(fontSize: 12.0,color: Colors.grey),), 47 ], 48 mainAxisAlignment: MainAxisAlignment.spaceEvenly, 49 crossAxisAlignment: CrossAxisAlignment.start, 50 ), 51 ), 52 Row( 53 children: \u0026lt;Widget\u0026gt;[ 54 Icon( 55 Icons.star, 56 color: Colors.yellow, 57 ), 58 Text(\u0026#39;30\u0026#39;), 59 ], 60 ), 61 ], 62 ); 63 row = SizedBox( 64 height: 60.0, 65 child: row, 66 ); 67 return row; 68 } 69 70 _buildThird() { 71 Widget buildItem(IconData iconData, String text) { 72 return Expanded( 73 child: SizedBox( 74 height: 50.0, 75 child: Column( 76 children: \u0026lt;Widget\u0026gt;[ 77 Icon( 78 iconData, 79 color: Colors.blue, 80 ), 81 Text( 82 text, 83 style: TextStyle(color: Colors.blue), 84 ), 85 ], 86 mainAxisAlignment: MainAxisAlignment.spaceEvenly, 87 ), 88 ), 89 ); 90 } 91 92 return Row( 93 children: \u0026lt;Widget\u0026gt;[ 94 buildItem(Icons.phone, \u0026#39;呼叫\u0026#39;), 95 buildItem(Icons.room, \u0026#39;导航\u0026#39;), 96 buildItem(Icons.share, \u0026#39;分享\u0026#39;), 97 ], 98 ); 99 } 100} 第四部分 1 2/// 对应 https://flutter.io/tutorials/layout/ 的 https://flutter.io/tutorials/layout/images/lakes.jpg 图片 3class TutorialsPage extends StatefulWidget { 4 @override 5 _TutorialsPageState createState() =\u0026gt; _TutorialsPageState(); 6} 7 8class _TutorialsPageState extends State\u0026lt;TutorialsPage\u0026gt; { 9 @override 10 Widget build(BuildContext context) { 11 return Scaffold( 12 body: ListView( 13 children: \u0026lt;Widget\u0026gt;[ 14 //为了好分辨,我将内部的4大块分为四个方法 15 _buildHeader(), 16 Padding( 17 //这里我观察到下面有一个整体的左右边距,所以这里单独抽取了一个padding 18 child: Column( 19 children: \u0026lt;Widget\u0026gt;[ 20 _buildSecond(), // 第二部分 21 _buildThird(), 22 _buildFourth(), 23 ], 24 ), 25 padding: const EdgeInsets.only( 26 left: 30.0, 27 right: 30.0, 28 ), 29 ), 30 ], 31 ), 32 ); 33 } 34 35 Widget _buildHeader() { 36 // 这里对应的是图片 37 return Image.asset(\u0026#34;images/lakes_header.jpg\u0026#34;); 38 } 39 40 _buildSecond() { 41 Widget row = Row( 42 children: \u0026lt;Widget\u0026gt;[ 43 Expanded( 44 child: Column( 45 children: \u0026lt;Widget\u0026gt;[ 46 Text(\u0026#39;旅游圣地\u0026#39;), 47 Text( 48 \u0026#39;不要钱\u0026#39;, 49 style: TextStyle(fontSize: 12.0, color: Colors.grey), 50 ), 51 ], 52 mainAxisAlignment: MainAxisAlignment.spaceEvenly, 53 crossAxisAlignment: CrossAxisAlignment.start, 54 ), 55 ), 56 Row( 57 children: \u0026lt;Widget\u0026gt;[ 58 Icon( 59 Icons.star, 60 color: Colors.yellow, 61 ), 62 Text(\u0026#39;30\u0026#39;), 63 ], 64 ), 65 ], 66 ); 67 row = SizedBox( 68 height: 60.0, 69 child: row, 70 ); 71 return row; 72 } 73 74 _buildThird() { 75 Widget buildItem(IconData iconData, String text) { 76 return Expanded( 77 child: SizedBox( 78 height: 50.0, 79 child: Column( 80 children: \u0026lt;Widget\u0026gt;[ 81 Icon( 82 iconData, 83 color: Colors.blue, 84 ), 85 Text( 86 text, 87 style: TextStyle(color: Colors.blue), 88 ), 89 ], 90 mainAxisAlignment: MainAxisAlignment.spaceEvenly, 91 ), 92 ), 93 ); 94 } 95 96 return Row( 97 children: \u0026lt;Widget\u0026gt;[ 98 buildItem(Icons.phone, \u0026#39;呼叫\u0026#39;), 99 buildItem(Icons.room, \u0026#39;导航\u0026#39;), 100 buildItem(Icons.share, \u0026#39;分享\u0026#39;), 101 ], 102 ); 103 } 104 105 _buildFourth() { 106 return Padding( 107 padding: const EdgeInsets.all(8.0), 108 child: Text( 109 \u0026#39;这个旅游地方我也不知道是什么地方,有什么流弊的,不过看起来还不错.\\n\\n\u0026#39; 110 \u0026#39;这篇文章就到这里基本也没啥说的了,这个是第四部分,我就把内容直接放在Widget里面了,感谢观看,后面我可能会出一个简易的FAQ,专门写一些小白问题☺☺☺☺☺\u0026#39;, 111 style: TextStyle( 112 fontSize: 13.0, 113 ), 114 ), 115 ); 116 } 117} ","link":"https://kikt.top/posts/flutter/flutter-newer-readme/","section":"posts","tags":["flutter"],"title":"Flutter 项目新手向结构简析"},{"body":"flutter 介绍 所有的一切都是个人观点,不满可以留言,可以讨论,吵架大可不必 所有的资料仅 2018-07-06 时我所了解的,当前的 flutter 版本号 dev 为 0.5.6,beta 为 0.5.1 转载请注明出处,简书为第一发布平台(本人目前迁出简书平台,自建 blog)\n何谓 flutter 简介 google 自己的官方介绍,来源于\n为什么要用 flutter 跨平台框架,能开发 ios/android,性能不错\n已有那么多的跨平台方案,flutter 有什么优势 所有 UI 为 Flutter 平台自建,使用 skia 引擎绘制到屏幕上,能保持高度的统一性 所以 flutter 定位仅为 UI 框架,可以做一些业务逻辑\n劣势呢 目前与原生控件很难有机的结合到一个界面内\n1 大概意思是,目前类似于baidumap,这样的控件只能是生硬的覆盖到flutter的界面上 2 android中对应FlutterView(SurfaceView),ios中是FlutterViewController的根view 3 你很难直接写方便的回调,手势控制 4 5 WebView,直播等视频播放同理 与原生通信仅依赖一个接近字符串性质的通道,没有构建工具/编译层级的检查 尚处于初级阶段,开源社区还不活跃,相关社区关注度不高\n1 关于字符串性质的通道: 2 大概意思就是,所有的通信依赖于字符串 3 比如flutter中需要定义 4 static const MethodChannel _channel = const MethodChannel(\u0026#39;com.365.app/BarCode\u0026#39;); 5 _channel.invokeMethod(\u0026#34;getData\u0026#34;, source); 6 类似于这样的调用方式 7 8 而原生中 也是需要定义出完全相同的字符串来表示通道名,方法名等等 flutter 使用 dart 语言开发 为什么使用 dart,貌似是说 flutter 的开发团队物理距离 dart 的团队很近,这段真实性未知\n前景情况 个人觉得如果你的团队允许,可以考虑转入\n其他文章链接 一篇在上看到的文章 : 后记 后面打算写一篇 Google 的 Gallery 的源码解析,看看有没有这个毅力吧\n","link":"https://kikt.top/posts/flutter/flutter-first-blog/","section":"posts","tags":["flutter","介绍"],"title":"Flutter开篇介绍"},{"body":"","link":"https://kikt.top/tags/%E4%BB%8B%E7%BB%8D/","section":"tags","tags":null,"title":"介绍"},{"body":"","link":"https://kikt.top/tags/navigationbar/","section":"tags","tags":null,"title":"navigationbar"},{"body":"简单记录,为后续方便查找,仅有代码片段\n可以放在ViewController的基类中\n1if let bar = self.navigationController?.navigationBar { 2 bar.backgroundColor = .themeColor 3 bar.tintColor = .white 4 var attrs = bar.titleTextAttributes 5 if attrs == nil { 6 attrs = [NSAttributedStringKey:Any]() 7 } 8 attrs?[NSAttributedStringKey.foregroundColor] = UIColor.white 9 bar.titleTextAttributes = attrs 10} ","link":"https://kikt.top/posts/ios/swift/swift-navigation-title-color-style/","section":"posts","tags":["iOS","swift","navigationbar"],"title":"swift navigation title 标题颜色代码设置"},{"body":"写在前面 在 ios11 中,navigationbar 的 leftItem 都会多出来一个奇怪的白边,这个白边很不容易修改,从前的设置方法失效了\n之前看到有篇文章是修改 layoutMargins 的方案来做的 这个方案设置虽然简单,但是有一个问题,就是当你 push,pop 以后,位置就变了,也就是说,layoutMargins 就失效了,而且需要遍历,采用 ContentView 的字符串\n另外有一个方案是采用自定义 NavigationBar 的方案来做的 也算是简单暴力\n我这里采用另一个方案来做,而且比较简单,也就是自定义 view 的方案的来做\n思路 UIBarButtonItem.init(customView: view)这种方式如果直接将 Button 放进去,那么你设置的 frame 的位置是无效的\n那么我这里采用另一个取巧的方案去做 众所周知,ios 中的控件摆放是可以超出父控件距离的,也就是说,我使用一个 UIView 包裹真正用于显示的 View,然后将子 View 的 x 设置偏移也就可以解决了\n实现 1 2import UIKit 3 4extension UIViewController{ 5 func setNavigatorLeftItem(customView:UIView) { 6 var view:UIView 7 if #available(iOS 11, *){ 8 let padding:CGFloat = 20 9 let frame = customView.frame 10 view = UIView(frame: CGRect(x: 0, y: 0, width: frame.width + padding, height: frame.height)) 11 customView.frame = customView.frame.offsetBy(dx: -padding, dy: 0) 12 view.addSubview(customView) 13 14 }else{ 15 view = customView 16 } 17 let item = UIBarButtonItem.init(customView: view) 18 self.navigationItem.leftBarButtonItem = item 19 } 20} 没错,代码就这么简单,没有别的代码\n当然也可以 extension NavigationItem 或者 NavigationBar,这个看自己的需求或者习惯了\n调用\n1import UIKit 2 3class CommonViewController : UIViewController{ 4 5 override func viewDidLoad() { 6 super.viewDidLoad() 7 let button = ImageButton.init(type: .custom) 8 button.rectPerfect = 0.8 9 button.image = ImageConst.Image.main_user_center.toUIImage() 10 let (_,height) = self.getNavigatorBarSize().getWidthAndSize() 11 let w = height / 102 * 120 12 let h = height 13 14 button.frame = CGRect(x: 5 ,y: 0,width: w,height: h) 15 16 self.setNavigatorLeftItem(customView: button) //调用extension的代码 17 } 18 19} 截图 说明 这里比较懒,只定义了左边的 item,右部的 item 同理,只是使用 rightItem 就可以了,padding 变成+ 而不是 - 就可以了 还可以抽象一个 enum 定义 left right,然后根据 left right 定义 padding 的正负,毕竟具体的实现都好说\n稀土连接 简书连接 ","link":"https://kikt.top/posts/ios/swift/swift-ios11-change-the-navigationbar-spacing/","section":"posts","tags":["iOS","swift","navigationbar"],"title":"Swift Ios11 修改navigationbar间距"},{"body":"起因 在引入新的依赖后,有时你会报一些冲突的错误,尤其是 v4 v7 库的使用\n有的时候能\u0026quot;自动\u0026quot;纠正,但是大部分时候不行\n比如 A 库引用了 v7 26.x.x 的库, B 库使用了 v7 27.x.x 作为依赖\n解决方案 gradle 打包的过程中,首先会加载所有 gradle 脚本到库内\n然后才是运行的过程, 所以我们只需要在 app 级的build.gradle中增加如下代码即可\n1rootProject.allprojects { // 闭包循环每个工程 2 3 subprojects { //每个工程子工程 4 project.configurations.all { //查找所有配置 5 resolutionStrategy.eachDependency { details -\u0026gt; //遍历所有依赖 6 if (details.requested.group == \u0026#39;com.android.support\u0026#39; 7 \u0026amp;\u0026amp; details.requested.name.contains(\u0026#39;appcompat-v7\u0026#39;)) { 8 details.useVersion \u0026#34;26.1.0\u0026#34; //将support包 v7替换为26.1.0 ,这里根据你自己的需要来改就可以了 9 } 10 } 11 } 12 } 13 14} ","link":"https://kikt.top/posts/android/android-repo-confire/","section":"posts","tags":["android","冲突"],"title":"android 依赖冲突"},{"body":"","link":"https://kikt.top/tags/ble/","section":"tags","tags":null,"title":"ble"},{"body":"swift 蓝牙连接 项目简介 最近公司要用到便携式蓝牙打印机进行打印\n打印机使用的 ECS/POS 指令集\nios 使用的 BLE 方案,安卓则是因为设备的原因只能选择普通蓝牙的连接方案\nBLE 蓝牙相关的概念性东西我这里就不说了 大家可以自己去搜索下\n有个 mac 的蓝牙开发工具 LightBlue,很好用,mac app store 自己下就好了,这个很方便你理解 BLE 的蓝牙相关 device(central/peripheral)-\u0026gt;services-\u0026gt;characteristics\n这里可以看到,有一个 mobike,有兴趣的同学可以研究下 mobike 的蓝牙连接 ☺ 说笑一下,人家肯定有安全性校验的\n语言选型 最近在学习 ios 开发,因为我是 android 出身,学习 ios 开发的时候 swift3 已经出现很久了,所以我这里使用的 swift 进行开发\n坑 1 最初我使用了厂家提供的 ios sdk 进行开发,其中封装了很多常用的方法,让我自己以为很简单就能完成,但是事实上是我太天真了,首先厂家提供的是.a 的库,只有一个.h 文件暴露在外,我的项目是纯 swift 项目,这就不可避免的使用到了 swift 到 oc 的桥接\n坑 2 满以为桥接完了调 SDK 方法就行,谁知道调用的时候根本就没反应,没办法,只能摸石头过河进行开发了,最初使用的是 oc 的 corebluetooth 方案,因为实在是没找到 swift 的相关说法,baidu 没搜到,没办法,oc 毕竟也算是入门了,直接开干了\n坑 3 开发完 oc 的连接 demo,强迫症发作,决定一定要用纯 swift 开发,毕竟我们还是要跟随时代脚步的嘛\n找文档 都说苹果的官方文档写的很好,那么我就上去看看吧,这里要吐槽一点,文档的方法,类描述确实很不错,看起来很清晰,但是但是..怎么没有告诉我 import 什么\nUIKit 里不包含 Bluetooth 相关的类,而官方中将这个定义在System体系的 Core Bluetooth 中\n使用\n1import CoreBluetooth 这样CBCentralManager终于可以用了\n正式开发 折腾了半天,终于可以开始开发了...\nmacos 模拟器蓝牙 central 这里要吐槽下公司,没有 ios 测试机,我自己又是安卓手机,没办法,这里有一招,建一个 macos 的项目,将UIKit换成Cocoa,或者Foundation,然后其他语法中 macos 和 ios 的蓝牙部分代码几乎一样,这样就能连接上打印机了,我这里又是模块开发,将数据部分的代码 copy 一份到 macos 的 demo 上,就能模拟真机的 mac 了\n上面说几乎一样的原因是,cm.isScanning在 mac 开发中用不了,ios 中可以\n当时记得苹果说 simulator 可以用 mac 的蓝牙开发,结果短短的一个版本以后就干掉了相关功能,真是狗\n帮助类的代码 1 2// 3// BluetoothHelper.swift 4// SwiftBluetoothScanDemo1 5// 6// Created by caijinglong on 2017/9/9. 7// 8 9import Foundation 10import CoreBluetooth 11 12protocol BluetoothHelperDelegate { 13 14 func bluetoothHelperIndex()-\u0026gt;Int 15 16 func bluetoothHelperNotifyConnected(isConnected:Bool) 17 18 func bluetoothHelperAutoStopScan() 19} 20 21class BluetoothHelper :NSObject,CBCentralManagerDelegate,CBPeripheralDelegate{ 22 23 static let shared = BluetoothHelper() 24 25 private var cm:CBCentralManager! = nil 26 private var peripheral: CBPeripheral! = nil 27 private var service:CBService! = nil 28 29 private var characteristic:CBCharacteristic! = nil 30 31 private var delegateDict = Dictionary\u0026lt;Int,BluetoothHelperDelegate\u0026gt;() 32 33 public func registerDelegate(delegate:BluetoothHelperDelegate){ 34 delegateDict[delegate.bluetoothHelperIndex()] = delegate 35 } 36 37 public func unregisterDelegate(delegate:BluetoothHelperDelegate){ 38 delegateDict.removeValue(forKey: delegate.bluetoothHelperIndex()) 39 } 40 41 private override init(){ 42 super.init() 43 self.cm = CBCentralManager(delegate: self, queue: nil) 44 } 45 46 /// 被连接的打印机的名字 47 var connectDeviceName:String? = \u0026#34;\u0026#34; 48 49 /// 是否连接了打印机 50 var isConnected:Bool = false{ 51 didSet{ 52 if(!isConnected){ 53 peripheral = nil 54 service = nil 55 characteristic = nil 56 connectDeviceName = nil 57 58 delegateDict.forEach({ (key,delegate) in 59 60 }) 61 }else{ 62 connectDeviceName = self.name 63 } 64 } 65 } 66 67 /// 蓝牙开关是否打开 68 var btOpen = false 69 private var name = \u0026#34;QSPrinter\u0026#34; 70 71 // 后面是代理方法 72 func centralManagerDidUpdateState(_ central: CBCentralManager) { 73 NSLog(\u0026#34;状态变化\u0026#34;) 74 if(central.state.rawValue == 5){ 75 btOpen = true 76 }else{ 77 btOpen = false 78 isConnected = false 79 } 80 } 81 82 /// 开始扫描设备 83 func startScan(name:String){ 84 self.name = name 85 self.cm.stopScan() 86 self.cm.scanForPeripherals(withServices: nil, options: nil) 87 runDelay(5) { 88 self.delegateDict.forEach({ (_,delegate) in 89 self.cm.stopScan() 90 delegate.bluetoothHelperAutoStopScan() 91 }) 92 } 93 } 94 95 /// 停止扫描设备 96 func stopScan(){ 97 self.cm.stopScan() 98 } 99 100 /// 关闭连接设备 101 func disconnect(){ 102 if(peripheral != nil){ 103 self.cm.cancelPeripheralConnection(peripheral) 104 } 105 } 106 107 func centralManager(_ central: CBCentralManager, didDiscover peripheral: CBPeripheral, advertisementData: [String: Any], rssi RSSI: NSNumber) { 108 NSLog(\u0026#34;\\(String(describing: peripheral.name)) is discovered\u0026#34;) 109 if(peripheral.name?.uppercased() == name.uppercased()){ 110 self.peripheral = peripheral 111 peripheral.delegate = self 112 cm.connect(peripheral) 113 cm.stopScan() 114 } 115 } 116 117 func centralManager(_ central: CBCentralManager, didConnect peripheral: CBPeripheral) { 118 NSLog(\u0026#34;\\(String(describing: peripheral.name)) 连接成功\u0026#34;) 119 let uuid = CBUUID(string: \u0026#34;18F0\u0026#34;) 120 peripheral.discoverServices([uuid]) 121 } 122 123 func centralManager(_ central: CBCentralManager, didDisconnectPeripheral peripheral: CBPeripheral, error: Error?) { 124 NSLog(\u0026#34;\\(String(describing: peripheral.name)) 连接断开\u0026#34;) 125 isConnected = false 126 } 127 128 func peripheral(_ peripheral: CBPeripheral, didDiscoverServices error: Error?) { 129 if let service = peripheral.services?[0]{ 130 let uuid = CBUUID(string: \u0026#34;2AF1\u0026#34;) 131 peripheral.discoverCharacteristics([uuid], for: service) 132 self.service = service 133 } 134 } 135 136 func peripheral(_ peripheral: CBPeripheral, didDiscoverCharacteristicsFor service: CBService, error: Error?) { 137 if let characteristic = service.characteristics?[0]{ 138 NSLog(\u0026#34;characteristic is prepared\u0026#34;) 139 isConnected = true 140 self.characteristic = characteristic 141 } 142 } 143 144 /// 输出字符串 145 func writeText(text:String)throws{ 146 let enc = CFStringConvertEncodingToNSStringEncoding(CFStringEncoding(CFStringEncodings.GB_18030_2000.rawValue)) 147 148 if let data = text.data(using: String.Encoding(rawValue: enc)){ 149 do { 150 try self.writeData(data: data) 151 } catch { 152 throw error 153 } 154 } 155 } 156 157 158 private var datas = [Data]() 159 160 /// 写入数据 161 func writeData(data:Data) throws { 162 if(isConnected){ 163 datas.append(data) 164 }else{ 165 throw BtError.NoConnectError 166 } 167 } 168 169 /// 真实的打印方法 170 func print(){ 171 for index in 0 ... datas.count - 1 { 172 let item = datas[index] 173 runDelay(0.02 * Double(index), { 174 self.peripheral.writeValue(item, for: self.characteristic, type: CBCharacteristicWriteType.withoutResponse) 175 }) 176 } 177 self.datas.removeAll() 178 } 179 180} 181 182enum BtError :Error{ 183 case NoConnectError 184} 分析下代码 这里使用单例的方案管理连接,实际上 BLE 支持同时连接多个外设,我这里是因为目前没有这样的需求,所以考虑使用单例的模式,看官请根据自己的需求来\ncentralManagerDidUpdateState这个代理方法很重要,是唯一一个必须实现的方法,用于监听蓝牙的状态,是一个 Int 类型的枚举值,这里因为 ios10 有一个过期相关的提示,替换了 state 相关的类由CBCentralManagerState替换到CBManagerState,值没有变化,就是由 oc 的枚举方式替换到了 swift 的枚举,这里我直接使用 5 来进行判断,ios11 也没看见修改这个数值,短时间内直接用 5 就行,后续有 bug 再说 这里用一个 property 来储存蓝牙状态\nstartScan其中是开始扫描的方法\n1 func startScan(name:String){ 2 self.name = name 3 self.cm.stopScan() 4 self.cm.scanForPeripherals(withServices: nil, options: nil) 5 runDelay(5) { 6 self.delegateDict.forEach({ (_,delegate) in 7 self.cm.stopScan() 8 delegate.bluetoothHelperAutoStopScan() 9 }) 10 } 11 } 先停止扫描,然后开始扫描,记录一下 name,后续会用到,5 秒后停止扫描,并代理通知\n1func centralManager(_ central: CBCentralManager, didDiscover peripheral: CBPeripheral, advertisementData: [String: Any], rssi RSSI: NSNumber) { 2 NSLog(\u0026#34;\\(String(describing: peripheral.name)) is discovered\u0026#34;) 3 if(peripheral.name?.uppercased() == name.uppercased()){ 4 self.peripheral = peripheral 5 peripheral.delegate = self 6 cm.connect(peripheral) 7 cm.stopScan() 8 } 9 } 10 11 func centralManager(_ central: CBCentralManager, didConnect peripheral: CBPeripheral) { 12 NSLog(\u0026#34;\\(String(describing: peripheral.name)) 连接成功\u0026#34;) 13 let uuid = CBUUID(string: \u0026#34;18F0\u0026#34;) 14 peripheral.discoverServices([uuid]) 15 } 这两个方法,第一个是扫描到了设备,这里我忽视大小写进行匹配,然后如果名字匹配则调用cm.connect(peripheral)进行连接,并且停止扫描\n第二个方法是连接成功,这里 18F0 是 service 的名称,就是扫描 UUID 为 18F0 的 services\n1 func peripheral(_ peripheral: CBPeripheral, didDiscoverServices error: Error?) { 2 if let service = peripheral.services?[0]{ 3 let uuid = CBUUID(string: \u0026#34;2AF1\u0026#34;) 4 peripheral.discoverCharacteristics([uuid], for: service) 5 self.service = service 6 } 7 } 这里是在扫描到 services 后的代理,然后扫描 uuid 为2AF1的 Characteristics 这里 service 保持引用\n1func peripheral(_ peripheral: CBPeripheral, didDiscoverCharacteristicsFor service: CBService, error: Error?) { 2 if let characteristic = service.characteristics?[0]{ 3 NSLog(\u0026#34;characteristic is prepared\u0026#34;) 4 isConnected = true 5 self.characteristic = characteristic 6 } 7 } 这里是扫描到 Characteristics 后的操作,这里我记录了一个连接状态 和 characteristic 的引用\n1self.peripheral.writeValue(item, for: self.characteristic, type: CBCharacteristicWriteType.withoutResponse)//item是Data 这个是真实的输出方法,这个输出方法使用了了之前的peripheral和characteristic 这里之所以要持有所有'中间'产物的引用是因为之前用 oc 写这个代码的时候因为没有持有 peripheral 的引用报错,导致代理获取不到数据\n详细分析写数据 这里我使用了一个方案来写\n1 /// 输出字符串 2 func writeText(text:String)throws{ 3 let enc = CFStringConvertEncodingToNSStringEncoding(CFStringEncoding(CFStringEncodings.GB_18030_2000.rawValue)) 4 5 if let data = text.data(using: String.Encoding(rawValue: enc)){ 6 do { 7 try self.writeData(data: data) 8 } catch { 9 throw error 10 } 11 } 12 } 13 14 15 private var datas = [Data]() 16 17 /// 写入数据 18 func writeData(data:Data) throws { 19 if(isConnected){ 20 datas.append(data) 21 }else{ 22 throw BtError.NoConnectError 23 } 24 } 25 26 /// 真实的打印方法 27 func print(){ 28 for index in 0 ... datas.count - 1 { 29 let item = datas[index] 30 runDelay(0.02 * Double(index), { 31 self.peripheral.writeValue(item, for: self.characteristic, type: CBCharacteristicWriteType.withoutResponse) 32 }) 33 } 34 self.datas.removeAll() 35 } 1func runDelay(_ delay:TimeInterval,_ block:@escaping () -\u0026gt; ()){ 2 let queue = DispatchQueue.main 3 4 let delayTime = DispatchTime.now() + delay 5 6 queue.asyncAfter(deadline: delayTime) { 7 block() 8 } 9} 这里的思路大概是: 首先一个容器用于储存顺序存入的数据,然后在调用print的时候将所有数据进行输出,并且延迟一定的时间,每个输出时间间隔 0.02s\n之所以这么做的原因是:我当时直接调用writeValue方法写数据,没有间隔时间,发现会出现样式错误,输出顺序错误的情况发生\n这个时候我凭感觉认为是发生了writeValue和实际通讯的到达顺序不一致的问题,我查了下,BLE 主打的是低延迟,但是对应的数据通讯的数据量就有了限制,所以采用这个方案\n当然我也试过使用一个 Data 储存所有字节数据的方案,发现打印机无法打印,具体原因没有深究\n打印相关 编码问题 一般的蓝牙打印机中文使用的是 GBK 编码,ios 中是 GB_18030_2000,而 ios 默认是 utf8 编码,所以这里需要显示指定\n关于二维码 打印二维码使用的是 ESC/POS 的指令集,这个在指令集的说明文档中可以找到\n这里的 moduleSize 是二维码的大小,具体参数可以参考说明文档,一般对接的打印机厂商都会提供\n一般的打印机中文都是 GBK 编码的,而扫码一般是 UTF8 编码,这个编码转换很麻烦,所以尽量不要出现中文\n打印机发送指令\n1// 2// PrinterHelper.swift 3// SwiftBluetoothScanDemo1 4// 5// Created by Caijinglong on 2017/9/11. 6// 7 8import Foundation 9 10/// printer helper 11/// 12/// single instance 13class PrinterHelper{ 14 15 static var shared:PrinterHelper = PrinterHelper() 16 17 var helper : BluetoothHelper! 18 19 // var devices = [Printer]() 20 21 private init(){ 22 helper = BluetoothHelper.shared 23 } 24 25 func registerDelegate(delegate: BluetoothHelperDelegate){ 26 helper.registerDelegate(delegate: delegate) 27 } 28 29 func unregisterDelegate(delegate: BluetoothHelperDelegate){ 30 helper.unregisterDelegate(delegate: delegate) 31 } 32 33 var index = 0 34 35 let DIVIDER = \u0026#34;-----------------------------------------------\u0026#34; 36 let ESC: Byte = 27//换码 37 let FS: Byte = 28//文本分隔符 38 let GS: Byte = 29//组分隔符 39 let DLE: Byte = 16//数据连接换码 40 let EOT: Byte = 4//传输结束 41 let ENQ: Byte = 5//询问字符 42 let SP: Byte = 32//空格 43 let HT: Byte = 9//横向列表 44 let LF: Byte = 10//打印并换行（水平定位） 45 let CR: Byte = 13//归位键 46 let FF: Byte = 12//走纸控制（打印并回到标准模式（在页模式下） 47 let CAN: Byte = 24//作废（页模式下取消打印数据 ） 48 49 func conn(deviceName:String){ 50 helper.startScan(name: deviceName) 51 } 52 53 func disconnect(){ 54 helper.disconnect() 55 } 56 57 func sendMsg(msg:String) -\u0026gt; Self{ 58 try? helper.writeText(text: msg) 59 return self 60 } 61 62 func sendBytes(bytes:[Byte]) -\u0026gt; Self{ 63 try? helper.writeData(data: Data.bytesArray(byteArray: bytes)) 64 return self 65 } 66 67 func sendHex(int:Int) -\u0026gt; Self { 68 return self.sendHexs(hexInt: int) 69 } 70 71 func sendHexs(hexInt ints:Int...) -\u0026gt; Self{ 72 var data = Data() 73 ints.forEach { (int) in 74 data.append(UInt8(int)) 75 } 76 try? helper.writeData(data: data) 77 return self 78 } 79 80 func sendBytes(bytes:Byte...) -\u0026gt; Self{ 81 return sendBytes(bytes: bytes) 82 } 83 84 func alignLeft()-\u0026gt; Self{ 85 return sendBytes(bytes: ESC,97,0) 86 } 87 88 func alignCenter() -\u0026gt; Self { 89 return sendBytes(bytes: ESC,97,1) 90 } 91 92 func alignRight() -\u0026gt; Self{ 93 return sendBytes(bytes: ESC,97,2) 94 } 95 96 func printDivider() -\u0026gt; Self { 97 return sendMsg(msg: DIVIDER) 98 } 99 100 101 func startPrint(){ 102 helper.print() 103 } 104 105 func setFontSize(size:Int) -\u0026gt; Self{ 106 var realSize: Byte = 0 107 108 if(size \u0026lt;= 7){ 109 realSize = Byte(size * 17) 110 } 111 112 var result = [Byte]() 113 result.append(0x1D) 114 result.append(0x21) 115 result.append(realSize) 116 print(\u0026#34;size = \\(size) realSize = \\(realSize)\u0026#34;) 117 return sendBytes(bytes: result) 118 } 119 120 func newLine(lines:Int = 1) -\u0026gt; Self{ 121 for _ in 0...lines - 1{ 122 _ = sendHex(int: 0x0A) 123 } 124 return self 125 } 126 127 /** 128 * 选择加粗模式 129 130 * @return 131 */ 132 func boldOn() -\u0026gt; Self { 133 var result = [Byte]() 134 result.append(ESC) 135 result.append(69) 136 result.append(0xF) 137 return sendBytes(bytes: result) 138 } 139 140 141 /** 142 * 取消加粗模式 143 144 * @return 145 */ 146 func boldOff() -\u0026gt; Self { 147 var result = [Byte]() 148 result.append(ESC) 149 result.append(69) 150 result.append(0) 151 return sendBytes(bytes: result) 152 } 153 154 func subTitle(_ title:String) -\u0026gt; Self{ 155 return 156 self.newLine() 157 .setFontSize(size: 1) 158 .boldOn() 159 .alignCenter() 160 .sendMsg(msg: title) 161 .setFontSize(size: 0) 162 .boldOff() 163 } 164 165 func sendQrcode(qrcode:String) -\u0026gt; Self{ 166 let moduleSize:Byte = 8 167 var list = [Byte]() 168 169 if let data = Data.gbkData(text: qrcode){ 170 171 //打印二维码矩阵 172 list.append(0x1D)// init 173 list.append(40) // adjust height of barcode 174 list.append(107)// adjust height of barcode 175 list.append(Byte(data.count + 3)) // pl 176 list.append(0) // ph 177 list.append(49) // cn 178 list.append(80) // fn 179 list.append(48) // 180 181 data.forEach({ (char) in 182 list.append(char) 183 }) 184 185 list.append(0x1D) 186 list.append(40)// list.append(\u0026#34;(k\u0026#34;) 187 list.append(107)// list.append(\u0026#34;(k\u0026#34;) 188 list.append(3) 189 list.append(0) 190 list.append(49) 191 list.append(69) 192 list.append(48) 193 194 list.append(0x1D) 195 list.append(40)// list.append(\u0026#34;(k\u0026#34;) 196 list.append(107)// list.append(\u0026#34;(k\u0026#34;) 197 list.append(3) 198 list.append(0) 199 list.append(49) 200 list.append(67) 201 list.append(moduleSize) 202 203 list.append(0x1D) 204 list.append(40)// list.append(\u0026#34;(k\u0026#34;) 205 list.append(107)// list.append(\u0026#34;(k\u0026#34;) 206 list.append(3) // pl 207 list.append(0) // ph 208 list.append(49) // cn 209 list.append(81) // fn 210 list.append(48) // m 211 } 212 213 return 214 alignCenter() 215 .sendBytes(bytes: list) 216 } 217} 蓝牙连接的类\n1// 2// BluetoothHelper.swift 3// SwiftBluetoothScanDemo1 4// 5// Created by caijinglong on 2017/9/9. 6// Copyright © 2017 sxw. All rights reserved. 7// 8 9import Foundation 10import CoreBluetooth 11 12protocol BluetoothHelperDelegate:NSObjectProtocol { 13 14 func bluetoothHelperIndex()-\u0026gt;Int 15 16 func bluetoothHelperNotifyConnected(isConnected:Bool) 17 18 func bluetoothHelperAutoStopScan() 19 20 func bluetoothHelperFindDevices(name:String) 21} 22 23extension BluetoothHelperDelegate{ 24 func bluetoothHelperFindDevices(name:String){ 25 } 26} 27 28protocol BluetoothHelperScanDeviceDelegate { 29 func bluetoothScan(peripheral: CBPeripheral) 30 31 func bluetoothHelperIndex()-\u0026gt;Int 32 33 func bluetoothConnected(name:String) 34 35 func bluetoothDisconnect(name:String) 36} 37 38extension BluetoothHelperScanDeviceDelegate{ 39 func bluetoothConnected(name:String){} 40 41 func bluetoothDisconnect(name:String){} 42} 43 44class BluetoothHelper :NSObject,CBCentralManagerDelegate,CBPeripheralDelegate{ 45 46 static let shared = BluetoothHelper() 47 48 private var cm:CBCentralManager! = nil 49 private var peripheral: CBPeripheral! = nil 50 private var service:CBService! = nil 51 52 private var characteristic:CBCharacteristic! = nil 53 54 private var delegateDict = Dictionary\u0026lt;Int,BluetoothHelperDelegate\u0026gt;() 55 56 private var scanDelegateDict = Dictionary\u0026lt;Int,BluetoothHelperScanDeviceDelegate\u0026gt;() 57 58 public func registerDelegate(delegate:BluetoothHelperDelegate){ 59 delegateDict[delegate.bluetoothHelperIndex()] = delegate 60 } 61 62 public func unregisterDelegate(delegate:BluetoothHelperDelegate){ 63 delegateDict.removeValue(forKey: delegate.bluetoothHelperIndex()) 64 } 65 66 public func registerScanDelegate(delegate:BluetoothHelperScanDeviceDelegate){ 67 scanDelegateDict[delegate.bluetoothHelperIndex()] = delegate 68 } 69 70 public func unregisterScanDelegate(delegate:BluetoothHelperScanDeviceDelegate){ 71 delegateDict.removeValue(forKey: delegate.bluetoothHelperIndex()) 72 } 73 74 private override init(){ 75 super.init() 76 self.cm = CBCentralManager(delegate: self, queue: nil) 77 } 78 79 /// 被连接的打印机的名字 80 var connectDeviceName:String? = \u0026#34;\u0026#34; 81 82 /// 是否连接了打印机 83 var isConnected:Bool = false{ 84 didSet{ 85 if(!isConnected){ 86 peripheral = nil 87 service = nil 88 characteristic = nil 89 90 delegateDict.forEach({ (key,delegate) in 91 delegate.bluetoothHelperNotifyConnected(isConnected: false) 92 }) 93 connectDeviceName = nil 94 }else{ 95 connectDeviceName = self.name 96 97 delegateDict.forEach({ (key,delegate) in 98 delegate.bluetoothHelperNotifyConnected(isConnected: true) 99 }) 100 } 101 } 102 } 103 104 /// 蓝牙开关是否打开 105 var btOpen = false 106 private var name = \u0026#34;QSPrinter\u0026#34; 107 108 // 后面是代理方法 109 func centralManagerDidUpdateState(_ central: CBCentralManager) { 110 NSLog(\u0026#34;状态变化: state = \\(central.state.rawValue)\u0026#34;) 111 if(central.state.rawValue == 5){ 112 btOpen = true 113 }else{ 114 btOpen = false 115 isConnected = false 116 } 117 } 118 119 /// 仅扫描 120 func startScan(){ 121 self.name = \u0026#34;\u0026#34; 122 self.cm.stopScan() 123 self.cm.scanForPeripherals(withServices: nil, options: nil) 124 runDelay(5) { 125 self.delegateDict.forEach({ (_,delegate) in 126 delegate.bluetoothHelperAutoStopScan() 127 }) 128 } 129 } 130 131 /// 开始扫描设备 132 func startScan(name:String){ 133 self.name = name 134 self.cm.stopScan() 135 self.cm.scanForPeripherals(withServices: nil, options: nil) 136 runDelay(5) { 137 self.delegateDict.forEach({ (_,delegate) in 138 self.cm.stopScan() 139 delegate.bluetoothHelperAutoStopScan() 140 }) 141 } 142 } 143 144 /// 停止扫描设备 145 func stopScan(){ 146 self.cm.stopScan() 147 } 148 149 /// 关闭连接设备 150 func disconnect(){ 151 if(peripheral != nil){ 152 self.cm.cancelPeripheralConnection(peripheral) 153 } 154 } 155 156 /// 扫描到设备 157 func centralManager(_ central: CBCentralManager, didDiscover peripheral: CBPeripheral, advertisementData: [String: Any], rssi RSSI: NSNumber) { 158 NSLog(\u0026#34;\\(String(describing: peripheral.name)) is discovered\u0026#34;) 159 if(peripheral.name == nil){ 160 return 161 } 162 163 scanDelegateDict.forEach { (_,delegate) in 164 delegate.bluetoothScan(peripheral: peripheral) 165 } 166 167 168 if(self.name.isEmpty){ 169 return 170 } 171 172 if(peripheral.name?.uppercased() == name.uppercased()){ 173 self.connect(peripheral: peripheral) 174 } 175 } 176 177 /// 连接peripheral 178 func connect(peripheral:CBPeripheral){ 179 self.peripheral = peripheral 180 peripheral.delegate = self 181 cm.connect(peripheral) 182 cm.stopScan() 183 } 184 185 /// 连接成功后 186 func centralManager(_ central: CBCentralManager, didConnect peripheral: CBPeripheral) { 187 NSLog(\u0026#34;\\(String(describing: peripheral.name)) 连接成功\u0026#34;) 188 let uuid = CBUUID(string: \u0026#34;18F0\u0026#34;) 189 peripheral.discoverServices([uuid]) 190 191 scanDelegateDict.forEach { (_,delegate) in 192 delegate.bluetoothConnected(name: name) 193 } 194 } 195 196 /// 断开连接后 197 func centralManager(_ central: CBCentralManager, didDisconnectPeripheral peripheral: CBPeripheral, error: Error?) { 198 NSLog(\u0026#34;\\(String(describing: peripheral.name)) 连接断开\u0026#34;) 199 scanDelegateDict.forEach { (_,delegate) in 200 delegate.bluetoothDisconnect(name: name) 201 } 202 isConnected = false 203 } 204 205 /// 扫描设备的services 206 func peripheral(_ peripheral: CBPeripheral, didDiscoverServices error: Error?) { 207 if let service = peripheral.services?[0]{ 208 let uuid = CBUUID(string: \u0026#34;2AF1\u0026#34;) 209 peripheral.discoverCharacteristics([uuid], for: service) 210 self.service = service 211 } 212 } 213 214 /// 扫描service的characteristics 215 func peripheral(_ peripheral: CBPeripheral, didDiscoverCharacteristicsFor service: CBService, error: Error?) { 216 if let characteristic = service.characteristics?[0]{ 217 NSLog(\u0026#34;characteristic is prepared\u0026#34;) 218 isConnected = true 219 self.characteristic = characteristic 220 } 221 } 222 223 /// 输出字符串 224 func writeText(text:String)throws{ 225 let enc = CFStringConvertEncodingToNSStringEncoding(CFStringEncoding(CFStringEncodings.GB_18030_2000.rawValue)) 226 227 if let data = text.data(using: String.Encoding(rawValue: enc)){ 228 do { 229 try self.writeData(data: data) 230 } catch { 231 throw error 232 } 233 } 234 } 235 236 /// 输出二进制 237 func writeBytes(){ 238 239 } 240 241 private var lock = NSLock() 242 private var isWritering = false 243 244 private var tempData = Data() 245 246 private var datas = [Data]() 247 248 /// 写入数据 249 func writeData(data:Data) throws { 250 if(isConnected){ 251// lock.lock(before: Date()) 252 tempData.append(data) 253 datas.append(data) 254 }else{ 255 throw BtError.NoConnectError 256 } 257 } 258 259 /// 真实的打印方法 260 func print(){ 261// NSLog(\u0026#34;printdata : \\(tempData)\u0026#34;) 262 for index in 0 ... datas.count - 1 { 263 let item = datas[index] 264 runDelay(0.02 * Double(index), { 265 self.peripheral.writeValue(item, for: self.characteristic, type: CBCharacteristicWriteType.withoutResponse) 266 }) 267 } 268 self.datas.removeAll() 269 } 270 271 private func _realWriterData(data:Data) { 272 if(isConnected){ 273 NSLog(\u0026#34;real write data : \\(data)\u0026#34;) 274 self.peripheral.writeValue(data, for: self.characteristic, type: CBCharacteristicWriteType.withoutResponse) 275 }else{ 276 277 } 278 } 279} 280 281enum BtError :Error{ 282 case NoConnectError 283} ##　后记 这里的代码是我测试项目中使用的,因为是我独立开发,所以有的代码比较乱,敬请见谅\n蓝牙打印机连接本身不算什么高深的操作，只是其中的回调比较复杂,看起来麻烦,这里我也没讲什么概念性的东西,主要就是讲解下代码和实现步骤啥的 搞清楚了蓝牙外设提供的服务有什么,如何连接,另外需要注意的是 CBCharacteristicWriteType.withoutResponse,还有一个有回应的是,这里就看蓝牙设备本身如何设定的了\n这里读取暂时没涉及到,有需要的同学自己研究下吧\n最后祝大家都能顺利的完成自己的蓝牙连接!!\n","link":"https://kikt.top/posts/ios/swift/swift-connect-ble-printer/","section":"posts","tags":["iOS","swift","ble"],"title":"Swift连接BLE蓝牙打印机"},{"body":"","link":"https://kikt.top/tags/flexmark/","section":"tags","tags":null,"title":"flexmark"},{"body":"","link":"https://kikt.top/categories/spring/","section":"categories","tags":null,"title":"spring"},{"body":"写在前面 主要技术点:使用 thymeleaf+flexmark 渲染模板渲染 markdown 文件 ,highlight 渲染代码高亮 thymeleaf 模板负责渲染页面 flexmark 是 java 语言编写,负责将数据库中的 markdown 语法文本转为 html 文本 highlight 负责渲染 code 部分的代码,是一款 js+css 库\n步骤 首先定义一个 controller 和 requstmapping\n1package com.kikt.web.ctl.blog; 2 3import com.kikt.service.markdown.MarkdownService; 4import com.sun.org.apache.xpath.internal.operations.Mod; 5import org.springframework.beans.factory.annotation.Autowired; 6import org.springframework.stereotype.Controller; 7import org.springframework.ui.Model; 8import org.springframework.web.bind.annotation.RequestMapping; 9import org.springframework.web.bind.annotation.RequestMethod; 10import org.springframework.web.bind.annotation.RequestParam; 11import org.springframework.web.bind.annotation.RequestPart; 12 13/** 14 * Created by cai on 2017/8/25. 15 */ 16@Controller 17@RequestMapping(\u0026#34;/md\u0026#34;) 18public class MarkdownCtl { 19 20 @Autowired 21 private MarkdownService service; 22 23 @RequestMapping(value = \u0026#34;/parse\u0026#34;, method = RequestMethod.POST) 24 public String parseMarkDown(Model model, @RequestParam(\u0026#34;md\u0026#34;) String markdownText) { 25 model.addAttribute(\u0026#34;md\u0026#34;, service.parseMarkdownString(markdownText)); 26 return \u0026#34;test\u0026#34;; 27 } 28 29 @RequestMapping(value = \u0026#34;/index\u0026#34;, method = RequestMethod.GET) 30 public String index(Model model) { 31 model.addAttribute(\u0026#34;inputName\u0026#34;, \u0026#34;md\u0026#34;); 32 return \u0026#34;markdown\u0026#34;; 33 } 34 35} 在 static/templates 下定义一个文件,markdown.html\n这样当访问 http://localhost:8080/md/index的时候,就会跳转到index页面中\n1\u0026lt;!DOCTYPE html\u0026gt; 2\u0026lt;html 3 xmlns:th=\u0026#34;http://www.thymeleaf.org\u0026#34; 4 xmlns:sec=\u0026#34;http://www.thymeleaf.org/thymeleaf-extras-springsecurity3\u0026#34; 5\u0026gt; 6 \u0026lt;head\u0026gt; 7 \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; 8 \u0026lt;script type=\u0026#34;text/javascript\u0026#34; th:src=\u0026#34;@{/js/jquery-3.2.1.min.js}\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 9 \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; 10 $(document).ready({}); 11 \u0026lt;/script\u0026gt; 12 \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; 13 \u0026lt;title\u0026gt;Title\u0026lt;/title\u0026gt; 14 \u0026lt;/head\u0026gt; 15 \u0026lt;body\u0026gt; 16 \u0026lt;form method=\u0026#34;post\u0026#34; action=\u0026#34;./parse\u0026#34;\u0026gt; 17 \u0026lt;div\u0026gt; 18 \u0026lt;textarea 19 th:name=\u0026#34;${inputName}\u0026#34; 20 title=\u0026#34;md\u0026#34; 21 th:width=\u0026#34;200px\u0026#34; 22 th:height=\u0026#34;300px\u0026#34; 23 /\u0026gt; 24 \u0026lt;button type=\u0026#34;submit\u0026#34;\u0026gt;提交\u0026lt;/button\u0026gt; 25 \u0026lt;/div\u0026gt; 26 \u0026lt;/form\u0026gt; 27 \u0026lt;/body\u0026gt; 28\u0026lt;/html\u0026gt; 其中很简单,就定义了一个表单,表单中有一个输入框和一个提交按钮,这里模拟的是一个 post 提交表单的过程,提交的 url 为/parse 也就是/md/parse,对应的就是指向 test.html\n1\u0026lt;!DOCTYPE html\u0026gt; 2\u0026lt;html 3 xmlns:th=\u0026#34;http://www.thymeleaf.org\u0026#34; 4 xmlns:sec=\u0026#34;http://www.thymeleaf.org/thymeleaf-extras-springsecurity3\u0026#34; 5\u0026gt; 6 \u0026lt;head\u0026gt; 7 \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width,initial-scale=1\u0026#34; /\u0026gt; 8 \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; 9 \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; th:href=\u0026#34;@{/highlight/styles/default.css}\u0026#34; /\u0026gt; 10 \u0026lt;script th:src=\u0026#34;@{/highlight/highlight.pack.js}\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 11 \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; type=\u0026#34;text/css\u0026#34; th:href=\u0026#34;@{/css/markdown.css}\u0026#34; /\u0026gt; 12 \u0026lt;script type=\u0026#34;text/javascript\u0026#34; th:src=\u0026#34;@{/js/jquery-3.2.1.min.js}\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 13 \u0026lt;script th:inline=\u0026#34;javascript\u0026#34; type=\u0026#34;text/javascript\u0026#34;\u0026gt; 14 $(document).ready(function () { 15 var a = [[${md}]] 16 $(\u0026#34;#div\u0026#34;).html(a) 17 $(\u0026#39;pre code\u0026#39;).each(function(i, block) { 18 hljs.highlightBlock(block); 19 }); 20 }) 21 \u0026lt;/script\u0026gt; 22 \u0026lt;title\u0026gt;Title\u0026lt;/title\u0026gt; 23 \u0026lt;/head\u0026gt; 24 \u0026lt;body\u0026gt; 25 \u0026lt;div id=\u0026#34;div\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; 26 \u0026lt;/body\u0026gt; 27\u0026lt;/html\u0026gt; 再来看下 js 中的代码是在后台定义的 attr,名字为 md,来源是 service service 的代码如下:\n1package com.kikt.service.markdown 2 3import com.kikt.ext.logger 4import com.vladsch.flexmark.html.HtmlRenderer 5import com.vladsch.flexmark.parser.Parser 6import com.vladsch.flexmark.util.options.MutableDataSet 7import org.springframework.stereotype.Service 8 9/** 10 * Created by cai on 2017/8/25. 11 */ 12@Service 13open class MarkdownService { 14 15 fun parseMarkdownString(markdown: String): String { 16 val options = MutableDataSet() 17 val parser = Parser.builder(options).build() 18 val renderer = HtmlRenderer.builder(options).build() 19 val document = parser.parse(markdown) 20 val html = renderer.render(document) 21 logger.info(\u0026#34;parse html = $html\u0026#34;) 22 return html 23 } 24 25} 就是定义一个了第三方的 markdown 解析器,传入前端页面,再由前端页面通过 js 进行渲染 markdown.css 是我自己定义的一些渲染规则\n1blockquote { 2 font: 18px normal helvetica, sans-serif; 3 margin-top: 10px; 4 margin-bottom: 10px; 5 margin-left: 10px; 6 padding-left: 8px; 7 border-left: 9px solid #ccc; 8} 9 10pre { 11 font: 14px normal helvetica, sans-serif; 12 background-color: #efefef; 13 color: #333333; 14 margin-left: 5px; 15 padding: 10px; 16 margin-right: 30px; 17} 18 19a { 20 font: 16px normal helvetica, sans-serif; 21} 22 23blockquote p { 24 font-size: 18px; 25 margin-left: 0px; 26} 27 28p { 29 font-size: 14px; 30 margin-left: 10px; 31} 32 33p code { 34 background-color: #ededef; 35} 第三方库来源及用途 模板 用于渲染 java 中的视图层 java 中的库,用于转化 markdown 语法到 html 语法 java 的轻应用构建框架 高亮 pre 中的 code 语法 前端都知道的 js 框架\n截图 后记 也没什么创新可言,主要就是做一个小技术点的总结\n其实更节省资源的做法是将 markdown 从文本到 html 的语法全部交给前端解决,后端只负责储存,这样将解析的过程交给每个浏览器去解决是个更好的解决思路,这样的好处就是不论什么浏览器都可以正常的渲染出 markdown\n","link":"https://kikt.top/posts/server/java/spring-boot/template/","section":"posts","tags":["sprintboot","java","渲染","server","thymeleaf","flexmark"],"title":"spring boot 渲染md格式模板"},{"body":"","link":"https://kikt.top/tags/sprintboot/","section":"tags","tags":null,"title":"sprintboot"},{"body":"","link":"https://kikt.top/tags/thymeleaf/","section":"tags","tags":null,"title":"thymeleaf"},{"body":"","link":"https://kikt.top/tags/%E6%B8%B2%E6%9F%93/","section":"tags","tags":null,"title":"渲染"},{"body":"前言 在业内，扫码登陆不是什么新技术了，我这里主要是想自己实现一下这个功能，用的是简单实现，提供的只是思路 具体可以参考网上的其他文章 开发环境 mac+idea+paw+chrome+mysql 开发语言:java+kotlin mac:我的开发系统 idea:开发工具 paw:http调试工具 插一句 开发语言使用kotlin是有原因,kotlin是构建在jvm上的,而且有很多很方便的语法糖,敲代码速度很快 启动项目 首先配置一个 spring boot 的项目,这里使用 maven 构建的方案,因为我这里使用 gradle 构建总是会出现各种奇怪的问题\npom.xml\n1\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; 2\u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; 3 xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; 4 \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; 5 6 \u0026lt;groupId\u0026gt;com.kikt\u0026lt;/groupId\u0026gt; 7 \u0026lt;artifactId\u0026gt;myapp\u0026lt;/artifactId\u0026gt; 8 \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; 9 \u0026lt;!--\u0026lt;packaging\u0026gt;war\u0026lt;/packaging\u0026gt;--\u0026gt; 10 \u0026lt;packaging\u0026gt;war\u0026lt;/packaging\u0026gt; 11 12 \u0026lt;name\u0026gt;myapp\u0026lt;/name\u0026gt; 13 \u0026lt;description\u0026gt;MyApp\u0026lt;/description\u0026gt; 14 15 \u0026lt;parent\u0026gt; 16 \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; 17 \u0026lt;artifactId\u0026gt;spring-boot-starter-parent\u0026lt;/artifactId\u0026gt; 18 \u0026lt;version\u0026gt;1.5.4.RELEASE\u0026lt;/version\u0026gt; 19 \u0026lt;relativePath/\u0026gt; \u0026lt;!-- lookup parent from repository --\u0026gt; 20 \u0026lt;/parent\u0026gt; 21 22 \u0026lt;properties\u0026gt; 23 \u0026lt;project.build.sourceEncoding\u0026gt;UTF-8\u0026lt;/project.build.sourceEncoding\u0026gt; 24 \u0026lt;project.reporting.outputEncoding\u0026gt;UTF-8\u0026lt;/project.reporting.outputEncoding\u0026gt; 25 \u0026lt;java.version\u0026gt;1.8\u0026lt;/java.version\u0026gt; 26 \u0026lt;kotlin.version\u0026gt;1.1.3-2\u0026lt;/kotlin.version\u0026gt; 27 \u0026lt;/properties\u0026gt; 28 29 \u0026lt;dependencies\u0026gt; 30 \u0026lt;!--\u0026lt;dependency\u0026gt;--\u0026gt; 31 \u0026lt;!--\u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;--\u0026gt; 32 \u0026lt;!--\u0026lt;artifactId\u0026gt;spring-boot-starter-data-jpa\u0026lt;/artifactId\u0026gt;--\u0026gt; 33 \u0026lt;!--\u0026lt;/dependency\u0026gt;--\u0026gt; 34 \u0026lt;dependency\u0026gt; 35 \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; 36 \u0026lt;artifactId\u0026gt;spring-boot-starter-data-rest\u0026lt;/artifactId\u0026gt; 37 \u0026lt;/dependency\u0026gt; 38 \u0026lt;dependency\u0026gt; 39 \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; 40 \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; 41 \u0026lt;/dependency\u0026gt; 42 43 \u0026lt;dependency\u0026gt; 44 \u0026lt;groupId\u0026gt;mysql\u0026lt;/groupId\u0026gt; 45 \u0026lt;artifactId\u0026gt;mysql-connector-java\u0026lt;/artifactId\u0026gt; 46 \u0026lt;scope\u0026gt;runtime\u0026lt;/scope\u0026gt; 47 \u0026lt;/dependency\u0026gt; 48 49 \u0026lt;dependency\u0026gt; 50 \u0026lt;groupId\u0026gt;com.alibaba\u0026lt;/groupId\u0026gt; 51 \u0026lt;artifactId\u0026gt;druid\u0026lt;/artifactId\u0026gt; 52 \u0026lt;version\u0026gt;1.1.0\u0026lt;/version\u0026gt; 53 \u0026lt;/dependency\u0026gt; 54 55 \u0026lt;dependency\u0026gt; 56 \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; 57 \u0026lt;artifactId\u0026gt;spring-boot-starter-tomcat\u0026lt;/artifactId\u0026gt; 58 \u0026lt;!--\u0026lt;scope\u0026gt;provided\u0026lt;/scope\u0026gt;--\u0026gt; 59 \u0026lt;/dependency\u0026gt; 60 \u0026lt;dependency\u0026gt; 61 \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; 62 \u0026lt;artifactId\u0026gt;spring-boot-starter-actuator\u0026lt;/artifactId\u0026gt; 63 \u0026lt;!--\u0026lt;scope\u0026gt;provided\u0026lt;/scope\u0026gt;--\u0026gt; 64 \u0026lt;/dependency\u0026gt; 65 \u0026lt;dependency\u0026gt; 66 \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; 67 \u0026lt;artifactId\u0026gt;spring-boot-starter-test\u0026lt;/artifactId\u0026gt; 68 \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; 69 \u0026lt;/dependency\u0026gt; 70 71 \u0026lt;!-- https://mvnrepository.com/artifact/org.mybatis.spring.boot/mybatis-spring-boot-starter --\u0026gt; 72 \u0026lt;!--\u0026lt;dependency\u0026gt;--\u0026gt; 73 \u0026lt;!--\u0026lt;groupId\u0026gt;org.mybatis.spring.boot\u0026lt;/groupId\u0026gt;--\u0026gt; 74 \u0026lt;!--\u0026lt;artifactId\u0026gt;mybatis-spring-boot-starter\u0026lt;/artifactId\u0026gt;--\u0026gt; 75 \u0026lt;!--\u0026lt;version\u0026gt;1.3.0\u0026lt;/version\u0026gt;--\u0026gt; 76 \u0026lt;!--\u0026lt;/dependency\u0026gt;--\u0026gt; 77 78 79 \u0026lt;dependency\u0026gt; 80 \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; 81 \u0026lt;artifactId\u0026gt;spring-boot-starter-aop\u0026lt;/artifactId\u0026gt; 82 \u0026lt;/dependency\u0026gt; 83 84 \u0026lt;dependency\u0026gt; 85 \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; 86 \u0026lt;artifactId\u0026gt;spring-boot-starter-data-jpa\u0026lt;/artifactId\u0026gt; 87 \u0026lt;version\u0026gt;1.5.4.RELEASE\u0026lt;/version\u0026gt; 88 \u0026lt;/dependency\u0026gt; 89 90 \u0026lt;dependency\u0026gt; 91 \u0026lt;groupId\u0026gt;org.jetbrains.kotlin\u0026lt;/groupId\u0026gt; 92 \u0026lt;artifactId\u0026gt;kotlin-stdlib-jre8\u0026lt;/artifactId\u0026gt; 93 \u0026lt;version\u0026gt;${kotlin.version}\u0026lt;/version\u0026gt; 94 \u0026lt;/dependency\u0026gt; 95 \u0026lt;dependency\u0026gt; 96 \u0026lt;groupId\u0026gt;org.jetbrains.kotlin\u0026lt;/groupId\u0026gt; 97 \u0026lt;artifactId\u0026gt;kotlin-test\u0026lt;/artifactId\u0026gt; 98 \u0026lt;version\u0026gt;${kotlin.version}\u0026lt;/version\u0026gt; 99 \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; 100 \u0026lt;/dependency\u0026gt; 101 \u0026lt;!-- https://mvnrepository.com/artifact/com.alibaba/fastjson --\u0026gt; 102 \u0026lt;dependency\u0026gt; 103 \u0026lt;groupId\u0026gt;com.alibaba\u0026lt;/groupId\u0026gt; 104 \u0026lt;artifactId\u0026gt;fastjson\u0026lt;/artifactId\u0026gt; 105 \u0026lt;version\u0026gt;1.2.35\u0026lt;/version\u0026gt; 106 \u0026lt;/dependency\u0026gt; 107 108 \u0026lt;!-- https://mvnrepository.com/artifact/org.json/json --\u0026gt; 109 \u0026lt;dependency\u0026gt; 110 \u0026lt;groupId\u0026gt;org.json\u0026lt;/groupId\u0026gt; 111 \u0026lt;artifactId\u0026gt;json\u0026lt;/artifactId\u0026gt; 112 \u0026lt;version\u0026gt;20170516\u0026lt;/version\u0026gt; 113 \u0026lt;/dependency\u0026gt; 114 115 \u0026lt;dependency\u0026gt; 116 \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; 117 \u0026lt;artifactId\u0026gt;spring-boot-starter-jdbc\u0026lt;/artifactId\u0026gt; 118 \u0026lt;exclusions\u0026gt; 119 \u0026lt;exclusion\u0026gt; 120 \u0026lt;groupId\u0026gt;org.apache.tomcat\u0026lt;/groupId\u0026gt; 121 \u0026lt;artifactId\u0026gt;tomcat-jdbc\u0026lt;/artifactId\u0026gt; 122 \u0026lt;/exclusion\u0026gt; 123 \u0026lt;/exclusions\u0026gt; 124 \u0026lt;/dependency\u0026gt; 125 126 \u0026lt;dependency\u0026gt; 127 \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; 128 \u0026lt;artifactId\u0026gt;spring-boot-starter-thymeleaf\u0026lt;/artifactId\u0026gt; 129 \u0026lt;/dependency\u0026gt; 130 \u0026lt;dependency\u0026gt; 131 \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; 132 \u0026lt;artifactId\u0026gt;spring-boot-devtools\u0026lt;/artifactId\u0026gt; 133 \u0026lt;/dependency\u0026gt; 134 135 \u0026lt;!--\u0026lt;dependency\u0026gt;--\u0026gt; 136 \u0026lt;!--\u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;--\u0026gt; 137 \u0026lt;!--\u0026lt;artifactId\u0026gt;spring-boot-starter-ssl\u0026lt;/artifactId\u0026gt;--\u0026gt; 138 \u0026lt;!--\u0026lt;/dependency\u0026gt;--\u0026gt; 139 140 \u0026lt;!--netty--\u0026gt; 141 \u0026lt;dependency\u0026gt; 142 \u0026lt;groupId\u0026gt;io.netty\u0026lt;/groupId\u0026gt; 143 \u0026lt;artifactId\u0026gt;netty-all\u0026lt;/artifactId\u0026gt; 144 \u0026lt;version\u0026gt;4.1.13.Final\u0026lt;/version\u0026gt; 145 \u0026lt;/dependency\u0026gt; 146 \u0026lt;/dependencies\u0026gt; 147 148 \u0026lt;build\u0026gt; 149 \u0026lt;finalName\u0026gt;myapp\u0026lt;/finalName\u0026gt; 150 \u0026lt;plugins\u0026gt; 151 \u0026lt;plugin\u0026gt; 152 \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; 153 \u0026lt;artifactId\u0026gt;spring-boot-maven-plugin\u0026lt;/artifactId\u0026gt; 154 \u0026lt;/plugin\u0026gt; 155 \u0026lt;plugin\u0026gt; 156 \u0026lt;groupId\u0026gt;org.jetbrains.kotlin\u0026lt;/groupId\u0026gt; 157 \u0026lt;artifactId\u0026gt;kotlin-maven-plugin\u0026lt;/artifactId\u0026gt; 158 \u0026lt;version\u0026gt;${kotlin.version}\u0026lt;/version\u0026gt; 159 \u0026lt;executions\u0026gt; 160 \u0026lt;execution\u0026gt; 161 \u0026lt;id\u0026gt;compile\u0026lt;/id\u0026gt; 162 \u0026lt;phase\u0026gt;compile\u0026lt;/phase\u0026gt; 163 \u0026lt;goals\u0026gt; 164 \u0026lt;goal\u0026gt;compile\u0026lt;/goal\u0026gt; 165 \u0026lt;/goals\u0026gt; 166 \u0026lt;/execution\u0026gt; 167 \u0026lt;execution\u0026gt; 168 \u0026lt;id\u0026gt;test-compile\u0026lt;/id\u0026gt; 169 \u0026lt;phase\u0026gt;test-compile\u0026lt;/phase\u0026gt; 170 \u0026lt;goals\u0026gt; 171 \u0026lt;goal\u0026gt;test-compile\u0026lt;/goal\u0026gt; 172 \u0026lt;/goals\u0026gt; 173 \u0026lt;/execution\u0026gt; 174 \u0026lt;/executions\u0026gt; 175 \u0026lt;configuration\u0026gt; 176 \u0026lt;jvmTarget\u0026gt;1.8\u0026lt;/jvmTarget\u0026gt; 177 \u0026lt;/configuration\u0026gt; 178 \u0026lt;/plugin\u0026gt; 179 \u0026lt;plugin\u0026gt; 180 \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt; 181 \u0026lt;artifactId\u0026gt;maven-compiler-plugin\u0026lt;/artifactId\u0026gt; 182 \u0026lt;executions\u0026gt; 183 \u0026lt;execution\u0026gt; 184 \u0026lt;id\u0026gt;compile\u0026lt;/id\u0026gt; 185 \u0026lt;phase\u0026gt;compile\u0026lt;/phase\u0026gt; 186 \u0026lt;goals\u0026gt; 187 \u0026lt;goal\u0026gt;compile\u0026lt;/goal\u0026gt; 188 \u0026lt;/goals\u0026gt; 189 \u0026lt;/execution\u0026gt; 190 \u0026lt;execution\u0026gt; 191 \u0026lt;id\u0026gt;testCompile\u0026lt;/id\u0026gt; 192 \u0026lt;phase\u0026gt;test-compile\u0026lt;/phase\u0026gt; 193 \u0026lt;goals\u0026gt; 194 \u0026lt;goal\u0026gt;testCompile\u0026lt;/goal\u0026gt; 195 \u0026lt;/goals\u0026gt; 196 \u0026lt;/execution\u0026gt; 197 \u0026lt;/executions\u0026gt; 198 \u0026lt;/plugin\u0026gt; 199 \u0026lt;/plugins\u0026gt; 200 \u0026lt;/build\u0026gt; 201 \u0026lt;repositories\u0026gt; 202 \u0026lt;repository\u0026gt; 203 \u0026lt;id\u0026gt;spring-milestone\u0026lt;/id\u0026gt; 204 \u0026lt;url\u0026gt;http://repo.spring.io/libs-release\u0026lt;/url\u0026gt; 205 \u0026lt;/repository\u0026gt; 206 \u0026lt;/repositories\u0026gt; 207 208\u0026lt;/project\u0026gt; 其中有一些是其他的配置,比如 netty 是在内部构建一个 netty 服务器,注入 spring 进行管理\n1server: 2 port: 8433 3 tomcat: 4 uri-encoding: utf-8 5 6spring: 7 datasource: 8 url: jdbc:mysql://localhost:3306/app?autoReconnect=true\u0026amp;useUnicode=true\u0026amp;characterEncoding=utf-8 9 username: root 10 password: root 11 driver-class-name: com.mysql.jdbc.Driver 12 # type: com.alibaba.druid.pool.DruidDataSource 13 profiles: 14 active: dev 15 # active: prod 16 # active: test 17 #jpg 18 jpa: 19 database: mysql 20 show-sql: true 21 hibernate: 22 ddl-auto: update 23 jooq: 24 sql-dialect: 25 #thymeleaf 26 thymeleaf: 27 mode: HTML5 28#mybatis: 29# mapperLocations: classpath:mapper/*.xml 30# type-aliases-package: com.kikt.api.responsedata 配置文件,使用的是 yml 的格式,也算比较容易理解吧\n首先配置几个 Controller 除网页外,其他所有的交互方式使用 restful 的方式\n1@RestController 2@RequestMapping(\u0026#34;/user\u0026#34;) 3public class UserCtl extends BaseCtl { 4 5 @Autowired 6 private ScanService scanService; 7 8 @Autowired 9 private LoginService loginService; 10 11 @RequestMapping(value = \u0026#34;/login/{username}\u0026#34;, method = RequestMethod.POST) 12 public String login(@PathVariable(\u0026#34;username\u0026#34;) String username, @RequestParam(\u0026#34;pwd\u0026#34;) String pwd) { 13 return loginService.login(username, pwd); 14 } 15 16 @RequestMapping(value = \u0026#34;/login\u0026#34;, method = RequestMethod.GET) 17 public String index(Model model, HttpServletRequest request) { 18 String sessionId = scanService.getSessionId(); 19 String scheme = request.getScheme(); 20 logger.debug(\u0026#34;URL:\u0026#34; + request.getRequestURL()); 21 String serverName = request.getServerName(); 22 logger.debug(\u0026#34;addr:\u0026#34; + serverName); 23 String contextPath = request.getContextPath(); 24 logger.debug(\u0026#34;contextPath:\u0026#34; + contextPath); 25 int serverPort = request.getServerPort(); 26 logger.debug(\u0026#34;serverport:\u0026#34; + serverPort); 27 28 StringBuilder path = new StringBuilder(); 29 path.append(scheme).append(\u0026#34;://\u0026#34;).append(serverName).append(\u0026#34;:\u0026#34;).append(serverPort).append(contextPath); 30 31 model.addAttribute(\u0026#34;sessionId\u0026#34;, sessionId); 32 model.addAttribute(\u0026#34;qrcode\u0026#34;, path + \u0026#34;/user/login/\u0026#34; + sessionId); 33 return \u0026#34;index\u0026#34;; 34 } 35 36 //for html wait login 37 @RequestMapping(value = \u0026#34;/wait/{sessionId}\u0026#34;, method = RequestMethod.POST) 38 @ResponseBody 39 public String waitLogin(@PathVariable(\u0026#34;sessionId\u0026#34;) String sessionId) { 40 return scanService.waitForLogin(sessionId); 41 } 42 43 //phone scan for the login 44 @RequestMapping(value = \u0026#34;/login/{sessionId}\u0026#34;, method = RequestMethod.POST) 45 @ResponseBody 46 public String scanWithLogin(@PathVariable(\u0026#34;sessionId\u0026#34;) String sessionId, @RequestParam String username, @RequestParam String token) { 47 loginService.checkTokenWithName(username, token); 48 return scanService.scanWithLogin(sessionId, username); 49 } 50} 这样就可以使用 http://localhost:8433/user/login/user 这样的 url,使用 post 方式,模拟表单\n同一个 url,使用 get 的方式,获取的就是二维码的显示页面\n这里 index 是定义到一个模板页面,model 中可以设置一些属性在模板文件中进行调用,我这里模板用的是thymeleaf\n模板文件 放在 src/main/resources/templates 目录下,也就是在生成放置 application.properties 的目录中新建一个 templates 目录,在其中新建一个 index.html,这样 controller 就会使用模板渲染 html 使用了 jquery 和 jquery.qrcode 两个 js 库,其中 jquery 是网络访问使用,qrcode 依赖于 jquery,同时提供 qrcode 的生成\n1\u0026lt;!DOCTYPE html\u0026gt; 2\u0026lt;html 3 xmlns:th=\u0026#34;http://www.thymeleaf.org\u0026#34; 4 xmlns:sec=\u0026#34;http://www.thymeleaf.org/thymeleaf-extras-springsecurity3\u0026#34; 5\u0026gt; 6 \u0026lt;head\u0026gt; 7 \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width,initial-scale=1\u0026#34; /\u0026gt; 8 \u0026lt;!--\u0026lt;link th:href=\u0026#34;@{bootstrap/css/bootstrap.min.css}\u0026#34; rel=\u0026#34;stylesheet\u0026#34;/\u0026gt;--\u0026gt; 9 \u0026lt;!--\u0026lt;link th:href=\u0026#34;@{bootstrap/css/bootstrap-theme.min.css}\u0026#34; rel=\u0026#34;stylesheet\u0026#34;/\u0026gt;--\u0026gt; 10 \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; 11 \u0026lt;script type=\u0026#34;text/javascript\u0026#34; th:src=\u0026#34;@{/js/jquery-3.2.1.min.js}\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 12 \u0026lt;!--\u0026lt;script type=\u0026#34;text/javascript\u0026#34; th:src=\u0026#34;@{/js/qrcode.js}\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;--\u0026gt; 13 \u0026lt;script 14 type=\u0026#34;text/javascript\u0026#34; 15 src=\u0026#34;http://cdn.bootcss.com/jquery.qrcode/1.0/jquery.qrcode.min.js\u0026#34; 16 \u0026gt;\u0026lt;/script\u0026gt; 17 \u0026lt;!--\u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#34;../static/js/jquery-3.2.1.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;--\u0026gt; 18 19 \u0026lt;script th:inline=\u0026#34;javascript\u0026#34; type=\u0026#34;text/javascript\u0026#34;\u0026gt; 20 21 function makeQrImage(sessionId) { 22 var qrcode = [[${qrcode}]] 23 $(\u0026#39;#code\u0026#39;).qrcode(qrcode); 24 $(\u0026#39;p\u0026#39;).text(qrcode) 25 26 $.ajax({ 27 url:\u0026#39;./wait/\u0026#39;+sessionId, 28 method:\u0026#39;post\u0026#39;, 29 success:login, 30 fail:loginFail 31 }) 32 } 33 34 var login = function (result) { 35 $(\u0026#39;p\u0026#39;).text(result) 36 }; 37 38 var loginFail = function (result) { 39 $(\u0026#39;p\u0026#39;).text(result) 40 } 41 42 $(document).ready(function () { 43 var sessionId = [[${sessionId}]] 44 makeQrImage(sessionId) 45 }); 46 \u0026lt;/script\u0026gt; 47 \u0026lt;style\u0026gt; 48 .qrcode { 49 width: 150px; 50 height: 150px; 51 } 52 \u0026lt;/style\u0026gt; 53 \u0026lt;title\u0026gt;Title\u0026lt;/title\u0026gt; 54 \u0026lt;/head\u0026gt; 55 \u0026lt;body\u0026gt; 56 \u0026lt;div id=\u0026#34;code\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; 57 \u0026lt;div id=\u0026#34;result\u0026#34;\u0026gt;\u0026lt;p\u0026gt;\u0026lt;/p\u0026gt;\u0026lt;/div\u0026gt; 58 \u0026lt;/body\u0026gt; 59\u0026lt;/html\u0026gt; [[${sessionId}]] 就是读取 model 中的 sessionId 属性\n同理 [[${qrcode}]]就是 model 中的 qrcode 属性\n这里 \u0026lt;script th:inline=\u0026quot;javascript\u0026quot; type=\u0026quot;text/javascript\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; 的标签中使用了 th:inline=\u0026quot;javascript\u0026quot; 这样的写法,这个就是模板的写法了,让 js 标签内可以识别模板中的变量等等\n这里 ajax 中使用了硬编码,可以考虑使用 java 中的 model 传过来,如同 qrcode 的 url 一样,这样就可以在不动 html 的情况下,完成后台 url 的切换\n这里其实逻辑比较简单\n步骤 前端网页: 访问 /user/login GET 方式,提示扫码,然后使用已经登录的手机扫码,同时创建一个 ajax 连接,后台 hold 住此链接等待扫码,使用的是长轮询的方案\n手机端:访问/user/login/adminPOST 方式,先登录,获取了 token 和 username,然后再使用扫码,传入参数 username,token\nmysql 数据库表设计(相关逻辑) 用户表 记录用户相关的数据,包括id,用户名,email,注册时间等信息 登录token表 记录用户token,和token更新时间,token信息 具体的 java 端实现\n上面只是简单的流程步骤,具体的实现还是需要到 service 中去看\n1package com.kikt.api.service.scan 2 3import com.kikt.api.exeption.ErrorEnum 4import com.kikt.api.ext.toJson 5import com.kikt.api.service.BaseService 6import com.kikt.api.service.user.LoginService 7import com.kikt.response.Response 8import org.springframework.beans.factory.annotation.Autowired 9import org.springframework.stereotype.Service 10import java.util.* 11import java.util.concurrent.* 12 13/** 14 * Created by cai on 2017/8/24. 15 */ 16@Service 17open class ScanService : BaseService { 18 19 @Autowired 20 private var loginService: LoginService? = null 21 22 private val map: MutableMap\u0026lt;String, LoginSession\u0026gt; = mutableMapOf() 23 24 fun getSessionId(): String { 25 val random = UUID.randomUUID().toString() 26 map.put(random, LoginSession()) 27 return random 28 } 29 30 fun waitForLogin(sessionId: String): String { 31 val sessionData = map[sessionId] ?: ErrorEnum.SESSION_SCAN_TIME_OUT.throwError() 32 val waitForLogin: String 33 try { 34 waitForLogin = sessionData.waitForLogin() 35 } catch(e: Exception) { 36 map.remove(sessionId) 37 ErrorEnum.SESSION_SCAN_TIME_OUT.throwError() 38 } 39 map.remove(sessionId) 40 return waitForLogin 41 } 42 43 fun scanWithLogin(sessionId: String, username: String): String { 44 val sessionData = map[sessionId] ?: ErrorEnum.SESSION_NO_FOUNT.throwError() 45 val result = loginService?.login(username, 2) 46 if (result != null) { 47 sessionData.login(result) 48 } 49 return Response.newSuccessResponse(\u0026#34;成功\u0026#34;).toJson() 50 } 51 52} 53 54class LoginSession { 55 56 private val queue: BlockingQueue\u0026lt;String\u0026gt; = LinkedBlockingQueue(2) 57 58 companion object { 59 val TIME_OUT: Long = 60000 60 61 val threadPool: ExecutorService = Executors.newFixedThreadPool(30) 62 } 63 64 fun waitForLogin(): String { 65 val take: String? 66 try { 67 runDelayTimeout() 68 take = queue.take() 69 } catch(e: InterruptedException) { 70 throw e 71 } 72 return take 73 } 74 75 fun login(result: String) { 76 queue.offer(result) 77 } 78 79 fun runDelayTimeout() { 80 val currentThread = Thread.currentThread() 81 threadPool.execute { 82 Thread.sleep(TIME_OUT) 83 currentThread.interrupt() 84 } 85 } 86} 总体思路是:定义一个 map 用于记录 sesstionId,和具体的 LoginSession\nLoginSession 中包含一个阻塞队列,在 index 的 ctl 中创建 sessionId 和 loginSession 对象,在访问/wait/sessionId 时调用,等待扫码,称为连接 1\n扫码时,创建连接 2,根据 token 检验手机登陆用户,然后根据 sessionId 找到 LoginSession 对象,给队列传入数据,这样 LoginSession.take()返回后结果后,连接 1 返回登陆信息,同时登陆 2 返回成功的信息\n优化 上面的连接 1 中需要设置一个超时时间,超时后返回失败,这里创建一个线程池,30 秒后尝试中断线程,上面\n1 fun runDelayTimeout() { 2 val currentThread = Thread.currentThread() 3 threadPool.execute { 4 Thread.sleep(TIME_OUT) 5 currentThread.interrupt() 6 } 7 } 执行 60 秒后过时,连接 1 返回失败信息,前端根据失败信息显示刷新重试的样式即可\n后记 总体思路和主要代码都放出来了,具体的实现应该还有更优解,这里我就不尝试了,只起到思路引领\n","link":"https://kikt.top/posts/server/java/spring-boot/scan-login/","section":"posts","tags":["sprintboot","java","扫码","server"],"title":"spring boot 扫码登录 后端实现"},{"body":"","link":"https://kikt.top/tags/%E6%89%AB%E7%A0%81/","section":"tags","tags":null,"title":"扫码"},{"body":"","link":"https://kikt.top/tags/mysql/","section":"tags","tags":null,"title":"mysql"},{"body":"前言 为啥标题这么长呢? 因为确实关联到了这些问题 最近买了个阿里云的打折主机,打算主机布个简易的服务器,顺便熟悉下 springboot 的一些知识, 数据库打算直接用简单 jdbctemplate 但是不巧 在提交上传的时候有中文,引起了乱码问题\n乱码问题 根据我多年的经验,乱码都是编码问题,baidu 了下\n修改 springboot.properties\n1spring.datasource.url = jdbc:mysql://127.0.0.1:3306/app?autoReconnect=true\u0026amp;useUnicode=true\u0026amp;characterEncoding=utf-8 果然得到了解决\nemoji 报错 后来上传的内容中有 emoji 表情,报错信息UncategorizedSQLException 原因是 utf8 不支持长度为 4 的编码\n数据库 1create table blog_content 2( 3 `_id` int not null auto_increment comment \u0026#39;id 主键\u0026#39; 4 primary key, 5 title varchar(50) default \u0026#39;没有标题\u0026#39; not null comment \u0026#39;标题\u0026#39;, 6 content varchar(1000) null, 7 tag varchar(30) null comment \u0026#39;标签\u0026#39;, 8 insert_time timestamp default CURRENT_TIMESTAMP not null, 9 update_time timestamp default CURRENT_TIMESTAMP not null comment \u0026#39;更新时间\u0026#39;, 10 author_uid int not null 11) 12 comment \u0026#39;博客内容\u0026#39; 13 ENGINE=InnoDB DEFAULT charset utf8mb4 collate utf8mb4_unicode_ci; 14; 1INSERT INTO blog_content (content, tag, author_uid) VALUES (\u0026#39;内容👌\u0026#39;,\u0026#39;1,2\u0026#39;,1); 解决过程 数据库相关 根据网上的说法,修改数据库,修改表,修改表字段为 utf8mb4\nALTER DATABASE app CHARACTER SET = utf8mb4 COLLATE = utf8mb4_unicode_ci; ALTER TABLE blog_content CONVERT TO CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci; ALTER TABLE blog_content CHANGE content_emoji content_emoji VARCHAR(1000);\n再运行依然报错..\n这个时候我就不得不考虑问题出在程序内还是 mysql 内了 使用 mysql 的数据库连接,直接在 sql 中插入一条带 emoji 的数据,直接报错 那么就不是程序的问题了,数据库的问题 使用 SHOW VARIABLES WHERE Variable_name LIKE 'character_set_%' OR Variable_name LIKE 'collation%';\n1character_set_client utf8 2character_set_connection utf8 3character_set_database utf8 4character_set_results utf8 只有数据库是 这个时候使用一条set names utf8mb4;就解决了 再查询一次\n1character_set_client utf8mb4 2character_set_connection utf8mb4 3character_set_database utf8mb4 4character_set_results utf8mb4 再插入 emoji 的数据 成功了!\n程序解决方案 这个时候在程序内,还是会抛异常,不过没问题\n这个时候我们知道,我们执行set names utf8mb4;就能解决问题 那么在程序中也加入这个调用也就可以了\njdbctemplate 是全局单例的,那么我们找一个合适的位置调用就可以了\n找一个合适的位置调用就可以了\n1@Component 2open class ApplicationStartup : ApplicationListener\u0026lt;ContextRefreshedEvent\u0026gt; { 3 4 override fun onApplicationEvent(event: ContextRefreshedEvent) { 5 val service = event.applicationContext.autowireCapableBeanFactory.getBean(BlogService::class.java) 6 service.changeSet() 7 8 logger.info(\u0026#34;ApplicationStartup init\u0026#34;) 9 } 10} 用的是 kotlin 的写法,和 java 大同小异,实现 ApplicationListener 接口 加 Component 注解\n1service.changeSet(){ 2 jdbcTemplate?.update(\u0026#34;set names utf8mb4;\u0026#34;) 3} 结尾 其实,这个问题不算困难,但是在解决的过程中也是有过弯路的 单纯从网上找答案一般是很难解决的,这个时候我觉得就需要加入自己的思考,为啥会出问题 所谓大胆假设,小心求证! 就是这个道理了\n","link":"https://kikt.top/posts/server/java/spring-boot/encoding-error/","section":"posts","tags":["sprintboot","java","mysql","编码","utf8","server"],"title":"spring boot jdbctemplate mysql emoji 编码错误的问题"},{"body":"","link":"https://kikt.top/tags/utf8/","section":"tags","tags":null,"title":"utf8"},{"body":"","link":"https://kikt.top/tags/%E7%BC%96%E7%A0%81/","section":"tags","tags":null,"title":"编码"},{"body":"何谓将类名作为参数 举个栗子 看这么一个需求:\n一个 tableview,其中的 cell 是 nib 写的\n步骤:\n定义 1 个 cell 和对应的 xib 在 ViewController 中定义一个 Xib 加载对应文件,注册 xib 这个时候有一些步骤就是需要定义一个 xib 的文件名,cell 的 identitier,但是这两个东西都是字符串,如果一个字母敲错了或者后续业务逻辑/功能有更改,那么当你要修改 cell 对应的类名时,你就不得不一起修改文件名,字符串的名字,所有引用的名称..等等步骤\n这个时候就要想了,如果将这个 Cell 实现一个 protocol,protocol 中有 xibName,identifier,同时每个类去实现,然后 tableview 注册方法中只传类名不就可以了吗,这样以后如果有修改都只在 Cell 的类内部去写,就不容易出错了\n实现步骤 定义一个 Protocol 1protocol NibCell { 2 3 static func nibName() -\u0026gt; String 4 5 static func identifier() -\u0026gt; String 6 7} 定义一个 Cell 1import UIKit 2 3class OrderDetailCell: UITableViewCell,NibCell { 4 5 static func nibName() -\u0026gt; String { 6 return \u0026#34;OrderDetailCell\u0026#34; 7 } 8 9 static func identifier() -\u0026gt; String { 10 return \u0026#34;OrderDetailCell\u0026#34; 11 } 12 13 override func awakeFromNib() { 14 super.awakeFromNib() 15 // Initialization code 16 } 17 override func setSelected(_ selected: Bool, animated: Bool) { 18 super.setSelected(selected, animated: animated) 19 // Configure the view for the selected state 20 } 21} tableview 写一个通过注册 xib 来注册 cell 的扩展方法 1import UIKit 2 3extension UITableView{ 4 5 func registerNibCell(nibCellType nibCell:NibCell.Type){ 6 let nib = UINib(nibName: nibCell.nibName(), bundle: nil) 7 self.register(nib, forCellReuseIdentifier: nibCell.identifier()) 8 } 9 10} 这里传入了一个 NibCell.Type 的方法,这样在实际使用的时候,可以直接用对应的 nibName 获取到实际类(OrderDetailCell)定义的 nibName 方法的返回值\n调用 1import UIKit 2 3class MyOrderDetailViewCtl: BaseViewCtl,OrderDetailView{ 4 5 @IBOutlet weak var tableview: UITableView! 6 7 override func viewDidLoad() { 8 super.viewDidLoad() 9 tableview.registerNibCell(nibCellType: OrderDetailCell.self) 10 } 11 12} 总结 通过封装,可以直接使用类来作为参数,后续维护时,只要看到继承 NibCell 协议的类,即可直接找到对应的方法得到 nib 名称和对应的 cell,同样注册时也不怕敲错字符串了\n当然,更多的还是知道了如何使用 swift 中的将类名作为参数传递的方法\n","link":"https://kikt.top/posts/ios/swift/swift3-class-as-param/","section":"posts","tags":["iOS","swift"],"title":"Swift3之将类作为参数"},{"body":"关于 react native 和 weex 之我见 写在前面 我是一个主 android 开发,原生的 ios 开发也算是初窥门径,主要是有一些东西如果能一次性开发,多次使用就好了,跨平台性嘛\n本文没有代码,只是一些简单的看法\n跨平台的探索 这里就有几个选择了,有纯粹的网页嵌入式开发,虽然是一个解决方案,但是毕竟不原生,而且网页渲染很不靠谱的感觉,否定掉了\n然后想起了react native和weex,都号称是使用 web 语言开发,然后渲染成原生控件,而且还支持热更新!\n好高端大气的样子啊!去尝试下吧\nreact native 首先是react native,简称 RN facebook 的开源项目,语法和文档都还算可以接受\n开发环境配置 我是 jetbrain 的忠实粉丝嘛,webstorm 走起来,破解的方案自己 baidu 吧,这里就不宣传了\n导航条的问题 我翻遍了所有的文档,没找到一个考虑的导航控制器,导航条虽然有一个react-navigation\n但是我使用了一下这个,如果是自己写一个自己的项目还好,但是我们毕竟不是设计师,国内的设计们从来都是按照自己的方案设计导航条的啊!真没几个人是用系统自带的方案,这里用 react 的 navigation 很难自定义,我这里没找到可以修改标题颜色的方案\n而且还需要吐槽一点,我认为网页端最强的一点就是百分比适配方案是 css 自带的,非常强大,而这里居然没有了,完全是 px,这样面对不同的平台真的能好好的适配吗\n运行 这里就要说 webstorm 对于 react native 的支持了,帮我们全部配置好了,可以用鼠标选择 ios/android 直接运行就行了,真是 diao 啊\n日志问题/debug 问题 和源生相比,android studio/xcode 都是可以直接在 ide 里直接可以看到日志的,调试相对很方便,这里就不是这样了,真的很麻烦,需要在模拟器里开 debug 模式,然后 chrome 打开网页,开发者模式,看控制台才能看见\n这个时候我才知道,我们原生开发的开发环境真的比网页端的兄弟们好太多了\n动态部署 可以直接在模拟器点 cmd+R 就可以了 好简单啊!\n直接原地重新运行,我靠,什么时候我们源生也能这样就好了\n页面跳转问题 在 android 中有 intent 开 activity 的方案,ios 中有 modal 跳转开新页面 RN 这里就不行了,因为本质上 android 是运行在同一个Activity中的,ios 的话应该是一个UIViewController中吧,然后利用内置的引擎将 js 渲染成源生代码进行展示,这里我想如果我需要跳转的话,可以自己内嵌代码,利用源生的方案跳转,然后回调到 RN 中来,理论上可行,后续我自己开发下试试看吧\n小总结 RN 其实完全可以承载简单的开发任务,比如是交互性质,或者展示页面时,完全可以使用 RN 来开发,但是学习成本不算太低\n另外就是当你有很繁重的任务,尤其是调用内置的系统级 API 时,如蓝牙的话如果能找到轮子还行,如果找不到那就很尴尬了\nweex 阿里巴巴的项目嘛,在各种 blog 中也能见到 vue 的大名,这里想着可以尝试下\n优势/劣势 对于中国人来说,这个原作者是中国人,相对来说中文的说明和解答就会很多,但是相对的,开源项目还是很需要英文社区的支持的,毕竟外国人对于开源社区的贡献从目前来说还是高于中国的\n开发环境 这个开发环境相对 RN 来说没有那么好,因为 ios/andorid 的项目好像需要自己来建,这样就很不友好了,对于有原生开发经验的人来说还算友好,但是如果没有呢? 新入行的朋友想要快速的运行起项目来回很困难,这样的话对于新人来说门槛偏高,一个 vue 的开发人员转到 weex 来的话还需要学习 android/ios 的开发配置知识,不利于快速入行,我记得当前 androidstudio 只需要建立好项目,然后 run 就跑起来了\n文档 这个相对完善很多,毕竟中文的嘛,但是我学到一半学习不下去的很大原因是,我试验自带的控件indicator和对应的 demo 代码,发现选中颜色和背景颜色不生效,这我就很揪心了,如果 api 更新后又不反映到文档上,让人会很困惑,自己调试了找了几个小时问题,发现居然是框架的问题,这个时候那种感觉就像吃了 shi 一样难受\n语法 这个我想说,个人感觉比 RN 友好了很多,而且看起来让我想起了 css+html+js 的那种感觉,真的很友好\n最后小小总结下 RN 和 weex 都是很优秀的项目,但是目前个人感觉还是不太适合开发大型项目,里面的坑现在还不好说,而且最大的问题是没有完备的开发工具,虽然说NB的程序员都是用vim开发的 但是对于我等平庸之人来说,ide 是开发必备的,因为静态的语法检查可以节省大家的时间,而且再怎么样所有的一切都是依赖在 andorid/ios 本身的平台上的\n个人认为:如果目前有两端需求,又不要求界面风格统一的应用,且是新应用,很适合使用 RN/weex 开发,但是本身公司就有 ios/android 开发的情况下,不太适合使用这个来开发,原生开发很成熟,非常成熟,原则上不会出现大问题,而且解决问题的方案会很多,混合 app 的开发,第一个版本的压力会非常大!!\n而 RN/weex 还处于快速迭代的过程中,目前应该还不适合接入,如果再过一年,我觉得可以考虑使用 RN 开发应用\n我想这次 app store 大规模的下架热更新的事件也应该会给大家一个警钟吧\n个人观点,有不同意的不要喷 你好!react native 你好!weex 希望明年再看会有不同的看法 希望我可以早日可以一套代码多端使用! 2018-07-20 更新\n以上是 2017 年末的观点\n我在今年 4 月左右投入了 flutter 的开发大军中,个人的选择结果,个人的倾向性不言而喻\n","link":"https://kikt.top/posts/other/rn-weex-my-idea/","section":"posts","tags":null,"title":"RN/Weex的个人看法"},{"body":"ios-toast-swift swift 3.1 语法\n如果想支持其他的语法请自己修改 这里主要是模仿android端的提示方案 截图 背景灰色是因为我把 Demo 中的 ViewController 的 view 的 backgroundColor 修改为了 gray 不是会覆盖全屏的颜色\n这里有个小 bug 圆角么有包含全,后续改正\n食用方法 clone 项目 将 source 下的方法 copy 到源码内,如果有文件重名请自己改名 toast(\u0026quot;提示语句\u0026quot;) toast(\u0026quot;提示内容\u0026quot;,3) //内容 时长 源码分析 都是伪代码 代码分布 ToastView:自定义view相关的代码,基本没啥东西,就是加载了xib文件 Toast:帮助类,其中定义了如何附着到window中,位置,根据文字计算文字大小,渐隐动画等相关内容 提示 这里对于项目没有太多的侵入性 总体原理大概就是创建一个 view,将 view 附着到前台 window 中 这里有一点,这里的 toast 会覆盖掉软键盘\n如果想要修改 view 的样式,可以自己修改 ToastView.xib/ToastView.swift 内容很简单,就在ToastView中 可以自定义内容,更加丰富多彩,也可以基于扩展 content 是一个UILabel,用于显示内容 想要修改提示位置 Toast.swift 的 57~60行 想要修改大小 Toast.swift的35~50行左右 动画效果 Toast.swift的66~87行 License/开源协议 Copyright 2017 JingLong Cai Licensed under the Apache License, Version 2.0 (the \u0026quot;License\u0026quot;); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \u0026quot;AS IS\u0026quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. ","link":"https://kikt.top/posts/ios/ios-toast/","section":"posts","tags":["toast","iOS","swift"],"title":"Ios版toast"},{"body":"前言 最近有一些蓝牙的通信需要做,就研究了一下蓝牙连接相关\n连接蓝牙电子秤 连接 pos 机打印 其中连接蓝牙电子秤是接收数据 pos 机打印是发送数据/接收数据\n流程图 流程图画的相当不专业,请自行脑补 核心类 因为这次的电子秤不是 4.0 的设备,所以没有使用 BLE 的开发,而是经典蓝牙(SPP)的连接方式 BluetoothAdapter\n全局变量\n1protected BluetoothAdapter mAdapter; 获取的方法,在 API18 下的时候使用的方式和以上的不一样,其实差别不大\n1if (SDK_INT \u0026lt; 18) { 2 adapter = BluetoothAdapter.getDefaultAdapter(); 3} else { 4 BluetoothManager bm = (BluetoothManager) getSystemService(BLUETOOTH_SERVICE); 5 adapter = bm.getAdapter(); 6} 蓝牙使用的是注册广播的方式来获取系统给我们的通知 核心有以下的几种,注册广播的方法自己去搜下吧\n1 BluetoothDevice.ACTION_FOUND//找到设备 2 BluetoothDevice.ACTION_NAME_CHANGED//设备的名字 3 BluetoothAdapter.ACTION_DISCOVERY_FINISHED//扫描结束 4 BluetoothDevice.ACTION_PAIRING_REQUEST//配对请求的放弃 5 BluetoothAdapter.STATE_OFF//蓝牙关闭 6 BluetoothAdapter.STATE_ON//蓝牙开启 连接 一般这种连接应该是全局单例,考虑写在了 service 中\n首先需要扫描所有的蓝牙连接,但是这里有个坑,就是如果你将广播注册在 onCreate 中和 onDestroy,你每次都需要接收系统的广播,如果出现同名或者别的原因,这里就会一直接收广播 所以这里需要动态的将广播注册与反注册 我这里使用的方案请参照流程图\n说明 这里是经典蓝牙(SPP)的连接代码,BLE 的连接相关目前还没有做,后续如果有实现的时候也会再写 blog\n关于 UUID 蓝牙连接的 UUID 是有一套自己的定义规范的,但是目前的厂商不知道为什么大部分习惯都使用同一个 UUID,我这里蓝牙称,蓝牙打印机都用的这个\n1 public static final UUID _UUID = java.util.UUID.fromString(\u0026#34;00001101-0000-1000-8000-00805F9B34FB\u0026#34;); 扫描 1 mAdapter.startDiscovery() 关于找到设备的坑 这里有一些关于设备的坑,有的设备你使用BluetoothDevice.ACTION_FOUND广播中获取蓝牙设备的名字会发现是空的,这个时候就很尴尬了,使用系统自带的蓝牙扫描也会发现,扫描到的是先 MAC 地址,然后过几秒更改为名字,这里有另一个广播BluetoothDevice.ACTION_NAME_CHANGED可以获取到名字更新时的光爆\n当然蓝牙设备如果提前知道蓝牙的 mac 地址,最好还是使用 mac 地址连接匹配为最佳,毕竟 mac 地址轻易不会重复\n配对 1 try { 2 // 连接建立之前的先配对 3 if (device.getBondState() == BluetoothDevice.BOND_NONE) { 4 Method creMethod = BluetoothDevice.class.getMethod(\u0026#34;createBond\u0026#34;); 5 creMethod.invoke(device); 6 } else {//已配对，连接socket 7 connDevice(device); 8 } 9 } catch (Exception e) { 10 // TODO: handle exception 11 //DisplayMessage(\u0026#34;无法配对！\u0026#34;); 12 e.printStackTrace(); 13 } 这里如果已经配对,则直接连接,如果没有配对需要先配对,这里只是创建配对请求 ACTION_PAIRING_REQUEST这个广播用于接收配对请求的发起,然后使用\n1 LogUtils.d(TAG, \u0026#34;manualConn:\u0026#34; + manualConn); 2 if (manualConn) { 3 return; 4 } 5 final BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE); 6 if (device == null) { 7 return; 8 } 9 LogUtils.d(TAG, device.getName()); 10 if (device.getBondState() != BluetoothDevice.BOND_BONDED) { 11 try { 12 // ClsUtils.setPin(device.getClass(), device, pwd); // 手机和蓝牙采集器配对 13 LogUtils.d(TAG, \u0026#34;设置pin码\u0026#34; + pwd); 14 ToastUtils.toast(device.getName() + \u0026#34;配对中\u0026#34;); 15 boolean pinResult = device.setPin(pwd.getBytes()); 16// handler.postDelayed(new Runnable() { 17// @Override 18// public void run() { 19// try { 20// ClsUtils.cancelPairingUserInput(device.getClass(), device); 21// } catch (Exception e) { 22// } 23// } 24// }, 1000); 25 // 一般调用不成功，前言里面讲解过了 26 LogUtils.d(TAG, \u0026#34;pinResult:\u0026#34; + pinResult); 27 if (pinResult) { 28 connDevice(device); 29 } else { 30 ToastUtils.toast(\u0026#34;pin码不正确，请手动配对电子秤后点击连接\u0026#34;); 31 manualConn = true; 32 } 33 } catch (Exception e) { 34 ToastUtils.toast(\u0026#34;请求连接错误...\u0026#34;); 35 } 36 } 这里是直接贴出来了程序中的片段,也会有一些报错,替换为自己的 Log/Toast 的 util 就可以了,也可以考虑删除掉,这里注释掉的部分原本是打算关闭配对的连接框的,但是这里有一些其他的问题,不同的 rom 处理方式不同,有些处理时会将 pin 码清空导致连接失败,所以这里将这部分代码清空,不关闭了\n连接设备 核心连接代码\n1socket = device.createInsecureRfcommSocketToServiceRecord(_UUID); //不安全的 2// socket = device.createRfcommSocketToServiceRecord(_UUID); //安全 3socket.connect() 关于连接方式,这里有两种.一种是使用不安全的连接方式,一种是使用安全的连接方式,这里需要根据你的蓝牙设备作为区分, 都是创建一个 BluetoothSocket\n一般来说,如果对方是 android 设备,应该是安全的,如果是外置设备(蓝牙电子秤) 一般使用不安全的方案.\n这两个连接方法要求 API\u0026gt;10\n题外话 我其实现在的minSDK已经是19了,目前google自己都放弃维护低版本了,google chrome都不支持他们了,咱们也没必要继续支持低版本了 连接成功后,可以获取到一个 socket 连接,可以用这个 socket 连接获取到相关信息,不管是接收还是发出,通过这个连接就可以具体的获取相关信息\n这里只是抛砖引玉 具体的实现后续有时间抽取出来形成一个开源项目再贴吧,项目毕竟是公司的,我这里不方便直接将整个代码贴出来,这个连接的相关代码非常乱\n后记 这个蓝牙项目让我感受到了 google 深深的恶意,整个项目的坑数不胜数,这里先这样吧\n","link":"https://kikt.top/posts/android/android-spp-bluetooth/","section":"posts","tags":["android","蓝牙","spp"],"title":"android 经典蓝牙编程 SPP"},{"body":"","link":"https://kikt.top/tags/spp/","section":"tags","tags":null,"title":"spp"},{"body":"","link":"https://kikt.top/tags/%E8%93%9D%E7%89%99/","section":"tags","tags":null,"title":"蓝牙"},{"body":"前言 今天用 AS 写一个带有百度地图相关的项目时，发现了一个问题\n提示\n1 Error:Execution failed for task \u0026#39;:app:compileDebugNdk\u0026#39;. 2\u0026gt; Error: Your project contains C++ files but it is not using a supported native build system. 3Consider using CMake or ndk-build integration with the stable Android Gradle plugin: 4 https://developer.android.com/studio/projects/add-native-code.html 5or use the experimental plugin: 6 http://tools.android.com/tech-docs/new-build-system/gradle-experimental. 我就找原因，先点开了两个网页，发现一个是用 CMake 构建 ndk 的还一个是用 experimental 插件构件 ndk 项目的\n这两个方式的共通点是都有 c 的源码，自己生成 so 文件，都不是我想要的\n因为以前这么写没有问题，我在网上找相同的问题，大家都是说把 targetVersion 改成 23 以下就解决了，但是这不是我想要的，况且我这么用了也没解决问题，毕竟 targetVersion 迁移到 23+是大势所趋\n我找了下原因，应该是 so 文件的原因，在 6.0 中添加了一个安全性的规范，大概意思是说，不能引用外部的 so 库，这样会有安全性的问题\n索性，我在网上找到了一个解决方案\n这个博客给了我一个方案\n在 app 级的 build.gradle 中添加这么一段代码\n1compile fileTree(dir: \u0026#39;libs\u0026#39;, include: \u0026#39;*.jar\u0026#39;) 1android { 2 ... 3 //设置so引入 4 task nativeLibsToJar(type: Zip, description: \u0026#34;create a jar archive of the native libs\u0026#34;) { 5 destinationDir file(\u0026#34;$projectDir/libs\u0026#34;) 6 baseName \u0026#34;Native_Libs2\u0026#34; 7 extension \u0026#34;jar\u0026#34; 8 from fileTree(dir: \u0026#34;libs\u0026#34;, include: \u0026#34;**/*.so\u0026#34;) 9 into \u0026#34;lib\u0026#34; 10 } 11 12 tasks.withType(JavaCompile) { 13 compileTask -\u0026gt; compileTask.dependsOn(nativeLibsToJar) 14 } 15 //.so引入 end 16 ... 17} 这个大概意思就是建立一个 nativeLibsToJar 任务栈(这里的相关知识请查阅 gradle)，这个任务栈将 libs 中的所有 so 文件打包到 Native_Libs2 中，这个压缩包中的结构是 lib/(cpu)/*.so，打包方式是 zip\n当然，这里需要将所有的 so 文件按照标准结构放到 libs 文件夹中，不然是打不到的\n完成后的目录结构如下 查看手机 我的手机有 root 权限，可以看到应用文件夹 我们看到，这里的 so 文件会被放到应用的内部文件夹下，这样就不会出现外部 so 的引用问题了\n我的手机是魅族 pro5，android5.1 的系统，测试通过，6.0+暂时还没测试，不过工程起码能跑起来了,后续看看有没有别的 6.0 手机拿来用用看\n项目代码可以 git 下来，github 太慢，我放在了 oschina 的 git 服务器上\nkeystore 我也放在项目中了，不过得自己修改下才能运行\n","link":"https://kikt.top/posts/android/baidu-map-error/","section":"posts","tags":["android","百度地图"],"title":"Android6.0百度地图导入UnsatisfiedLinkError的问题"},{"body":"","link":"https://kikt.top/tags/%E7%99%BE%E5%BA%A6%E5%9C%B0%E5%9B%BE/","section":"tags","tags":null,"title":"百度地图"},{"body":"","link":"https://kikt.top/tags/excel/","section":"tags","tags":null,"title":"excel"},{"body":"","link":"https://kikt.top/tags/poi/","section":"tags","tags":null,"title":"poi"},{"body":"前言 这次不是 Android 的技术分享，是 java 的，当然把 poi 的代码放到 Android 中也可以用，毕竟同源嘛\n为啥会有这个文章呢，因为我老婆是会计嘛，她有时候会让我帮忙对账，两个 excel 文件，顺序也不同，需要我来对比出哪里有问题，也就是数不太对应，我想了一下，如果好几百个甚至几千个数字来对账，那我岂不是眼睛都花了，这样我哪里还有时间去happy愉快的撸代码了？ 作为一个程序员，我们要解放自己的眼睛，去做一些有意义的事情！\n开发环境 Intellij Idea+maven\npom 文件\n1\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; 2\u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; 3 xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; 4 xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; 5 \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; 6 7 \u0026lt;groupId\u0026gt;com.kikt\u0026lt;/groupId\u0026gt; 8 \u0026lt;artifactId\u0026gt;ExcelDemo\u0026lt;/artifactId\u0026gt; 9 \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; 10 \u0026lt;build\u0026gt; 11 \u0026lt;plugins\u0026gt; 12 \u0026lt;plugin\u0026gt; 13 \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt; 14 \u0026lt;artifactId\u0026gt;maven-compiler-plugin\u0026lt;/artifactId\u0026gt; 15 \u0026lt;configuration\u0026gt; 16 \u0026lt;source\u0026gt;1.7\u0026lt;/source\u0026gt; 17 \u0026lt;target\u0026gt;1.7\u0026lt;/target\u0026gt; 18 \u0026lt;/configuration\u0026gt; 19 \u0026lt;/plugin\u0026gt; 20 \u0026lt;/plugins\u0026gt; 21 \u0026lt;/build\u0026gt; 22 23 \u0026lt;dependencies\u0026gt; 24 \u0026lt;!-- https://mvnrepository.com/artifact/org.apache.poi/poi --\u0026gt; 25 \u0026lt;dependency\u0026gt; 26 \u0026lt;groupId\u0026gt;org.apache.poi\u0026lt;/groupId\u0026gt; 27 \u0026lt;artifactId\u0026gt;poi\u0026lt;/artifactId\u0026gt; 28 \u0026lt;version\u0026gt;3.15-beta2\u0026lt;/version\u0026gt; 29 \u0026lt;/dependency\u0026gt; 30 \u0026lt;!-- https://mvnrepository.com/artifact/org.apache.poi/poi-ooxml --\u0026gt; 31 \u0026lt;dependency\u0026gt; 32 \u0026lt;groupId\u0026gt;org.apache.poi\u0026lt;/groupId\u0026gt; 33 \u0026lt;artifactId\u0026gt;poi-ooxml\u0026lt;/artifactId\u0026gt; 34 \u0026lt;version\u0026gt;3.15-beta2\u0026lt;/version\u0026gt; 35 \u0026lt;/dependency\u0026gt; 36 \u0026lt;/dependencies\u0026gt; 37 38\u0026lt;/project\u0026gt; 引入了 poi 的解析库的两个文件\n结构 首先是 poi 对于 excel 的结构分析 WorkBook-\u0026gt;Sheet-\u0026gt;Row-\u0026gt;Cell 放在 wps/excel 中看，WorkBook 对应的是工作簿，Sheet 是表，Row 顾名思义是行，Cell 是单元格\n有了这个基础，我们继续去看\n获取数据 得到 sheet 表 要想拿到数据，首先需要先把工作簿拿到，然后拿到 Sheet\n首先拿到 WorkBook\n1File file = new File(path); 2FileInputStream is = new FileInputStream(file); 3Workbook sheets = WorkbookFactory.create(is); 这里 path 是文件对应的路径\n我们这里建一个 Utils 文件用于操作这样的重复数据 ExcelUtils.java\n1public class ExcelUtils { 2 private ExcelUtils() { 3 } 4 public static Sheet getSheet(String path, int sheetPosition) throws IOException, InvalidFormatException { 5 File file = new File(path); 6 FileInputStream is = new FileInputStream(file); 7 Workbook sheets = WorkbookFactory.create(is); 8 return sheets.getSheetAt(sheetPosition); 9 } 10 11 public static Sheet getSheet(String path, String sheetName) throws IOException, InvalidFormatException { 12 File file = new File(path); 13 FileInputStream is = new FileInputStream(file); 14 Workbook sheets = WorkbookFactory.create(is); 15 return sheets.getSheet(sheetName); 16 } 17} 两个方法分别使用表格的名字/序号获取 position 从 0 开始，这里为了处理有可能数十个 sheet 的情况，所以增加了一个用名称获取的方法\nSheet 的声明\n1public interface Sheet extends Iterable\u0026lt;Row\u0026gt; Sheet 是一个接口，继承 Iterable，所以可以知道这里的实现类一定实现了 Iterable 接口 可以用 foreach 循环来遍历 Sheet 得到 Row\n得到 Cell 1public interface Row extends Iterable\u0026lt;Cell\u0026gt; Row 同样如此，可以通过 foreach 循环得到 Cell，这样可以每个单元格的遍历\n1 Cell getCell(int var1); Row 中有一个方法，根据一个 int 值得到对应的 Cell 这个方法从 0 开始，这里就涉及到一个问题，Excel 的列标是字母形式，而不是数字，需要转化一下 这里写了一个小算法\n1 private static Map\u0026lt;Integer, Integer\u0026gt; columnMap = new HashMap\u0026lt;\u0026gt;(); 2 3 private static int getColumnLength(int length) { 4 Integer columnLength = columnMap.get(length); 5 if (columnLength == null) { 6 columnMap.put(length, (int) Math.pow(26, length)); 7 } else { 8 return columnLength; 9 } 10 return getColumnLength(length); 11 } 12 13 /** 14 * @param columnLetter 列的字母 15 * @return 列对应的数字 16 */ 17 public static int getColumnNumber(String columnLetter) { 18 if (columnLetter == null) { 19 throw new RuntimeException(\u0026#34;列号不能为空\u0026#34;); 20 } 21 columnLetter = columnLetter.toLowerCase(); 22 int letterLength = columnLetter.length(); 23 if (letterLength == 1) { 24 char letter = columnLetter.charAt(0); 25 return letter - 97; 26 } else { 27 Integer length =getColumnLength(letterLength - 1); 28 return (getColumnNumber(columnLetter.charAt(0) + \u0026#34;\u0026#34;)+1)*length+getColumnNumber(columnLetter.substring(1)); 29 } 30 } 可以将 AA、CA 之类的列号转为对应的数字 PS：题外话，这里推荐下 Sedgewick 的《算法》一书，最近重新研读了下，虽然都是基础，但是基础的牢靠对于算法有很大的帮助\n正式开始编码的准备工作 这里是对应的两个表的截图，这里我给隐私部位打了些马赛克\n金额之类的可以看到 我们要对比的就是图 1 的 F 列和图 2 的 H 列\n1 String recordFilePath = \u0026#34;H:\\\\1.xls\u0026#34;; 2 Sheet recordSheet = ExcelUtils.getSheet(recordFilePath, 0); 3 List\u0026lt;RecordBean\u0026gt; recordBeanList = getRecordList(recordSheet, \u0026#34;a\u0026#34;, \u0026#34;f\u0026#34;); 4 5 String invoiceFilePath = \u0026#34;2.xls\u0026#34;; 6 Sheet invoiceSheet = ExcelUtils.getSheet(invoiceFilePath, \u0026#34;外地预交增值税及附加税\u0026#34;); 7 List\u0026lt;InvoiceBean\u0026gt; invoiceBeanList = getInvoiceList(invoiceSheet, \u0026#34;a\u0026#34;, \u0026#34;i\u0026#34;); 这里我首先通过 util 的方法获取到了 sheet 表，然后将需要解析的列号写入方法内 然后获取到了对应的 List 集合\nbean 实体\n1package excel.bean; 2 3/** 4 * Created by kikt on 2017/2/26. 5 * 记账信息 6 */ 7public class RecordBean extends NumberBean{ 8 private int index; 9 private double number; 10 11 public int getIndex() { 12 return index; 13 } 14 15 public void setIndex(int index) { 16 this.index = index; 17 } 18 19 public double getNumber() { 20 return number; 21 } 22 23 public void setNumber(double number) { 24 this.number = number; 25 } 26 27 @Override 28 public String toString() { 29 return \u0026#34;RecordBean{\u0026#34; + 30 \u0026#34;index=\u0026#34; + index + 31 \u0026#34;, number=\u0026#34; + number + 32 \u0026#39;}\u0026#39;; 33 } 34} 1package excel.bean; 2 3/** 4 * Created by kikt on 2017/2/26. 5 */ 6public class NumberBean { 7 private int numberIndex; 8 9 public int getNumberIndex() { 10 return numberIndex; 11 } 12 13 public void setNumberIndex(int numberIndex) { 14 this.numberIndex = numberIndex; 15 } 16} 获取 list 的方法\n1private static List\u0026lt;RecordBean\u0026gt; getRecordList(Sheet recordSheet, String indexLetter, String numberLetter) { 2 List\u0026lt;RecordBean\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); 3 for (Row cells : recordSheet) { 4 RecordBean bean = new RecordBean(); 5 Cell indexCell = cells.getCell(ExcelUtils.getColumnNumber(indexLetter)); 6 if (indexCell == null || indexCell.getCellType() != Cell.CELL_TYPE_NUMERIC) { 7 continue; 8 } 9 double numericCellValue = indexCell.getNumericCellValue(); 10 bean.setIndex((int) numericCellValue); 11 int columnNumber = ExcelUtils.getColumnNumber(numberLetter); 12 bean.setNumberIndex(columnNumber); 13 bean.setNumber(cells.getCell(columnNumber).getNumericCellValue()); 14 list.add(bean); 15 } 16 17 return list; 18 } 另一个大致相同，这里不贴了\n然后通过一个 compare 方法比较一下\n1private static List\u0026lt;InvoiceBean\u0026gt; compareList(List\u0026lt;RecordBean\u0026gt; recordBeanList, List\u0026lt;InvoiceBean\u0026gt; invoiceBeanList) { 2 List\u0026lt;InvoiceBean\u0026gt; unMarkBeanList = new ArrayList\u0026lt;\u0026gt;(); 3 4 for (int i = recordBeanList.size() - 1; i \u0026gt;= 0; i--) { 5 RecordBean recordBean = recordBeanList.get(i); 6 for (int j = 0; j \u0026lt; invoiceBeanList.size(); j++) { 7 InvoiceBean invoiceBean = invoiceBeanList.get(j); 8 if (recordBean.getNumber() == invoiceBean.getNumber()) { 9 invoiceBeanList.remove(invoiceBean); 10 recordBeanList.remove(recordBean); 11 break; 12 } 13 } 14 } 15 16 unMarkBeanList.addAll(invoiceBeanList); 17 18 return unMarkBeanList; 19 } 将相同的移除掉，剩余的就是不同的\n保存结果 这里光有比对结果不行，还需要修改表格，将不同的标记出来，以备人工查账\n保存 sheet 的方法 1 public static void saveWorkbook(String path, Workbook workbook) throws IOException { 2 File file = new File(path); 3 workbook.write(new FileOutputStream(file)); 4 } 5 6 public static void backupSheet(String path, Workbook workbook) throws IOException { 7 File file = new File(path); 8 String name = file.getName(); 9 String newPath = file.getParentFile().getAbsolutePath() + \u0026#34;\\\\backup\\\\\u0026#34;; 10 String newName = newPath + name + \u0026#34;_\u0026#34; + TimeUtils.getTimeString() + \u0026#34;.bak\u0026#34;; 11 File newFile = new File(newName); 12 newFile.getParentFile().mkdirs(); 13 newFile.createNewFile(); 14 workbook.write(new FileOutputStream(newFile)); 15 } 16 17 public static void saveSheet(Sheet sheet, String path) throws IOException { 18 Workbook workbook = sheet.getWorkbook(); 19 saveWorkbook(path, workbook); 20 } 1package excel.utils; 2 3import java.text.SimpleDateFormat; 4import java.util.Date; 5 6/** 7 * Created by kikt on 2017/2/26. 8 */ 9public class TimeUtils { 10 11}public static String getTimeString() { 12 SimpleDateFormat sdf = new SimpleDateFormat(\u0026#34;yyyyMMdd_HHmmss\u0026#34;); 13 return sdf.format(new Date()); 14} 核心保存的方法是 workbook.write(OutputStream)方法，简单封装了一下，saveSheet()也是封装，参数不同，这里还有一个备份的方法，可以大概看看，简单的说就是修改文件名，加时间戳.bak 后缀，保存成文件\n修改样式 保存和备份文件说完了，这里还需要修改下样式，不然谁知道你最后查出了什么\n1 private static void setStyle(Sheet invoiceSheet, int index, int numberIndex) { 2 for (Row cells : invoiceSheet) { 3 Cell cell = cells.getCell(ExcelUtils.getColumnNumber(\u0026#34;a\u0026#34;)); 4 if (cell != null \u0026amp;\u0026amp; cell.getCellType() == Cell.CELL_TYPE_NUMERIC) { 5 if (index == cell.getNumericCellValue()) { 6 Cell numberCell = cells.getCell(numberIndex); 7 CellStyle cellStyle = invoiceSheet.getWorkbook().createCellStyle(); 8 cellStyle.setFillPattern(HSSFCellStyle.SOLID_FOREGROUND); 9 cellStyle.setFillForegroundColor(HSSFColor.RED.index); 10 numberCell.setCellStyle(cellStyle); 11 } 12 } 13 } 14 } 这里没有封装，只是简单的修改了下 核心代码是\n1CellStyle cellStyle = invoiceSheet.getWorkbook().createCellStyle();//创建一个新单元格样式 2cellStyle.setFillPattern(HSSFCellStyle.SOLID_FOREGROUND);//填充方式是前景色 3cellStyle.setFillForegroundColor(HSSFColor.RED.index);//设置前景色为红色 4numberCell.setCellStyle(cellStyle);//将单元格的样式改为新建的样式 到这里简单的修改样式就结束了，只要在这之后保存 workbook 就可以了\n结语 这篇文章主要是解析和简单的修改，后面可能会涉及到生成文件，到时候再写篇文章吧\n","link":"https://kikt.top/posts/server/java/poi/","section":"posts","tags":["java","poi","excel"],"title":"Poi解析对比excel表格"},{"body":"","link":"https://kikt.top/tags/aidl/","section":"tags","tags":null,"title":"aidl"},{"body":"前言 最近出去面试找工作，被人问到 AIDL，我就回答这个东西我用过，也大概理解，Android 的进程间通信语言嘛\n人家不置可否，那我能咋着呢，毕竟没深入研究过，也没办法，咱只能回来奋发图强了\n写在前面 我以前就看过的一个博客，里面原理代码什么都有，写的水平肯定比我高\n首先字面解释 A=Android IDL=Interface definition language 意译就是 android 接口定义语言，马丹，完全看不明白 算了，就是 Android 官方给我们定义出来跨进程，甚至跨应用通信用的\n开发平台 Android Studio 2.2+Android 手机一部\n新建工程 这个就不说了，跳过 就是新建工程后再建一个 module 也是 android app，功能后面再说\naidl 语法 这里请去看我写在前面，里面比较详细，或者自行 baidu/google，我也了解的不多\n代码示例 最关键的地方到了 其实就是新建一个 aidl 文件\n1// IMyAidlInterface.aidl 2package com.kikt.aidl; 3 4// Declare any non-default types here with import statements 5 6interface IMyAidlInterface { 7 8 void test(int sum,int sum2); 9} 接着 make project，生成下 java 代码 找到生成的代码看下 我靠 好复杂，还是渣格式，这里格式化一下：\n不想看完全代码的可以看下后面的结构图\n1/* 2 * This file is auto-generated. DO NOT MODIFY. 3 * Original file: H:\\\\Git\\\\ASWorkSpace\\\\public\\\\AidlDemo\\\\app\\\\src\\\\main\\\\aidl\\\\com\\\\kikt\\\\aidl\\\\IMyAidlInterface.aidl 4 */ 5package com.kikt.aidl; 6// Declare any non-default types here with import statements 7 8public interface IMyAidlInterface extends android.os.IInterface { 9 /** 10 * Local-side IPC implementation stub class. 11 */ 12 public static abstract class Stub extends android.os.Binder implements com.kikt.aidl.IMyAidlInterface { 13 private static final java.lang.String DESCRIPTOR = \u0026#34;com.kikt.aidl.IMyAidlInterface\u0026#34;; 14 15 /** 16 * Construct the stub at attach it to the interface. 17 */ 18 public Stub() { 19 this.attachInterface(this, DESCRIPTOR); 20 } 21 22 /** 23 * Cast an IBinder object into an com.kikt.aidl.IMyAidlInterface interface, 24 * generating a proxy if needed. 25 */ 26 public static com.kikt.aidl.IMyAidlInterface asInterface(android.os.IBinder obj) { 27 if ((obj == null)) { 28 return null; 29 } 30 android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR); 31 if (((iin != null) \u0026amp;\u0026amp; (iin instanceof com.kikt.aidl.IMyAidlInterface))) { 32 return ((com.kikt.aidl.IMyAidlInterface) iin); 33 } 34 return new com.kikt.aidl.IMyAidlInterface.Stub.Proxy(obj); 35 } 36 37 @Override 38 public android.os.IBinder asBinder() { 39 return this; 40 } 41 42 @Override 43 public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws 44 android.os.RemoteException { 45 switch (code) { 46 case INTERFACE_TRANSACTION: { 47 reply.writeString(DESCRIPTOR); 48 return true; 49 } 50 case TRANSACTION_test: { 51 data.enforceInterface(DESCRIPTOR); 52 int _arg0; 53 _arg0 = data.readInt(); 54 int _arg1; 55 _arg1 = data.readInt(); 56 this.test(_arg0, _arg1); 57 reply.writeNoException(); 58 return true; 59 } 60 } 61 return super.onTransact(code, data, reply, flags); 62 } 63 64 private static class Proxy implements com.kikt.aidl.IMyAidlInterface { 65 private android.os.IBinder mRemote; 66 67 Proxy(android.os.IBinder remote) { 68 mRemote = remote; 69 } 70 71 @Override 72 public android.os.IBinder asBinder() { 73 return mRemote; 74 } 75 76 public java.lang.String getInterfaceDescriptor() { 77 return DESCRIPTOR; 78 } 79 80 @Override 81 public void test(int sum, int sum2) throws android.os.RemoteException { 82 android.os.Parcel _data = android.os.Parcel.obtain(); 83 android.os.Parcel _reply = android.os.Parcel.obtain(); 84 try { 85 _data.writeInterfaceToken(DESCRIPTOR); 86 _data.writeInt(sum); 87 _data.writeInt(sum2); 88 mRemote.transact(Stub.TRANSACTION_test, _data, _reply, 0); 89 _reply.readException(); 90 } finally { 91 _reply.recycle(); 92 _data.recycle(); 93 } 94 } 95 } 96 97 static final int TRANSACTION_test = (android.os.IBinder.FIRST_CALL_TRANSACTION + 0); 98 } 99 100 public void test(int sum, int sum2) throws android.os.RemoteException; 101} 这里生成了一个静态内部类 Stub 方法签名如下\n1public static abstract class Stub extends android.os.Binder implements com.kikt.aidl.IMyAidlInterface 这个类是抽象类 这里类本身实现了对应的接口 IMyAidlInterface，但没有实现我们在 aidl 中定义的方法 test(int,int)方法 这也代表了 test 方法需要我们自己来实现\n另外方法继承了 android.os.Binder，看到这个的时候，我们就知道，这个应该用在什么地方了 对了，和 Service 必须实现的那个接口 onBind 的返回参数一样！\n这里写个类继承下\n1package com.kikt.aidldemo; 2 3import android.app.Service; 4import android.content.Intent; 5import android.os.IBinder; 6import android.os.RemoteException; 7import android.util.Log; 8 9import com.kikt.aidl.IMyAidlInterface; 10 11public class MyService extends Service { 12 private static final String TAG = \u0026#34;MyService\u0026#34;; 13 public MyService() { 14 } 15 16 @Override 17 public IBinder onBind(Intent intent) { 18 return new AidlEntity(); 19 } 20 21 public class AidlEntity extends IMyAidlInterface.Stub{ 22 23 @Override 24 public void test(int sum, int sum2) throws RemoteException { 25 Log.d(TAG, \u0026#34;test() called with: sum = [\u0026#34; + sum + \u0026#34;], sum2 = [\u0026#34; + sum2 + \u0026#34;]\u0026#34;); 26 } 27 } 28} 为了方便，直接写在 service 内部 这里只是简单的做一个日志输出，其他什么也没有干\n同应用调用 这里是同应用调用\n直接看核心代码\n1 bindService(new Intent(this, MyService.class), new ServiceConnection() { 2 @Override 3 public void onServiceConnected(ComponentName name, IBinder service) { 4 IMyAidlInterface test = IMyAidlInterface.Stub.asInterface(service); 5 try { 6 test.test(1, 2); 7 } catch (RemoteException e) { 8 e.printStackTrace(); 9 } 10 } 11 12 @Override 13 public void onServiceDisconnected(ComponentName name) { 14 15 } 16 }, BIND_AUTO_CREATE); 这里就是一个按钮点击后 bindService，然后 connection 会接受到一个 IBinder 的实例，这个实例就是上面 service 的那个\n当然还有一个写法，直接强转也不会报错\n1 bindService(new Intent(this, MyService.class), new ServiceConnection() { 2 @Override 3 public void onServiceConnected(ComponentName name, IBinder service) { 4// IMyAidlInterface test = IMyAidlInterface.Stub.asInterface(service); 5// try { 6// test.test(1, 2); 7// } catch (RemoteException e) { 8// e.printStackTrace(); 9// } 10 MyService.AidlEntity service1 = (MyService.AidlEntity) service; 11 try { 12 service1.test(4,5); 13 } catch (RemoteException e) { 14 e.printStackTrace(); 15 } 16 } 17 18 @Override 19 public void onServiceDisconnected(ComponentName name) { 20 21 } 22 }, BIND_AUTO_CREATE); 效果都是一样的，那么这个什么 aidl 还有个毛用啊，强转就好了\n接着就是高潮了\n跨应用调用 没错，我个人认为最重要的也就是这点了，aidl 可以在不同应用中调用 比如我要做一个提供服务的应用，或者说是同公司的核心组件，而不希望别人知道我的具体实现 这时我直接丢给你我的 aidl 文件，告诉你包名和服务名称，你就去调就好了！\n1ComponentName componentName = new ComponentName( 2 \u0026#34;com.kikt.aidldemo\u0026#34;, \u0026#34;com.kikt.aidldemo.MyService\u0026#34;); 3 Intent intent = new Intent(); 4 intent.setComponent(componentName); 5 6 bindService(intent, new ServiceConnection() { 7 @Override 8 public void onServiceConnected(ComponentName name, IBinder service) { 9 IMyAidlInterface iinterface = IMyAidlInterface.Stub.asInterface(service); 10 try { 11 iinterface.test(10, 20); 12 } catch (RemoteException e) { 13 e.printStackTrace(); 14 } 15 } 16 17 @Override 18 public void onServiceDisconnected(ComponentName name) { 19 20 } 21 }, BIND_AUTO_CREATE); 这里和上面的代码看上去差不多，但是我和原来的不是一个应用，而是第二个应用 这里使用 test 方法时，可以看到提供服务的应用可以输出日志\n而引申下 如果这里有一个算法，实现了两个参数间的计算，那么我们是不是可以得到计算结果呢，比如说一个加密方法，我不需要知道具体实现，只要调用就好了\naidl 修改如下：\n1// IMyAidlInterface.aidl 2package com.kikt.aidl; 3 4// Declare any non-default types here with import statements 5 6interface IMyAidlInterface { 7 8 void test(int sum,int sum2); 9 10 int add(int num,int num2); 11} 内部类实现修改\n1 public class AidlEntity extends IMyAidlInterface.Stub{ 2 3 @Override 4 public void test(int sum, int sum2) throws RemoteException { 5 Log.d(TAG, \u0026#34;test() called with: sum = [\u0026#34; + sum + \u0026#34;], sum2 = [\u0026#34; + sum2 + \u0026#34;]\u0026#34;); 6 } 7 8 @Override 9 public int add(int num, int num2) throws RemoteException { 10 return num + num2; 11 } 12 } 调用者应用的 bindService 中修改如下：\n1bindService(intent, new ServiceConnection() { 2 @Override 3 public void onServiceConnected(ComponentName name, IBinder service) { 4 IMyAidlInterface iinterface = IMyAidlInterface.Stub.asInterface(service); 5 try { 6 iinterface.test(10, 20); 7 } catch (RemoteException e) { 8 e.printStackTrace(); 9 } 10 11 try { 12 int add = iinterface.add(1, 2); 13 Log.d(\u0026#34;MainActivity\u0026#34;, \u0026#34;add:\u0026#34; + add); 14 } catch (RemoteException e) { 15 e.printStackTrace(); 16 } 17 } 18 19 @Override 20 public void onServiceDisconnected(ComponentName name) { 21 22 } 23 }, BIND_AUTO_CREATE); 在第二个中点击可以看到日志输出 思维发散 其实 aidl 就像一个核心，模块化开发的时候，核心模块不用给你代码，只要你去 aidl 文件，和跨应用的调用方法即可，而你实现后续的业务逻辑，也算是一种解耦的方式吧\n高级/原理 再回到 Stub 的实现中，看下 onTransact 方法就可以看出，其实 aidl 是实现自 android 提供的序列化 通过约定的方式，将方法名的参数和返回值序列化后再通过约定的方式取出来，这样来实现进程间通信 当然具体的内部原理因为我对于 framework 层没有深入研究，传输的过程我不太了解\n1 @Override 2 public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws 3 android.os.RemoteException { 4 switch (code) { 5 case INTERFACE_TRANSACTION: { 6 reply.writeString(DESCRIPTOR); 7 return true; 8 } 9 case TRANSACTION_test: { 10 data.enforceInterface(DESCRIPTOR); 11 int _arg0; 12 _arg0 = data.readInt(); 13 int _arg1; 14 _arg1 = data.readInt(); 15 this.test(_arg0, _arg1); 16 reply.writeNoException(); 17 return true; 18 } 19 case TRANSACTION_add: { 20 data.enforceInterface(DESCRIPTOR); 21 int _arg0; 22 _arg0 = data.readInt(); 23 int _arg1; 24 _arg1 = data.readInt(); 25 int _result = this.add(_arg0, _arg1); 26 reply.writeNoException(); 27 reply.writeInt(_result); 28 return true; 29 } 30 } 31 return super.onTransact(code, data, reply, flags); 32 } 后记 其实 aidl 很方便也是一种跨应用的解决方案，非常实用，面试和工作中都应该用得到，后续如果有机会可以多使用下，就先写这么多吧，谢谢网上的 android 先驱者和大神们!!!\n遨游在 android 知识的海洋中不可自拔的博主\n","link":"https://kikt.top/posts/android/android-aidl/","section":"posts","tags":["junit","aidl","android"],"title":"AIDL 安卓进程间通信/跨应用通信"},{"body":"","link":"https://kikt.top/tags/junit/","section":"tags","tags":null,"title":"junit"},{"body":"最近使用 AndroidStudio 的时候想要使用单元测试 因为有一些数据需要 Activity 的支持， 从网上找了一些教程，但自己使用时感觉不理想，发现都是一些业务逻辑的类，很少有直接针对 Activity 的单元测试 所以想自己写一个简单的 demo\n开发环境 Android Studio 2.2\n步骤 首先新建工程 然后会自动生成 MainActivity\nMainActivity 代码如下\n1public class MainActivity extends AppCompatActivity { 2 3 // Used to load the \u0026#39;native-lib\u0026#39; library on application startup. 4 static { 5 System.loadLibrary(\u0026#34;kikt-camera\u0026#34;); 6 } 7 8 @Override 9 protected void onCreate(Bundle savedInstanceState) { 10 super.onCreate(savedInstanceState); 11 setContentView(R.layout.activity_main); 12 13 // Example of a call to a native method 14 TextView tv = (TextView) findViewById(R.id.sample_text); 15 tv.setText(stringFromJNI()); 16 } 17 18 /** 19 * A native method that is implemented by the \u0026#39;native-lib\u0026#39; native library, 20 * which is packaged with this application. 21 */ 22 public native String stringFromJNI(); 23 24 public void showTest() { 25 Log.d(\u0026#34;MainActivity\u0026#34;, stringFromJNI()); 26 } 27} 这里直接创建 Test 文件 点 ok 后 会生成一个文件\n我在这里对代码进行了修改 修改如下\n1@RunWith(JUnit4.class) 2public class MainActivityTest { 3 4 @Rule 5 public ActivityTestRule\u0026lt;MainActivity\u0026gt; rule = new ActivityTestRule\u0026lt;\u0026gt;(MainActivity.class); 6 7 @Test 8 public void stringFromJNI() throws Exception { 9 MainActivity activity = rule.getActivity(); 10 TextView textView = (TextView) activity.findViewById(R.id.sample_text); 11 String s = textView.getText().toString(); 12 Log.d(\u0026#34;MainActivityTest\u0026#34;, s); 13 Log.d(\u0026#34;MainActivityTest\u0026#34;, activity.stringFromJNI()); 14 } 15 16} 这里通过 rule.getActivity()可以直接拿到 Activity 对象 可以获取到 View 对象 接着就可以将测试的相关所有逻辑写在里面了\n这里可以直接点击运行 test 了 我这里只是做了几个日志输出，可以从 Android monitor 里面看到日志输出 后记 demo 比较简单，没有什么多余的东西，仅做参考\n","link":"https://kikt.top/posts/android/android-junit/","section":"posts","tags":["junit","android"],"title":"Android Studio 简单的JunitTest"},{"body":"AndroidStudio2.2 中 对于 ndk/jni 建议使用 cmake 进行编译 而对于纯粹的 android 程序员来说，cmake 不是经常接触的方案，我在遇到 jni 相关时也遇到了一些问题，这里抛砖引玉吧\n开发环境 Android SDK/NDK Android Studio 2.2 友情提示：更新请科学上网\n准备工作 其实 demo 永远是最好的老师 我们直接自己创建一个 Project 好在 AS 对于对于 ndk 的支持越来越友好 选中 c++支持，这样创建出来的 gradle 文件就会自动创建相关的，有助于我们学习\n自动生成的核心文件 build.gradle MainActivity.java native-lib.cpp CMakelists.txt\nMainActivity.java MainActivity.java\n1 System.loadLibrary(\u0026#34;native-lib\u0026#34;); //加载native-lib库 2 ... 3 public native String stringFromJNI();//指向cpp文件中的方法 左边有一个箭头，这个点击可以直接跳到 cpp 文件中的方法\ngradle project 级别的和传统没有差别 看 module 级的\n1apply plugin: \u0026#39;com.android.application\u0026#39; 2 3android { 4 ... 5 externalNativeBuild { 6 cmake { 7 cppFlags \u0026#34;\u0026#34; 8 } 9 } 10 } 11 ... 12 externalNativeBuild { 13 cmake { 14 path \u0026#34;CMakeLists.txt\u0026#34; 15 } 16 } 17 18 19 ndk{ 20 abiFilters \u0026#39;armeabi\u0026#39; //打包的cpu方案 21 } 22} 23 24dependencies { 25 ... 26} 看到核心差别就是这几句 cppFlags 先不去管 这里有一个path \u0026quot;CMakeLists.txt\u0026quot; 这个指向了一个 txt 文件 打开这个文件\nCmakeLists.txt 总体语法是 #为单行注释\n指定最低版本号 添加库文件 找到指定的库 连接目标库\n通过观察这里有 native-lib 的地方就是指定的几处\n创建自己的 library 接下来模仿这个语法来写个自己的库 在 cpp 文件夹下，添加一个 math-lib.cpp math-lib.h\n接着修改 cmake\n1... 2 3cmake_minimum_required(VERSION 3.4.1)#最低版本号 4 5... 6 7add_library( ... 8 native-lib #库的名称 9 10 ... 11 SHARED #是否设置为共享库 12 13 ... 14 src/main/cpp/native-lib.cpp #库文件的指向 15 ) 16 17add_library(#这里是我自定义的demo库 18 math-lib 19 SHARED 20 src/main/cpp/math-lib.cpp 21 src/main/cpp/math-lib.h 22 ) 23... 24 25find_library( # Sets the name of the path variable. 26 log-lib 27... 28 log ) 29 30... 31 32target_link_libraries( # Specifies the target library. 33 native-lib 34 math-lib 35 ... 36 ${log-lib} ) 在 native-lib 的位置填写自己的 library 名称，和文件位置 接着在 MainActivity 中写一个 native 方法 private native int add(int a,int b);\n在静态代码块中 加载库 库的名称是 math-lib\n1static{ 2 System.loadLibrary(\u0026#34;math-lib\u0026#34;); 3} 修改 cpp 文件\n1#include \u0026lt;jni.h\u0026gt; 2#include \u0026lt;string\u0026gt; 3 4// 5// Created by kikt on 2016/10/21. 6// 7 8#include \u0026#34;math-lib.h\u0026#34; 9extern \u0026#34;C\u0026#34; 10JNIEXPORT jint JNICALL 11Java_com_kikt_ndkdemo1_MainActivity_add(JNIEnv *env, jobject instance, jint a, jint b) { 12 return a+b; 13} 这里比较简单，返回 a+b 的返回值就可以了\n不会写 JNI 的 c 方法名的朋友，AS 现在已经可以通过提示自动生成的，好方便！\n当然我们还是需要知道下如何自己生成，万一哪天 AS 抽风了呢 这里推荐一个我很久前看到的 blog\n这里有一个特别要注意的地方，因为这个是 cpp 文件 和 c 文件不同的是 必须加上 extern \u0026quot;C\u0026quot; 防止编译器将方法改名，否则会造成 natvie 方法调用不到，抛出异常\n后记 会写这个文章是因为头一阵研究视频编解码的时候引入了一个第三方库的时候遇到了编译不通过，无奈换回 AS2.1 的问题正常编译运行的问题\n因为 AndroidStudio 2.2 正式版刚刚开放加载一段时间，有一些朋友在 ndk 开发时可能会遇到各种问题，这里仅做一个入门的参考 欢迎留言交流\n","link":"https://kikt.top/posts/android/android-studio-2-2-ndk-and-gradle-config/","section":"posts","tags":["junit","android"],"title":"Android Studio 2.2 ndk开发环境 gradle配置"},{"body":"","link":"https://kikt.top/tags/butterknife/","section":"tags","tags":null,"title":"butterknife"},{"body":"写在前面： 在 github 上 butterknife 的 star 有 11000+ 为啥有这么多人用这个插件 两点： 1、自动化 2、有人更新和维护\nGRADLE 根目录的 build.gradle 也就是 project 级\n1buildscript { 2 repositories { 3 mavenCentral() 4 } 5 dependencies { 6 classpath \u0026#39;com.neenbedankt.gradle.plugins:android-apt:1.8\u0026#39; 7 } 8} module 级别\n1apply plugin: \u0026#39;android-apt\u0026#39; 2 3android { 4 ... 5} 6 7dependencies { 8 compile \u0026#39;com.jakewharton:butterknife:8.4.0\u0026#39; 9 apt \u0026#39;com.jakewharton:butterknife-compiler:8.4.0\u0026#39; 10} 基本的注入我想大部分人都知道\nButterKnife.bind(this) 这里可以是 View，Activity 等等\n还支持 Android annotations 的几个注解\n1@Optional //可选 2@Nullable //可能为空 在 8.4.0 中最大的改动可能就是使用 R2 代替 R 文件 我觉得这个可能是为了自动生成 R 文件经常出现问题的解决方案 应该是和 Android Studio 中的 instant run 有冲突\n变量的注入\n1@BindView 2TextView textView; 3 4@BindString(R.string.title) 5String title; 6 7@BindDrawable(R.drawable.graphic) 8Drawable graphic; 9 10@BindColor(R.color.red) 11int red; 12 13@BindDimen(R.dimen.spacer) Float spacer; // int (for pixel size) or float (for exact value) field 上面来自于官网\n可以修改 View 的属性 An Android Property can also be used with the apply method.\n1ButterKnife.apply(nameViews, View.ALPHA, 0.0f); onclick 事件\n1//单View的写法 2@OnClick(R.id.submit) 3public void submit(View view) { 4 // TODO submit data to server... 5} 6 7//也可以不写View参数 8@OnClick(R.id.submit) 9public void submit() { 10 // TODO submit data to server... 11} 12 13//也可以将参数进行强转 14@OnClick(R.id.submit) 15public void sayHi(Button button) { 16 button.setText(\u0026#34;Hello!\u0026#34;); 17} 18 19//也可以是一个数组，这里批量注入 20@OnClick({ R.id.door1, R.id.door2, R.id.door3 }) 21public void pickDoor(DoorView door) { 22 if (door.hasPrizeBehind()) { 23 Toast.makeText(this, \u0026#34;You win!\u0026#34;, LENGTH_SHORT).show(); 24 } else { 25 Toast.makeText(this, \u0026#34;Try again\u0026#34;, LENGTH_SHORT).show(); 26 } 27} 这个暂时没有试验，稍后试验 1// Custom views can bind to their own listeners by not specifying an ID. 2public class FancyButton extends Button { 3 @OnClick 4 public void onClick() { 5 // TODO do something! 6 } 7} 一些特殊的点击事件\n1@OnItemSelected(R.id.list_view) 2void onItemSelected(int position) { 3 // TODO ... 4} 5 6@OnItemSelected(value = R.id.maybe_missing, callback = NOTHING_SELECTED) 7void onNothingSelected() { 8 // TODO ... 9} 官网还有一个 bouns，看起来是省去了强转，可以用在 dialog 等地方\nBONUS\nAlso included are findById methods which simplify code that still has to find views on a View, Activity, or Dialog. It uses generics to infer the return type and automatically performs the cast.\n1View view = LayoutInflater.from(context).inflate(R.layout.thing, null); 2TextView firstName = ButterKnife.findById(view, R.id.first_name); 3TextView lastName = ButterKnife.findById(view, R.id.last_name); 4ImageView photo = ButterKnife.findById(view, R.id.photo); Add a static import for ButterKnife.findById and enjoy even more fun.\nandroid studio 中有插件哦 搜索 Butterknife 默认快捷键是 alt+insert 然后选 Butterknife 那个 当然有一个 ctrl+shift+B 的快捷键，应该是和其他的有冲突了\n暂时先这样\n","link":"https://kikt.top/posts/android/butterknife8-1/","section":"posts","tags":["android","butterknife"],"title":"Butterknife8.4.0的一些问题"},{"body":"其实 android 的剪切板使用不算复杂 而且一般的应用需求不会太复杂，只要简单的应用即可\n一般都是点击事件时将某段文字复制到剪切板中\nAndroid 中的剪切板是使用ClipboardManager来管理的 获取这个对象的方法是\n1Context.getSystemService(Context.CLIPBOARD_SERVICE); 2cm = (ClipboardManager) getSystemService(CLIPBOARD_SERVICE); 在 API11 后 使用的是\n1android.content.ClipboardManager API11 前 使用的是\n1android.text.ClipboardManager 前者的方法声明是\n1public class ClipboardManager extends android.text.ClipboardManager 也就是说即使在 API11 后也可以使用旧的方法来获取和修改剪切板内的内容\nCharSequence text = cm.getText();可以获取到剪切板内的内容 使用cm.setText(\u0026quot;复制到剪切板\u0026quot;);可以将内容复制到剪切板内\n如果你的应用 minSDK 在 11 以上，可以直接用新的方法，毕竟老的已经过时了\n使用如下的代码\n1 cm = (ClipboardManager) getSystemService(CLIPBOARD_SERVICE); 2 ClipData clipData = ClipData.newPlainText(\u0026#34;title\u0026#34;, \u0026#34;content23\u0026#34;); 3 cm.setPrimaryClip(clipData); 可以简单的达到效果\n这个有一个对象ClipData\n1package com.dn.clipbroaddemo; 2 3import android.content.ClipData; 4import android.content.ClipDescription; 5import android.content.ClipboardManager; 6import android.os.Bundle; 7import android.support.v7.app.AppCompatActivity; 8import android.util.Log; 9 10public class MainActivity extends AppCompatActivity { 11 12 private ClipboardManager cm; 13 14 @Override 15 protected void onCreate(Bundle savedInstanceState) { 16 super.onCreate(savedInstanceState); 17 setContentView(R.layout.activity_main); 18 19 cm = (ClipboardManager) getSystemService(CLIPBOARD_SERVICE); 20 21// ClipData clipData = ClipData.newPlainText(\u0026#34;title\u0026#34;, \u0026#34;content23\u0026#34;); 22// cm.setPrimaryClip(clipData); 23// 24// ClipData primaryClip = cm.getPrimaryClip(); 25 26 ClipData data = new ClipData(new ClipDescription(\u0026#34;label\u0026#34;,new String[]{ClipDescription.MIMETYPE_TEXT_PLAIN}), 27 new ClipData.Item(\u0026#34;test\u0026#34;)); 28 data.addItem(new ClipData.Item(\u0026#34;test0\u0026#34;)); 29 data.addItem(new ClipData.Item(\u0026#34;test1\u0026#34;)); 30 31 for (int i = 0; i \u0026lt; data.getItemCount(); i++) { 32 ClipData.Item item = data.getItemAt(i); 33 Log.d(\u0026#34;MainActivity\u0026#34;, \u0026#34;item:\u0026#34; + item); 34 } 35 36 } 37} 日志输出：\n109-18 15:49:26.977 30431-30431/com.dn.clipbroaddemo D/MainActivity: item:ClipData.Item { T:test } 209-18 15:49:26.977 30431-30431/com.dn.clipbroaddemo D/MainActivity: item:ClipData.Item { T:test0 } 309-18 15:49:26.977 30431-30431/com.dn.clipbroaddemo D/MainActivity: item:ClipData.Item { T:test1 } 这个对象中可以放很多 Item，我想目的是为了扩展剪切板的功能吧 构造方法中需要传入一个ClipDescription从字面意义上看应该是用于描述 Data\n1ClipDescription primaryClipDescription = cm.getPrimaryClipDescription(); 2ClipData primaryClip = cm.getPrimaryClip(); 还可以从剪切板中取出对应的描述和 data 信息\n总结来说： 获取 manager 对象 新建剪切板的内容对象 将对象放入剪切板中\n","link":"https://kikt.top/posts/android/android-clipboard-manager/","section":"posts","tags":["android","Clipboard"],"title":"Android剪切板的简单解析"},{"body":"","link":"https://kikt.top/tags/clipboard/","section":"tags","tags":null,"title":"Clipboard"},{"body":"","link":"https://kikt.top/tags/retrofit/","section":"tags","tags":null,"title":"retrofit"},{"body":"retrofit 的简单二次封装 基于上次的后，可以对 retrofit 简单的二次封装\n1public interface HttpURL { 2 String baseUrl = \u0026#34;http://127.0.0.1:32001/\u0026#34;; 3} 1public class RequestUtils { 2 3 private static OkHttpClient client; 4 private static Retrofit retrofit; 5 6 private RequestUtils() { 7 } 8 9 static { 10 client = new OkHttpClient() 11 .newBuilder() 12 .connectTimeout(8, TimeUnit.SECONDS) 13 .readTimeout(8, TimeUnit.SECONDS) 14 .writeTimeout(8, TimeUnit.SECONDS) 15 .addInterceptor(new HttpInterceptor()) 16 .build(); 17 18 retrofit = new Retrofit.Builder() 19 .baseUrl(HttpURL.baseUrl) 20 .client(client) 21 .addConverterFactory(StringConverterFactory.create()) 22 .build(); 23 } 24 25 public static String post(String url, String body) throws IOException { 26 RequestServer requestServer = retrofit.create(RequestServer.class); 27 String[] path = url.split(\u0026#34;/\u0026#34;); 28 Call\u0026lt;String\u0026gt; call = requestServer.post(path[0], path[1], body); 29 Response\u0026lt;String\u0026gt; response = call.execute(); 30 return response.body(); 31 } 32 33 public static void main(String[] args) throws IOException { 34 String hello = post(\u0026#34;ping/test\u0026#34;, \u0026#34;hello\u0026#34;); 35 System.out.println(hello); 36 } 37} 输出结果\n1{ \u0026#34;code\u0026#34;: 200, \u0026#34;content\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;成功\u0026#34; } } 这里的 post 方法就是传入 url，请求参数是 body，返回值就是 String 类型，如果需要对 string，如果需要对返回值进行处理，再接受 hello 的对应参数进行处理即可\n同样的道理，现在很多的网站可以使用 put/delete/get/post 等不同的 method 方法在同一个 URL 下区分不同的业务逻辑和返回值，只要进行对应的封装即可\n","link":"https://kikt.top/posts/android/retroift-simple-packaging/","section":"posts","tags":["android","retrofit"],"title":"Retroift简单二次封装"},{"body":"retrofit 初探 引用 maven 1\u0026lt;dependency\u0026gt; 2 \u0026lt;groupId\u0026gt;com.squareup.retrofit2\u0026lt;/groupId\u0026gt; 3 \u0026lt;artifactId\u0026gt;retrofit\u0026lt;/artifactId\u0026gt; 4 \u0026lt;version\u0026gt;2.1.0\u0026lt;/version\u0026gt; 5\u0026lt;/dependency\u0026gt; gradle 1 api \u0026#39;com.squareup.retrofit2:retrofit:2.1.0\u0026#39; github 个人意见 其实，最适合使用 retrofit 的是 rest 请求类的交互，如果具体的请求参数是以 url 区分业务逻辑，请求参数通过 json 进行的，那其实 retrofit 不太适用\n俗话说，demo 是最好的学习 先来看看怎么定义业务逻辑\n1public interface GitHubService { 2 @GET(\u0026#34;users/{user}/repos\u0026#34;) 3 Call\u0026lt;List\u0026lt;Repo\u0026gt;\u0026gt; listRepos(@Path(\u0026#34;user\u0026#34;) String user); 4} 这里的{user}是一个会在实际使用时会被动态改变的，会根据 String user 中的变量而改变\n1public class RetrofitDemo { 2 private static OkHttpClient client; 3 4 static { 5 client = new OkHttpClient.Builder() 6 .addInterceptor(new HttpInterceptor()) 7 .build(); 8 } 9 10 public static void main(String[] args) throws IOException { 11 Retrofit retrofit = new Retrofit.Builder() 12 .baseUrl(\u0026#34;http://127.0.0.1:32001\u0026#34;) 13 .addConverterFactory(GsonConverterFactory.create()) 14 // .addConverterFactory(StringConverterFactory.create()) 15 .client(client) 16 .build(); 17 18 RequestServer requestServer = retrofit.create(RequestServer.class); 19 TestEntity bean = new TestEntity(); 20 bean.setTest(\u0026#34;text1\u0026#34;); 21 Call\u0026lt;ResponseEntity\u0026gt; call = requestServer.post(\u0026#34;ping\u0026#34;, \u0026#34;test\u0026#34;, bean); 22 Response\u0026lt;ResponseEntity\u0026gt; response = call.execute(); 23 ResponseEntity body = response.body(); 24 System.out.println(body.toString()); 25 } 26} 在上述的代码中 访问的 url 是 http://127.0.0.1:32001/ping/test 请求的方式是post 返回值是Call\u0026lt;ResponseEntity\u0026gt; 这里的具体访问是框架实现的 框架会将请求的 Bean 转换成 Json Post 请求到指定的 url\n然后返回值也会被转化成对应的类型 这里依赖的是ConverterFactory 这里的使用的GsonConverterFactory 是官方 Demo 中的一个converter\n用于实现 bean 到 json 的转化，再将回包转化成 bean 返回\n看下GsonConverterFactory的实现\n这里其实就 4 个关键方法\n1 @Override 2 public Converter\u0026lt;ResponseBody, ?\u0026gt; responseBodyConverter(Type type, Annotation[] annotations, 3 Retrofit retrofit) { 4 TypeAdapter\u0026lt;?\u0026gt; adapter = gson.getAdapter(TypeToken.get(type)); 5 return new GsonResponseBodyConverter\u0026lt;\u0026gt;(gson, adapter); 6 } 7 8 @Override 9 public Converter\u0026lt;?, RequestBody\u0026gt; requestBodyConverter(Type type, 10 Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) { 11 TypeAdapter\u0026lt;?\u0026gt; adapter = gson.getAdapter(TypeToken.get(type)); 12 return new GsonRequestBodyConverter\u0026lt;\u0026gt;(gson, adapter); 13 } 1@Override public RequestBody convert(T value) throws IOException { 2 Buffer buffer = new Buffer(); 3 Writer writer = new OutputStreamWriter(buffer.outputStream(), UTF_8); 4 JsonWriter jsonWriter = gson.newJsonWriter(writer); 5 adapter.write(jsonWriter, value); 6 jsonWriter.close(); 7 return RequestBody.create(MEDIA_TYPE, buffer.readByteString()); 8 } 1 @Override public T convert(ResponseBody value) throws IOException { 2 JsonReader jsonReader = gson.newJsonReader(value.charStream()); 3 try { 4 return adapter.read(jsonReader); 5 } finally { 6 value.close(); 7 } 8 } 前两个方法用于生成 Converter\n后面的是 Converter 中的方法 用于将 bean 转化成 RequestBody 和将 ResponseBody 转化成 bean\n仿照这个自己写一个 Factory StringConverterFactory\n1public final class StringConverterFactory extends Converter.Factory { 2 3 public static StringConverterFactory create() { 4 return new StringConverterFactory(); 5 } 6 7 private StringConverterFactory() { 8 } 9 10 @Override 11 public Converter\u0026lt;ResponseBody, ?\u0026gt; responseBodyConverter(Type type, Annotation[] annotations, Retrofit retrofit) { 12 return new StringResponseBodyConverter(); 13 } 14 15 @Override 16 public Converter\u0026lt;?, RequestBody\u0026gt; requestBodyConverter(Type type, Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) { 17 return new StringRequestBodyConverter(); 18 } 19} StringRequestBodyConverter\n1final class StringRequestBodyConverter implements Converter\u0026lt;String, RequestBody\u0026gt; { 2 3 StringRequestBodyConverter() { 4 } 5 6 @Override 7 public RequestBody convert(String s) throws IOException { 8 return RequestBody.create(MediaType.parse(\u0026#34;text/json\u0026#34;), s); 9 } 10} StringResponseBodyConverter\n1final class StringResponseBodyConverter implements Converter\u0026lt;ResponseBody, String\u0026gt; { 2 3 StringResponseBodyConverter() { 4 } 5 6 @Override 7 public String convert(ResponseBody value) throws IOException { 8 9 try { 10 return value.string(); 11 } finally { 12 value.close(); 13 } 14 } 15} 其实就是 Factory 中的两个方法控制使用哪个转化器转化 两个 Convert 控制怎么转化\n","link":"https://kikt.top/posts/android/retroift-first-develop/","section":"posts","tags":["android","retrofit"],"title":"Retroift初探"},{"body":"","link":"https://kikt.top/series/","section":"series","tags":null,"title":"Series"}]